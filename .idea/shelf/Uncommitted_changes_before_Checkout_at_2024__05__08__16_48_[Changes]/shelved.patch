Index: .idea/shelf/Uncommitted_changes_before_Update_at_01_05_2024_13_06__Changes_.xml
===================================================================
diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_01_05_2024_13_06__Changes_.xml b/.idea/shelf/Uncommitted_changes_before_Update_at_01_05_2024_13_06__Changes_.xml
deleted file mode 100644
--- a/.idea/shelf/Uncommitted_changes_before_Update_at_01_05_2024_13_06__Changes_.xml	(revision 2de02ed084cf3446ea9c0020a85b83e8f9ecb48d)
+++ /dev/null	(revision 2de02ed084cf3446ea9c0020a85b83e8f9ecb48d)
@@ -1,9 +0,0 @@
-<changelist name="Uncommitted_changes_before_Update_at_01_05_2024_13_06_[Changes]" date="1714561590836" recycled="true" deleted="true">
-  <option name="PATH" value="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_01_05_2024_13_06_[Changes]/shelved.patch" />
-  <option name="DESCRIPTION" value="Uncommitted changes before Update at 01/05/2024 13:06 [Changes]" />
-  <binary>
-    <option name="BEFORE_PATH" value="data/sus.amogus" />
-    <option name="AFTER_PATH" value="data/sus.amogus" />
-    <option name="SHELVED_PATH" value="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_01_05_2024_13_06_[Changes]/sus.amogus" />
-  </binary>
-</changelist>
\ No newline at end of file
Index: .idea/shelf/Uncommitted_changes_before_Update_at_01_05_2024_13_38_[Changes]1/shelved.patch
===================================================================
diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_01_05_2024_13_38_[Changes]1/shelved.patch b/.idea/shelf/Uncommitted_changes_before_Update_at_01_05_2024_13_38_[Changes]1/shelved.patch
deleted file mode 100644
--- a/.idea/shelf/Uncommitted_changes_before_Update_at_01_05_2024_13_38_[Changes]1/shelved.patch	(revision 2de02ed084cf3446ea9c0020a85b83e8f9ecb48d)
+++ /dev/null	(revision 2de02ed084cf3446ea9c0020a85b83e8f9ecb48d)
@@ -1,103 +0,0 @@
-Index: src/main/java/org/game/Map/Map.java
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
-<+>package main.java.org.game.Map;\r\n\r\nimport main.java.org.game.Graphics.Image;\r\nimport main.java.org.game.Isten;\r\nimport main.java.org.game.physics.Collider;\r\nimport main.java.org.game.updatable.Updatable;\r\nimport main.java.org.linalg.Vec2;\r\n\r\nimport java.util.*;\r\n\r\n\r\npublic class Map extends Updatable {\r\n    private Mapgenerator mapgenerator;\r\n    ArrayList<Room> rooms;\r\n    private UnitRoom[][] unitRooms;\r\n    private final int mapRowSize;\r\n    private final int mapColumnSize;\r\n    private EdgeManager edgeManager;\r\n    private final int minRoomSize;\r\n    private boolean isGenerated = false;\r\n    //private boolean\r\n\r\n    @Override\r\n    public void onStart(Isten isten) {\r\n\r\n        Mapgenerator mapgenerator = new Mapgenerator(this, isten);\r\n        mapgenerator.generateSideWalls();\r\n        //printMap();\r\n    }\r\n\r\n    public void init(Isten isten) {\r\n        this.edgeManager = new EdgeManager(isten);\r\n        this.mapgenerator = new Mapgenerator(this, isten);\r\n        mapgenerator.generate(minRoomSize);\r\n        isGenerated = true;\r\n    }\r\n\r\n    public Map(int rowNumber, int columnNumber, int minRoomSize){\r\n        this.mapRowSize = rowNumber;\r\n        this.mapColumnSize = columnNumber;\r\n        this.minRoomSize = minRoomSize;\r\n        //unitrooms is set in the generator --> onstart\r\n        this.rooms = new ArrayList<>();\r\n        initUnitRooms();\r\n\r\n    }\r\n\r\n    //for testing\r\n    boolean merged = false;\r\n    double delta = 0;\r\n    int cnt = 0;\r\n    int r = 0;\r\n    @Override\r\n    public void onUpdate(Isten isten, double deltaTime) {\r\n        //for testing\r\n        delta += deltaTime;\r\n        if (delta > 3 && cnt < 4 && !merged) {\r\n            //mergeRooms(rooms.get(0), rooms.get(0).getAdjacentRooms().get(0), isten);\r\n            /*if (!splitRooms(rooms.get(r), isten)) r++;\r\n            else {\r\n                r = 0;\r\n            }\r\n\r\n             */\r\n            System.out.println();\r\n            System.out.println();\r\n            //printMap();\r\n            cnt++;\r\n            delta = 0;\r\n            merged = true;\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void onDestroy() {\r\n\r\n    }\r\n    public void initUnitRooms(){\r\n        unitRooms = new UnitRoom[mapRowSize][mapColumnSize];\r\n        for(int i = 0; i<mapRowSize;i++)\r\n        {\r\n            for(int j = 0;j<mapColumnSize;j++)\r\n            {\r\n                unitRooms[i][j] = new UnitRoom(new Vec2(j,i));\r\n            }\r\n        }\r\n    }\r\n\r\n    //csak akkor ha minden ajto nyitva van!!\r\n    //a slitelesnel csak a minroomsize fele engedelyezett\r\n    private boolean splitRooms(Room r1, Isten isten)\r\n    {\r\n        if(r1.getUnitRooms().size() < minRoomSize) return false;\r\n        //egyenlőre minden szoba ami splittel lesz createlve ilyen type-val rendelkezik\r\n        int newID = generateNewRoomID(); //már kész van, teszt miatt nincs hasznalva\r\n        //int newId = 999;\r\n        Room newRoom = new Room(newID);\r\n        int lowestRowIdx = getRoomWithLowestRowIdx(r1);\r\n        ArrayList<UnitRoom> addableUnitRooms = new ArrayList<>();\r\n        int distance = 0;\r\n        ArrayList<UnitRoom> UnitRoomsWithDistanceXFromLowestRow;\r\n        //addig, amíg az új szoba a méret fele nem lesz\r\n        while(addableUnitRooms.size()<r1.getUnitRooms().size()/2){\r\n            UnitRoomsWithDistanceXFromLowestRow=getUnitRoomsWithXDistanceFromLowestRowIdxInOrderByColumn(r1,lowestRowIdx,distance++); //tavolsag novelese, es igy soronkent egyesevel balrol jobbra az osszes unitroom hozzaadasa, amig kell\r\n            for(UnitRoom addableUnitRoom:UnitRoomsWithDistanceXFromLowestRow){\r\n                if(addableUnitRooms.size()<r1.getUnitRooms().size()/2 )\r\n                {\r\n                    addableUnitRooms.add(addableUnitRoom);\r\n                }\r\n\r\n            }\r\n        }\r\n        ArrayList<UnitRoom> oldRoomWithoutNewRoom = getDifference(r1.getUnitRooms(),addableUnitRooms);\r\n        //ellenorzom, hogy osszefuggoek lennének-e: ha igen:\r\n        if( kruskalAlgoImplementation(oldRoomWithoutNewRoom) && kruskalAlgoImplementation(addableUnitRooms)) {\r\n            // removeoljuk a szomszedos roomok szomszedossagi listaibol a szobat, es a func vegen hozzaadjuk a ket szetvalasztott szoba egyiket/mindekettot\r\n            for(Room neighbourRoom : r1.getAdjacentRooms()){\r\n                neighbourRoom.getAdjacentRooms().remove(r1);\r\n            }\r\n            for (UnitRoom addUnitRoomToNewRoom : addableUnitRooms) {\r\n                //kivesszük az előző szobából a  aunitroomot\r\n                addUnitRoomToNewRoom.getOwnerRoom().getUnitRooms().remove(addUnitRoomToNewRoom);\r\n                addUnitRoomToNewRoom.setOwnerRoom(newRoom);\r\n                //hozzáadjuk az új szobához a unitroomot\r\n                newRoom.getUnitRooms().add(addUnitRoomToNewRoom);\r\n            }\r\n            rooms.add(newRoom);\r\n            newRoom.setAdjacentRooms();\r\n            r1.setAdjacentRooms();\r\n\r\n            //set the images\r\n            for(UnitRoom unitRoom : newRoom.getUnitRooms()) {\r\n                unitRoom.addRightImage(isten);\r\n            }\r\n            //update nodeRooms and generate the new ones\r\n            //also updates the images and colliders\r\n            edgeManager.updateEdgesAfterSplit(r1, newRoom);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n\r\n    public static ArrayList<UnitRoom> getDifference(ArrayList<UnitRoom> u1, ArrayList<UnitRoom> u2)\r\n    {\r\n        ArrayList<UnitRoom> difference = new ArrayList<>();\r\n        for (UnitRoom element : u1) {\r\n            if (!u2.contains(element)) {\r\n                difference.add(element);\r\n            }\r\n        }\r\n        return difference;\r\n    }\r\n    //nem biztos hogy így a legjobb\r\n    private boolean wouldRoomBeCoherent(ArrayList<UnitRoom> newRoomUnits)\r\n    {\r\n        UnitRoom starterRoom = newRoomUnits.get(0);\r\n        ArrayList<UnitRoom> coherentGraph = new ArrayList<>();\r\n        coherentGraph.add(starterRoom);\r\n        for(int i = 0;i<newRoomUnits.size();i++){\r\n            for(UnitRoom unitRoomToBeAddedToGraph : newRoomUnits){\r\n                 /*ha a size i-vel egyenlő, vagy kisebb nála, akkor tudjuk, hogy nem alkotnak összefüggő gráfot a UnitRoomok a Roomban,\r\n                    mert különben az előző körhöz képest legalább 1-et fel kellett volna tuidjak venni, vagy pedig már előtte többet kellett volna tudjak felvenni,\r\n                    rekurzív gondolat, mukodik (remelem)*/\r\n                if(coherentGraph.size()> i)\r\n                {\r\n                    if (!unitRoomToBeAddedToGraph.equals(coherentGraph.get(i))\r\n                            && !coherentGraph.contains(unitRoomToBeAddedToGraph)\r\n                            && unitRoomToBeAddedToGraph.isAdjacent(coherentGraph.get(i)))\r\n                    {\r\n                        coherentGraph.add(unitRoomToBeAddedToGraph);\r\n                        //break; ezzel valszeg effektivebb\r\n                    }\r\n                }\r\n                else{\r\n                    System.out.println(\"Nem lennenek koherensek a szobak\");\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        //mivel minden indexen vegig tudtunk menni ezert tudunk truet returnolni, azert biztonsag kedveert meg egy kontrollt bennhagyok\r\n        if(coherentGraph.size() == newRoomUnits.size()) return true;\r\n            //hogyha nem egyenlok akkor false menjen ki, bar egyenloknek kene lenniuk\r\n        else return false;\r\n    }\r\n    //elozo fv, vagyis wouldRoomBeCoherent atirasa generikusra, es akkor egy wouldMapBeCoherent fv-t is helyettesit.\r\n    private<T extends Graph> boolean kruskalAlgoImplementation(ArrayList<T> newCoherentElements)\r\n    {\r\n        T starterRoom = newCoherentElements.get(0);\r\n        ArrayList<T> coherentGraph = new ArrayList<>();\r\n        coherentGraph.add(starterRoom);\r\n        for(int i = 0;i<newCoherentElements.size();i++){\r\n            for(T ElementToBeAddedToGraph : newCoherentElements){\r\n                 /*ha a size i-vel egyenlő, vagy kisebb nála, akkor tudjuk, hogy nem alkotnak összefüggő gráfot a UnitRoomok a Roomban,\r\n                    mert különben az előző körhöz képest legalább 1-et fel kellett volna tuidjak venni, vagy pedig már előtte többet kellett volna tudjak felvenni,\r\n                    rekurzív gondolat, mukodik (remelem)*/\r\n                if(coherentGraph.size()> i)\r\n                {\r\n                    if (!ElementToBeAddedToGraph.equals(coherentGraph.get(i))\r\n                            && !coherentGraph.contains(ElementToBeAddedToGraph)\r\n                            && ElementToBeAddedToGraph.isAdjacent(coherentGraph.get(i)))\r\n                    {\r\n                        coherentGraph.add(ElementToBeAddedToGraph);\r\n                        //break; ezzel valszeg effektivebb\r\n                    }\r\n                }\r\n                else{\r\n                    System.out.println(\"Nem lennenek koherensek a szobak\");\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        //mivel minden indexen vegig tudtunk menni ezert tudunk truet returnolni, azert biztonsag kedveert meg egy kontrollt bennhagyok\r\n        if(coherentGraph.size() == newCoherentElements.size()) return true;\r\n            //hogyha nem egyenlok akkor false menjen ki, bar egyenloknek kene lenniuk\r\n        else return false;\r\n    }\r\n\r\n    //function hogy megtalaljam a legkisebb sorindexet a tombben, viszonyitasi parameter lesz.\r\n    // splitRooms func-on belül használva\r\n    private int getRoomWithLowestRowIdx(Room r1) {\r\n        UnitRoom min = unitRooms[mapRowSize-1][mapColumnSize-1];\r\n        for(UnitRoom unitRoom : r1.getUnitRooms())\r\n        {\r\n            if(unitRoom.getRowNum()<min.getRowNum())\r\n            {\r\n                min = unitRoom;\r\n            }\r\n        }\r\n        return min.getRowNum();\r\n    }\r\n    //function hogy megtalaljam azon UnitRoomokat, amik egy adott szamu soraban vannak a szobanaka alulrol nezve, amit a distance hataroz meg\r\n    // splitRooms func-on belül használva\r\n    private ArrayList<UnitRoom> getUnitRoomsWithXDistanceFromLowestRowIdxInOrderByColumn(Room r1, int lowestRowIdx, int distance) {\r\n        ArrayList<UnitRoom> ret = new ArrayList<>();\r\n        for(UnitRoom unitRoom: r1.getUnitRooms()){\r\n            if(unitRoom.getRowNum()==lowestRowIdx+distance){\r\n                ret.add(unitRoom);\r\n            }\r\n        }\r\n        ret.sort(Comparator.comparing(UnitRoom::getColNum));\r\n        return ret;\r\n    }\r\n\r\n    //ez a fv a mapgenerátorban is hasonlóan szerepel (colliderek és imagek nélkül)\r\n    private void mergeRooms(Room r1, Room r2, Isten isten) {\r\n        if(!r1.isAdjacent(r2) || r1.getID() == r2.getID()){\r\n            System.err.println(\"cant be merged\");\r\n            return;\r\n        }\r\n        System.out.println(r2.getID() + \"(r2) is merged to (r1)\" + r1.getID());\r\n        //remove r2 and keep r1;\r\n\r\n        //set colliders\r\n\r\n        edgeManager.deleteEdge(r1,r2);\r\n        edgeManager.updateEdgesAfterMerge(r1,r2);\r\n\r\n        for(UnitRoom unitRoom : r2.getUnitRooms()){\r\n            //r1.getUnitRooms().add(unitroom);\r\n            unitRoom.setOwnerRoom(r1);\r\n\r\n            //setting the new images of the deleted room\r\n            //this method cares about the renderable items too\r\n            unitRoom.addRightImage(isten);\r\n        }\r\n\r\n        r1.getUnitRooms().addAll(r2.getUnitRooms()); //insted of this: r1.getUnitRooms().add(unitroom);\r\n\r\n        r1.getAdjacentRooms().remove(r2);\r\n        r2.getAdjacentRooms().remove(r1);\r\n        for(Room adj : r2.getAdjacentRooms()){\r\n            if(!r1.getAdjacentRooms().contains(adj) && !adj.equals(r1)){\r\n                //System.out.println(\"adjroom added in r1: \" + adj.getID());\r\n                r1.getAdjacentRooms().add(adj);\r\n            }\r\n            adj.getAdjacentRooms().remove(r2);\r\n            if(!adj.getAdjacentRooms().contains(r1)) {\r\n                adj.getAdjacentRooms().add(r1);\r\n            }\r\n        }\r\n\r\n        r2.getAdjacentRooms().clear();\r\n        r2.getUnitRooms().clear();\r\n\r\n        //r1.setDiscovered(r2.isDiscovered());\r\n        //r1.setPlayerCount(r1.getPlayerCount() + r2.getPlayerCount());\r\n        //r1.setRoomType(r2.getRoomType());\r\n        r1.setMaxPlayerCount(r1.getMaxPlayerCount() + r2.getMaxPlayerCount());\r\n        rooms.remove(r2);\r\n\r\n\r\n    }\r\n\r\n    //merge the rooms until every room has minimumm size of the given number\r\n    private void printMap(){\r\n        for(int i = 0;i < mapRowSize;i++){ //test\r\n            for(int j = 0; j< mapColumnSize;j++){\r\n                if(unitRooms[i][j].getOwnerRoom().getID() < 10) {\r\n                    System.out.print(unitRooms[i][j].getOwnerRoom().getID() + \"     \");\r\n                }\r\n                else if(unitRooms[i][j].getOwnerRoom().getID() >= 10 && unitRooms[i][j].getOwnerRoom().getID() < 100) {\r\n                    System.out.print(unitRooms[i][j].getOwnerRoom().getID() + \"    \");\r\n                }\r\n                else if(unitRooms[i][j].getOwnerRoom().getID() >= 100) {\r\n                    System.out.print(unitRooms[i][j].getOwnerRoom().getID() + \"   \");\r\n                }\r\n            }\r\n            System.out.println();\r\n            System.out.println();\r\n        }\r\n    }\r\n    private int generateNewRoomID(){\r\n        int newID = 0;\r\n        while(true){\r\n            int roomCnt = 0;\r\n            for(Room room : rooms){\r\n                if(room.getID() == newID){\r\n                    newID++;\r\n                    break; //not found, try the next ID\r\n                }\r\n                roomCnt++;\r\n            }\r\n            if(roomCnt == rooms.size()){\r\n                return newID;\r\n            }\r\n\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n    public void setRooms(ArrayList<Room> rooms) {this.rooms = rooms;}\r\n\r\n    public void setUnitRooms(UnitRoom[][] unitRooms) {\r\n        this.unitRooms = unitRooms;\r\n    }\r\n\r\n    public ArrayList<Room> getRooms() {\r\n        return rooms;\r\n    }\r\n\r\n    public UnitRoom[][] getUnitRooms() {\r\n        return unitRooms;\r\n    }\r\n\r\n    public int getMapRowSize() {\r\n        return mapRowSize;\r\n    }\r\n\r\n    public int getMapColumnSize() {\r\n        return mapColumnSize;\r\n    }\r\n    public EdgeManager getEdgeManager(){ return edgeManager;}\r\n    public boolean isGenerated() {\r\n        return isGenerated;\r\n    }\r\n}\r\n
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
-diff --git a/src/main/java/org/game/Map/Map.java b/src/main/java/org/game/Map/Map.java
---- a/src/main/java/org/game/Map/Map.java	
-+++ b/src/main/java/org/game/Map/Map.java	
-@@ -19,7 +19,6 @@
-     private final int minRoomSize;
-     private boolean isGenerated = false;
-     //private boolean
--
-     @Override
-     public void onStart(Isten isten) {
- 
-@@ -29,18 +28,18 @@
-     }
- 
-     public void init(Isten isten) {
--        this.edgeManager = new EdgeManager(isten);
-         this.mapgenerator = new Mapgenerator(this, isten);
-         mapgenerator.generate(minRoomSize);
-         isGenerated = true;
-     }
- 
--    public Map(int rowNumber, int columnNumber, int minRoomSize){
-+    public Map(Isten isten, int rowNumber, int columnNumber, int minRoomSize){
-         this.mapRowSize = rowNumber;
-         this.mapColumnSize = columnNumber;
-         this.minRoomSize = minRoomSize;
-         //unitrooms is set in the generator --> onstart
-         this.rooms = new ArrayList<>();
-+        this.edgeManager = new EdgeManager(isten);
-         initUnitRooms();
- 
-     }
-Index: src/main/java/org/game/UI/Minimap.java
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
-<+>package main.java.org.game.UI;\r\n\r\nimport main.java.org.game.Graphics.Image;\r\nimport main.java.org.game.Graphics.ImageUI;\r\nimport main.java.org.game.Graphics.Renderable;\r\nimport main.java.org.game.Isten;\r\nimport main.java.org.game.Map.*;\r\nimport main.java.org.game.updatable.Updatable;\r\nimport main.java.org.linalg.Vec2;\r\n\r\nimport java.awt.*;\r\nimport java.awt.image.*;\r\nimport java.lang.reflect.Array;\r\nimport java.util.ArrayList;\r\nimport java.util.Arrays;\r\nimport java.util.Random;\r\n\r\npublic class Minimap extends Updatable {\r\n\r\n    private int displayedScale;\r\n\r\n    private final int width;\r\n    private final int height;\r\n\r\n    private final int pixelsPerUnit;\r\n    private final int wallWidthInPixels;\r\n\r\n    private ImageUI displayedImage=null;\r\n    private BufferedImage displayedImageData;\r\n    private int[] rawData;\r\n\r\n    private final Object syncObject=new Object();\r\n    private boolean canRerender=true;\r\n\r\n    public Minimap(int displayedScale, int res, int pixelsPerUnit, int wallWidthInPixels)\r\n    {\r\n        this.displayedScale=displayedScale;\r\n\r\n        this.width=res;\r\n        this.height=res;\r\n        this.pixelsPerUnit=pixelsPerUnit;\r\n        this.wallWidthInPixels=wallWidthInPixels;\r\n\r\n        rawData=new int[4*res*res];\r\n        displayedImageData=new BufferedImage(this.width, this.height, BufferedImage.TYPE_INT_ARGB);\r\n    }\r\n\r\n    @Override\r\n    public void onStart(Isten isten) {\r\n        displayedImage=new ImageUI();\r\n        displayedImage.setPosition(new Vec2(20,20));\r\n        displayedImage.setScale(new Vec2(displayedScale,displayedScale));\r\n        displayedImage.setSortingLayer(-69420);\r\n        displayedImage.setAlignment(Renderable.RIGHT, Renderable.BOTTOM);\r\n        displayedImage.setOrigin(Renderable.RIGHT, Renderable.BOTTOM);\r\n        displayedImage.setImage(displayedImageData);\r\n\r\n        isten.getRenderer().addRenderable(displayedImage);\r\n    }\r\n\r\n    @Override\r\n    public void onUpdate(Isten isten, double deltaTime) {\r\n        synchronized (syncObject)\r\n        {\r\n            if(canRerender==true)\r\n            {\r\n                canRerender=false;\r\n                Thread thread = new Thread(()->{this.draw(isten);});\r\n                thread.start();\r\n            }\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void onDestroy() {\r\n\r\n    }\r\n\r\n    private void draw(Isten isten)\r\n    {\r\n        Arrays.fill(rawData,0);//reset the content of the image\r\n\r\n        final Vec2 playerPos=isten.getPlayer().getPlayerCollider().getPosition().clone();\r\n\r\n        final Vec2 lowerBound=Vec2.subtract(playerPos, new Vec2(width*0.5f/pixelsPerUnit, height*0.5f/pixelsPerUnit));\r\n        final Vec2 upperBound=Vec2.sum(playerPos, new Vec2(width*0.5f/pixelsPerUnit, height*0.5f/pixelsPerUnit));\r\n        final Vec2 covered=Vec2.subtract(upperBound,lowerBound);\r\n        final Vec2 onePerCovered=new Vec2(1/covered.x, 1/covered.y);\r\n\r\n        /*ArrayList<Room> rooms = isten.getMap().getRooms();\r\n        if(rooms==null)\r\n            rooms=new ArrayList<>();\r\n\r\n        for(int i=0;i<rooms.size();i++)\r\n        {\r\n            //draw unit rooms\r\n            ArrayList<UnitRoom> unitRooms=rooms.get(i).getUnitRooms();\r\n            for(int j=0;j<unitRooms.size();j++)\r\n            {\r\n                Vec2 startPos=unitRooms.get(j).getPosition().clone();\r\n                startPos.x-=0.5f+lowerBound.x;\r\n                startPos.y-=0.5f+lowerBound.y;\r\n\r\n                if(startPos.x+1<0||startPos.y+1<0||startPos.x>covered.x||startPos.y>covered.y)\r\n                    continue;\r\n\r\n                startPos.y=covered.y-startPos.y-1;\r\n\r\n                int drawX, drawY;\r\n                drawX=Math.round(width*startPos.x* onePerCovered.x);\r\n                drawY=Math.round(height* startPos.y* onePerCovered.y);\r\n\r\n                for(int k=drawY>-1?drawY:0;k<height&&k<drawY+pixelsPerUnit;k++)\r\n                {\r\n                    for(int l=drawX>-1?drawX:0;l<width&&l<drawX+pixelsPerUnit;l++)\r\n                    {\r\n                        int index=4*(width*k+l);\r\n                        rawData[index++]=0;\r\n                        rawData[index++]=0;\r\n                        rawData[index++]=0;\r\n                        rawData[index]=255;\r\n                    }\r\n                }\r\n            }\r\n        }*/\r\n\r\n        //edging intensifies (drawing edges)\r\n        ArrayList<EdgeBetweenRooms> edges =isten.getMap().getEdgeManager().getRoomEdges();\r\n        for(int i=0;i<edges.size();i++)\r\n        {\r\n            ArrayList<EdgePiece> edgePieces=edges.get(i).getWalls();\r\n\r\n            for(int j=0;j<edgePieces.size();j++)\r\n            {\r\n                Vec2 startPos=edgePieces.get(j).getCollider().getPosition().clone();\r\n                Vec2 scale=edgePieces.get(j).getCollider().getScale();\r\n                startPos.x-=0.5f*scale.x+lowerBound.x;\r\n                startPos.y-=0.5f*scale.y+lowerBound.y;\r\n\r\n                if(startPos.x+1<0||startPos.y+1<0||startPos.x>covered.x||startPos.y>covered.y)\r\n                    continue;\r\n\r\n                startPos.y=covered.y-startPos.y-scale.y;\r\n\r\n                int drawX, drawY;\r\n                drawX=Math.round(width*startPos.x* onePerCovered.x);\r\n                drawY=Math.round(height* startPos.y* onePerCovered.y)+1;\r\n\r\n                int drawEndX=Math.round(scale.x*pixelsPerUnit);\r\n                int drawEndY=Math.round(scale.y*pixelsPerUnit);\r\n\r\n                if(drawEndX>drawEndY)\r\n                {\r\n                    drawX--;\r\n                    drawEndX+=drawX+wallWidthInPixels/2;\r\n                    drawEndY=drawY+wallWidthInPixels;\r\n                }\r\n                else\r\n                {\r\n                    drawY--;\r\n                    drawEndY+=drawY;\r\n                    drawEndX=drawX+wallWidthInPixels;\r\n                }\r\n\r\n                if(drawX<0)\r\n                    drawX=0;\r\n                if(drawY<0)\r\n                    drawY=0;\r\n                if(drawEndX>width)\r\n                    drawEndX=width;\r\n                if(drawEndY>height)\r\n                    drawEndY=height;\r\n\r\n                int r=255, g=255,b=255;\r\n                if(edgePieces.get(j) instanceof Door)\r\n                {\r\n                    //r=255;\r\n                    g=205;\r\n                    b=0;\r\n                }\r\n\r\n                for(int k=drawY;k<drawEndY;k++)\r\n                {\r\n                    for(int l=drawX;l<drawEndX;l++)\r\n                    {\r\n                        int index=4*(width*k+l);\r\n                        rawData[index++]=r;\r\n                        rawData[index++]=g;\r\n                        rawData[index++]=b;\r\n                        rawData[index]=255;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        //draw the great edges\r\n        do{\r\n            float mapSizeX, mapSizeY;\r\n            mapSizeX=isten.getMap().getMapColumnSize();\r\n            mapSizeY=isten.getMap().getMapRowSize();\r\n\r\n            float wallWidth=0.1f;\r\n\r\n            try{\r\n                Vec2 temp=isten.getMap().getEdgeManager().getRoomEdges().get(0).getWalls().get(0).getCollider().getScale();\r\n                wallWidth=temp.x>temp.y?temp.y:temp.x;\r\n            }\r\n            catch (Exception ex){}\r\n\r\n            Vec2[] positions=new Vec2[]{\r\n                    new Vec2(-0.5f, 0.5f*mapSizeY-0.5f),\r\n                    new Vec2(0.5f*mapSizeX-0.5f, mapSizeY-0.5f),\r\n                    new Vec2(mapSizeX-0.5f, 0.5f*mapSizeY-0.5f),\r\n                    new Vec2(0.5f*mapSizeX-0.5f,-0.5f)\r\n            };\r\n            Vec2[] scales=new Vec2[]{\r\n                    new Vec2(wallWidth, mapSizeY),\r\n                    new Vec2(mapSizeX, wallWidth),\r\n                    new Vec2(wallWidth, mapSizeY),\r\n                    new Vec2(mapSizeX, wallWidth)\r\n            };\r\n\r\n            for(int j=0;j<4;j++)\r\n            {\r\n                Vec2 startPos=positions[j].clone();\r\n                Vec2 scale=scales[j];\r\n                startPos.x-=0.5f*scale.x+lowerBound.x;\r\n                startPos.y-=0.5f*scale.y+lowerBound.y;\r\n                startPos.y=covered.y-startPos.y-scale.y;\r\n\r\n                int drawX, drawY;\r\n                drawX=Math.round(width*startPos.x* onePerCovered.x);\r\n                drawY=Math.round(height* startPos.y* onePerCovered.y)+1;\r\n\r\n                int drawEndX=Math.round(scale.x*pixelsPerUnit);\r\n                int drawEndY=Math.round(scale.y*pixelsPerUnit);\r\n\r\n                if(drawEndX>drawEndY)\r\n                {\r\n                    drawX--;\r\n                    drawEndX+=drawX+wallWidthInPixels/2;\r\n                    drawEndY=drawY+wallWidthInPixels;\r\n                }\r\n                else\r\n                {\r\n                    drawY--;\r\n                    drawEndY+=drawY;\r\n                    drawEndX=drawX+wallWidthInPixels;\r\n                }\r\n\r\n                if(drawX<0)\r\n                    drawX=0;\r\n                if(drawY<0)\r\n                    drawY=0;\r\n                if(drawEndX>width)\r\n                    drawEndX=width;\r\n                if(drawEndY>height)\r\n                    drawEndY=height;\r\n\r\n                for(int k=drawY;k<drawEndY;k++)\r\n                {\r\n                    for(int l=drawX;l<drawEndX;l++)\r\n                    {\r\n                        int index=4*(width*k+l);\r\n                        rawData[index++]=255;\r\n                        rawData[index++]=255;\r\n                        rawData[index++]=255;\r\n                        rawData[index]=255;\r\n                    }\r\n                }\r\n            }\r\n        } while(69==420);\r\n\r\n        //draw player\r\n        do{\r\n            for(int i=height/2-wallWidthInPixels;i<height/2+wallWidthInPixels+1;i++)\r\n            {\r\n                for (int j=width/2-wallWidthInPixels;j<width/2+wallWidthInPixels+1;j++)\r\n                {\r\n                    int currentIndex=4*(i*width+j);\r\n                    rawData[currentIndex++]=0;\r\n                    rawData[currentIndex++]=0;\r\n                    rawData[currentIndex++]=255;\r\n                    rawData[currentIndex]=255;\r\n                }\r\n            }\r\n        }while(69==420);\r\n\r\n        //apply transparency mask\r\n        int currentIndex=3;//offset to alpha value\r\n        float outerRadius=(float)Math.sqrt((width*0.5f)*(height*0.5f));\r\n        float innerRadius=outerRadius*0.9f;\r\n        float onePerInterpolationDistance=1/(outerRadius-innerRadius);\r\n        for(int row=0;row<height;row++)\r\n        {\r\n            for(int col=0;col<width;col++, currentIndex+=4)\r\n            {\r\n                float length=(float)Math.sqrt(Math.pow(row-height*0.5f,2)+Math.pow(col-width*0.5f,2));\r\n\r\n                if(rawData[currentIndex]==0)\r\n                    rawData[currentIndex]=128;\r\n\r\n                if(length<innerRadius)\r\n                {\r\n                    continue;\r\n                }\r\n                if(length>outerRadius)\r\n                {\r\n                    rawData[currentIndex]=0;\r\n                    continue;\r\n                }\r\n\r\n                rawData[currentIndex]=(int)((rawData[currentIndex]/255.0f)*(255-255*(length-innerRadius)*onePerInterpolationDistance));\r\n            }\r\n        }\r\n\r\n        displayedImageData.getRaster().setPixels(0,0, this.width, this.height, rawData);\r\n\r\n        synchronized (syncObject)\r\n        {\r\n            canRerender=true;\r\n        }\r\n    }\r\n}\r\n
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
-diff --git a/src/main/java/org/game/UI/Minimap.java b/src/main/java/org/game/UI/Minimap.java
---- a/src/main/java/org/game/UI/Minimap.java	
-+++ b/src/main/java/org/game/UI/Minimap.java	
-@@ -125,6 +125,9 @@
-         }*/
- 
-         //edging intensifies (drawing edges)
-+
-+        if(isten.getMap().getEdgeManager() != null) return;
-+
-         ArrayList<EdgeBetweenRooms> edges =isten.getMap().getEdgeManager().getRoomEdges();
-         for(int i=0;i<edges.size();i++)
-         {
-Index: src/main/java/org/items/ChestManager.java
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
-<+>package main.java.org.items;\r\n\r\nimport lombok.Getter;\r\nimport main.java.org.game.Isten;\r\nimport main.java.org.game.Map.Map;\r\nimport main.java.org.game.Map.UnitRoom;\r\nimport main.java.org.game.Map.Wall;\r\nimport main.java.org.game.physics.Collider;\r\nimport main.java.org.game.physics.ColliderGroup;\r\nimport main.java.org.game.updatable.Updatable;\r\nimport main.java.org.items.usable_items.*;\r\nimport main.java.org.linalg.Vec2;\r\nimport main.java.org.networking.Packet11ChestOpened;\r\n\r\nimport java.awt.event.KeyEvent;\r\nimport java.util.*;\r\n\r\nimport static java.lang.Math.sqrt;\r\n\r\n/**\r\n * This class generates chests around the map randomly.\r\n * Rules: There aren't any chests in front of doors.\r\n * Every chest is next to a wall and headed against the wall.\r\n */\r\npublic class ChestManager extends Updatable {\r\n    private Vector<Chest>chests=new Vector<>();\r\n    private  int chestCount;\r\n    private  Map map;\r\n    private Vector<UnitRoom> placeableUnitRooms = new Vector<>();//UnitRoom-ok, amelyikbe helyezhető láda (mivel ajtó mellé nem rakható láda)\r\n    private Vector<Boolean> isThereChest=new Vector<>();//igaz=van az azonos sorszámú unitroomban láda\r\n    /**\r\n     * @param n How many chests should be generated randomly across the map?\r\n     */\r\n    public ChestManager(int n){\r\n        chestCount=n;\r\n        map=null;\r\n    }\r\n    @Override\r\n    public void onStart(Isten isten) {\r\n\r\n    }\r\n\r\n    public void init(Isten isten) {\r\n        map=isten.getMap();\r\n        for (int i = 0; i < map.getUnitRooms().length; i++) {\r\n            for (int j = 0; j < map.getUnitRooms()[i].length; j++) {\r\n                UnitRoom unitRoomTmp=map.getUnitRooms()[i][j];\r\n                //megcsinaltam a unitroomot: van egy hasdoor valtozoja, es mindegyik uniroomrol le lehet kerdezni hogy melyik oldala fall\r\n                //fontos az ajtot is falnak veszi!!\r\n                //ezek a valtoztatasok a mapdrawing branchen elerhetoek(nem tudtam jol összrakni, nem vagyok jo git kezeko :) )\r\n                if(!unitRoomTmp.hasDoor()//ha egyik fal sem ajtó\r\n                        &&(unitRoomTmp.isTopWall()|| unitRoomTmp.isRightWall()|| unitRoomTmp.isBottomWall()|| unitRoomTmp.isLeftWall()))//ha egyik oldalán legalább fal van\r\n                {\r\n                    placeableUnitRooms.add(unitRoomTmp);\r\n                    isThereChest.add(false);\r\n                }\r\n            }\r\n        }\r\n        if(chestCount> placeableUnitRooms.size()) {\r\n            System.err.println(\"So many chests cant be generated!\");\r\n            chestCount=placeableUnitRooms.size();\r\n        }\r\n        Random rand=new Random();\r\n        int randomUnitRoom=rand.nextInt(placeableUnitRooms.size());\r\n        for (int h = 0; h < chestCount; h++) {\r\n            while(isThereChest.get(randomUnitRoom)){\r\n                randomUnitRoom=rand.nextInt(placeableUnitRooms.size());\r\n            }\r\n            WallLocation wall= wallInUnitRoomPicker(placeableUnitRooms.get(randomUnitRoom));\r\n            Vec2 chestPos=null;\r\n            switch (wall) {//0=left, 1=top, 2=right, 3=bottom\r\n                case LEFT: chestPos=new Vec2(placeableUnitRooms.get(randomUnitRoom).getPosition().x - 0.3f, placeableUnitRooms.get(randomUnitRoom).getPosition().y);break;\r\n                case TOP :chestPos=new Vec2(placeableUnitRooms.get(randomUnitRoom).getPosition().x, placeableUnitRooms.get(randomUnitRoom).getPosition().y + 0.3f);break;\r\n                case RIGHT: chestPos=new Vec2(placeableUnitRooms.get(randomUnitRoom).getPosition().x + 0.3f, placeableUnitRooms.get(randomUnitRoom).getPosition().y);break;\r\n                case BOTTOM: chestPos=new Vec2(placeableUnitRooms.get(randomUnitRoom).getPosition().x, placeableUnitRooms.get(randomUnitRoom).getPosition().y - 0.3f);break;\r\n            };\r\n            //CHEST TÍPUSOK, a networking miatt sokkal egyszerűbb így az itemeket átadni --> Chest.java/fillChest\r\n            chests.add(new Chest(chestPos,isten,wall.ordinal(),rand.nextInt(5)));\r\n            isThereChest.set(randomUnitRoom,true);\r\n        }\r\n        ColliderGroup chestColliders=new ColliderGroup();\r\n        for (int i = 0; i < chests.size(); i++) {\r\n            Collider c=new Collider(chests.get(i).getPosition(),new Vec2(0.15f,0.15f));\r\n            chestColliders.addCollider(c);\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void onUpdate(Isten isten, double deltaTime) {\r\n        if(isten.getInputHandler().isKeyDown(KeyEvent.VK_E)){\r\n            Vec2 playerPostion = isten.getPlayer().getPlayerCollider().getPosition();\r\n            int index = 0;\r\n            for(var chest : chests){\r\n                Vec2 playerChestVector = Vec2.subtract(playerPostion,chest.getPosition());\r\n                double playerChestDistance = sqrt(Vec2.dot(playerChestVector,playerChestVector));\r\n                if(playerChestDistance <= 0.5 && !chest.isOpened()){\r\n                    chest.open();\r\n                    isten.getSocketClient().sendData((\"11\"+index).getBytes());\r\n                    break;\r\n                }\r\n                index++;\r\n            }\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void onDestroy() {\r\n\r\n    }\r\n    private WallLocation wallInUnitRoomPicker(UnitRoom unitRoom ){\r\n\r\n        WallLocation wall;//0=left, 1=top, 2=right, 3=bottom\r\n        ArrayList<WallLocation> walls = new ArrayList<>();\r\n        if(unitRoom.isLeftWall())walls.add(WallLocation.LEFT);\r\n        if(unitRoom.isTopWall())walls.add(WallLocation.TOP);\r\n        if(unitRoom.isRightWall())walls.add(WallLocation.RIGHT);\r\n        if(unitRoom.isBottomWall()) walls.add(WallLocation.BOTTOM);\r\n\r\n        Random random = new Random();\r\n        return walls.get(random.nextInt(walls.size()));\r\n\r\n\r\n    }\r\n\r\n    public enum WallLocation {\r\n        LEFT,\r\n        TOP,\r\n        RIGHT,\r\n        BOTTOM\r\n    }\r\n\r\n    @Override\r\n    public Vector<Chest> getChests() { return chests; }\r\n}\r\n
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
-diff --git a/src/main/java/org/items/ChestManager.java b/src/main/java/org/items/ChestManager.java
---- a/src/main/java/org/items/ChestManager.java	
-+++ b/src/main/java/org/items/ChestManager.java	
-@@ -74,7 +74,7 @@
-                 case RIGHT: chestPos=new Vec2(placeableUnitRooms.get(randomUnitRoom).getPosition().x + 0.3f, placeableUnitRooms.get(randomUnitRoom).getPosition().y);break;
-                 case BOTTOM: chestPos=new Vec2(placeableUnitRooms.get(randomUnitRoom).getPosition().x, placeableUnitRooms.get(randomUnitRoom).getPosition().y - 0.3f);break;
-             };
--            //CHEST TÍPUSOK, a networking miatt sokkal egyszerűbb így az itemeket átadni --> Chest.java/fillChest
-+            //CHEST TIPUSOK, a networking miatt sokkal egyszerubb így az itemeket atadni --> Chest.java/fillChest
-             chests.add(new Chest(chestPos,isten,wall.ordinal(),rand.nextInt(5)));
-             isThereChest.set(randomUnitRoom,true);
-         }
-Index: src/main/java/org/game/Isten.java
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
-<+>package main.java.org.game;\r\n\r\nimport main.java.org.entities.villain.Villain;\r\nimport main.java.org.game.Camera.Camera;\r\nimport main.java.org.game.Graphics.*;\r\n\r\nimport main.java.org.entities.player.Player;\r\n\r\nimport main.java.org.game.Input.Input;\r\nimport main.java.org.game.Map.Map;\r\nimport main.java.org.game.PlayerPrefs.PlayerPrefs;\r\nimport main.java.org.game.UI.*;\r\nimport main.java.org.game.physics.PhysicsEngine;\r\nimport main.java.org.game.updatable.Updatable;\r\nimport main.java.org.linalg.Vec2;\r\n\r\nimport main.java.org.items.ChestManager;\r\nimport main.java.org.items.ItemManager;\r\n\r\nimport main.java.org.networking.*;\r\n\r\nimport javax.swing.*;\r\n\r\nimport java.util.ArrayList;\r\n\r\n/**\r\n * The main class representing the game part of the program.\r\n */\r\npublic class Isten {\r\n    private HandlerManager handlerManager;\r\n    private final PhysicsEngine physicsEngine;\r\n    protected final GameRenderer renderer;\r\n    protected final ArrayList<Updatable> updatables;\r\n    private final ArrayList<Updatable> pendingAddedUpdatables;\r\n    private final ArrayList<Updatable> pendingRemovedUpdatables;\r\n\r\n    private Map map;\r\n    private Inventory inventory;\r\n    private final Input inputHandler;\r\n    private final ItemManager itemManager;\r\n\r\n    private final Camera camera;\r\n\r\n    private GameClient socketClient;\r\n    private GameServer socketServer;\r\n\r\n    private PlayerMP player;\r\n    private ChestManager chestManager;\r\n    /**\r\n     * Constructor for Isten.\r\n     * Initializes the physics engine, game renderer, and list of updatables.\r\n     */\r\n    public Isten() {\r\n        inventory=new Inventory(5);\r\n        map=new Map(20, 20, 10);\r\n        chestManager = new ChestManager(75);\r\n        itemManager=new ItemManager();\r\n        inputHandler = new Input();\r\n        camera = new Camera();\r\n        physicsEngine = new PhysicsEngine();\r\n        renderer = new GameRenderer(camera, inputHandler);\r\n        updatables = new ArrayList<>();\r\n        pendingAddedUpdatables = new ArrayList<>();\r\n        pendingRemovedUpdatables = new ArrayList<>();\r\n\r\n\r\n        handlerManager = new HandlerManager(this);\r\n    }\r\n\r\n    /**\r\n     * Method to update the game state.\r\n     *\r\n     * @param deltaTime The time elapsed since the last update\r\n     */\r\n    public void update(double deltaTime) {\r\n\r\n\r\n        inputHandler.update();\r\n\r\n        if(socketServer == null || socketServer.isInitialized()) physicsEngine.step(deltaTime);\r\n\r\n\r\n        //remove pending updatables from updatables\r\n        for (Updatable u : pendingRemovedUpdatables)\r\n            if (!u.isDestroyed()) {\r\n                u.setDestroyedTrue();\r\n                u.onDestroy();\r\n            }\r\n        updatables.removeAll(pendingRemovedUpdatables);\r\n        pendingRemovedUpdatables.clear();\r\n\r\n        //add pending updatables to updatables\r\n        updatables.addAll(pendingAddedUpdatables);\r\n        pendingAddedUpdatables.clear();\r\n\r\n        //check if updatable has been initialized\r\n        for (Updatable u : updatables)\r\n            if (!u.isInitialized()) {\r\n                u.setInitializedTrue();\r\n                u.onStart(this);\r\n            }\r\n\r\n\r\n        //call onUpdates\r\n        for (Updatable u : updatables)\r\n            u.onUpdate(this, deltaTime);\r\n\r\n\r\n        //ServerUpdate\r\n        if(socketServer != null) {\r\n            socketServer.updateServer(this, deltaTime);\r\n        }\r\n\r\n\r\n\r\n        //Manage handlers of client\r\n        handlerManager.executeTasks();\r\n\r\n\r\n        //calculate render positions, check for UI inputs and then render\r\n        renderer.calculateRenderedPositions();\r\n        renderer.processUIInputs(inputHandler);\r\n        renderer.repaint();\r\n    }\r\n\r\n    /**\r\n     * Method to initialize the game.\r\n     */\r\n\r\n    public void initMP() {\r\n        //Set localPlayer to true, so that only this player can be moved and followed by the camera on this client\r\n        player = new PlayerMP(JOptionPane.showInputDialog(this.getRenderer(),\"Username\"),null,-1);\r\n\r\n\r\n        player.localPlayer = true;\r\n\r\n        addUpdatables();\r\n        addRenderables();\r\n\r\n        int skinID = PlayerPrefs.getInt(\"skin\");\r\n        player.setSkinID(skinID);\r\n        Packet00Login loginPacket = new Packet00Login(player.getUsername(), 0, 0, skinID);\r\n\r\n        if(socketServer != null) {\r\n            socketServer.addConnection(player,loginPacket);\r\n        }\r\n\r\n        if(JOptionPane.showConfirmDialog(this.getRenderer(), \"Server?\") == 0) {\r\n            socketServer = new GameServer(this);\r\n            socketServer.start();\r\n\r\n        }\r\n        socketClient = new GameClient(this, \"localhost\");\r\n        socketClient.start();\r\n\r\n        loginPacket.writeData(socketClient);\r\n\r\n        update(0);\r\n    }\r\n    public void init() {\r\n        //Create own player\r\n        player = new PlayerMP(JOptionPane.showInputDialog(this.getRenderer(),\"Username\"),null,-1);\r\n\r\n        player.localPlayer = true;\r\n\r\n        addUpdatables();\r\n        addRenderables();\r\n\r\n        int skinID = PlayerPrefs.getInt(\"skin\");\r\n        player.setSkinID(skinID);\r\n        Packet00Login loginPacket = new Packet00Login(player.getUsername(), 0, 0, skinID);\r\n\r\n        if(socketServer != null) {\r\n            socketServer.addConnection(player,loginPacket);\r\n        }\r\n\r\n        socketServer = new GameServer(this);\r\n        socketServer.start();\r\n\r\n        socketClient = new GameClient(this, \"localhost\");\r\n        socketClient.start();\r\n\r\n        loginPacket.writeData(socketClient);\r\n    }\r\n\r\n    /**\r\n     * Method to add renderable objects to the game renderer.\r\n     */\r\n    protected void addRenderables() {\r\n    }\r\n\r\n    /**\r\n     * Method to add updatable objects to the game.\r\n     */\r\n    protected void addUpdatables() {\r\n\r\n        updatables.add(player);\r\n        updatables.add(itemManager);\r\n        updatables.add(inventory);\r\n        updatables.add(map);\r\n\r\n        updatables.add(chestManager);//majd a játékba nem kell 500 láda, csak szemléltetésképp kell ilyen sok\r\n\r\n\r\n        updatables.add(new TimeCounter());\r\n        updatables.add(new Help());\r\n        updatables.add(new GameMenu());\r\n\r\n        updatables.add(new Minimap(200,200,20,2));\r\n    }\r\n\r\n    /**\r\n     * Method to get the game renderer.\r\n     *\r\n     * @return The game renderer\r\n     */\r\n    public GameRenderer getRenderer() {\r\n        return renderer;\r\n    }\r\n\r\n    /**\r\n     * returns the physics engine of the isten\r\n     */\r\n    public PhysicsEngine getPhysicsEngine() {\r\n        return physicsEngine;\r\n    }\r\n\r\n    /**\r\n     * returns the inputhandler of the isten\r\n     */\r\n    public Input getInputHandler() {\r\n        return inputHandler;\r\n    }\r\n\r\n    /**\r\n     * returns the camera of the isten\r\n     */\r\n    public Camera getCamera() {\r\n        return this.camera;\r\n    }\r\n\r\n    public Player getPlayer(){return player;}\r\n    public Inventory getInventory(){return inventory;}\r\n    public ItemManager getItemManager(){return itemManager;}\r\n    public Map getMap(){return map;}\r\n\r\n    public void addUpdatable(Updatable u) {\r\n        pendingAddedUpdatables.add(u);\r\n    }\r\n\r\n    public void removeUpdatable(Updatable u) {\r\n        pendingRemovedUpdatables.add(u);\r\n    }\r\n\r\n    public int getPlayerMPIndex(String username) {\r\n        int index = 0;\r\n        for(int i = 0; i < updatables.size(); i++) {\r\n            Updatable u = updatables.get(i);\r\n            if(u instanceof PlayerMP) {\r\n                if(((PlayerMP)u).getUsername().equalsIgnoreCase(username)) {\r\n                    break;\r\n                }\r\n\r\n            }\r\n            index++;\r\n        }\r\n        return index;\r\n    }\r\n\r\n    public int getVillainIndex(String villainName) {\r\n        int index = 0;\r\n        for(int i = 0; i < updatables.size(); i++) {\r\n            Updatable u = updatables.get(i);\r\n            if(u instanceof Villain) {\r\n                if(((Villain)u).getVillainName().equalsIgnoreCase(villainName)) {\r\n                    break;\r\n                }\r\n\r\n            }\r\n            index++;\r\n        }\r\n        return index;\r\n    }\r\n    public Updatable getUpdatable(int index) {\r\n        if(index >= updatables.size()) return null;\r\n        return updatables.get(index);\r\n    }\r\n\r\n    /**\r\n     * returns an ArrayList of updatables of the given type <br>\r\n     * <br>\r\n     * how to use it:\r\n     * ArrayList< Player> alma=new ArrayList<>();\r\n     * alma = isten.getUpdatablesByType(Player.class);\r\n     * @param type the Class of the elements\r\n     * @return an array list of elements\r\n     * @param <E> the type of the queried elements\r\n     */\r\n    public final <E extends Updatable> ArrayList<E> getUpdatablesByType(Class<E> type)\r\n    {\r\n        ArrayList<E> tempList=new ArrayList<>();\r\n        for(int i=0;i<updatables.size();i++)\r\n        {\r\n            if(type.isInstance(updatables.get(i)))\r\n                tempList.add((E)updatables.get(i));\r\n        }\r\n\r\n        return tempList;\r\n    }\r\n\r\n    public GameClient getSocketClient() {\r\n        return socketClient;\r\n    }\r\n\r\n    public ArrayList<Updatable> getUpdatables() {\r\n        return updatables;\r\n    }\r\n\r\n    public GameServer getSocketServer() {\r\n        return socketServer;\r\n    }\r\n\r\n    public HandlerManager getHandlerManager() {\r\n        return handlerManager;\r\n    }\r\n\r\n    public ChestManager getChestManager() { return chestManager; }\r\n}\r\n
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
-diff --git a/src/main/java/org/game/Isten.java b/src/main/java/org/game/Isten.java
---- a/src/main/java/org/game/Isten.java	
-+++ b/src/main/java/org/game/Isten.java	
-@@ -1,4 +1,4 @@
--package main.java.org.game;
-+    package main.java.org.game;
- 
- import main.java.org.entities.villain.Villain;
- import main.java.org.game.Camera.Camera;
-@@ -52,7 +52,7 @@
-      */
-     public Isten() {
-         inventory=new Inventory(5);
--        map=new Map(20, 20, 10);
-+        map=new Map(this, 20, 20, 10);
-         chestManager = new ChestManager(75);
-         itemManager=new ItemManager();
-         inputHandler = new Input();
Index: .idea/shelf/Uncommitted_changes_before_Update_at_01_05_2024_13_38__Changes_1.xml
===================================================================
diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_01_05_2024_13_38__Changes_1.xml b/.idea/shelf/Uncommitted_changes_before_Update_at_01_05_2024_13_38__Changes_1.xml
deleted file mode 100644
--- a/.idea/shelf/Uncommitted_changes_before_Update_at_01_05_2024_13_38__Changes_1.xml	(revision 2de02ed084cf3446ea9c0020a85b83e8f9ecb48d)
+++ /dev/null	(revision 2de02ed084cf3446ea9c0020a85b83e8f9ecb48d)
@@ -1,9 +0,0 @@
-<changelist name="Uncommitted_changes_before_Update_at_01_05_2024_13_38_[Changes]1" date="1714563621747" recycled="true" deleted="true">
-  <option name="PATH" value="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_01_05_2024_13_38_[Changes]1/shelved.patch" />
-  <option name="DESCRIPTION" value="Uncommitted changes before Update at 01/05/2024 13:38 [Changes]" />
-  <binary>
-    <option name="BEFORE_PATH" value="data/sus.amogus" />
-    <option name="AFTER_PATH" value="data/sus.amogus" />
-    <option name="SHELVED_PATH" value="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_01_05_2024_13_38_[Changes]1/sus.amogus" />
-  </binary>
-</changelist>
\ No newline at end of file
Index: .idea/sonarlint/issuestore/index.pb
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\n9\n\tREADME.md\u0012,8\\e\\8ec9a00bfd09b3190ac6b22251dbb1aa95a0579d\nX\n(src/main/java/org/items/ItemManager.java\u0012,5\\8\\58f412e7843066f3f085fcbcffbcd715deb97352\nY\n)src/main/java/org/items/ChestManager.java\u0012,c\\a\\ca0db237d642623320d941e9c23c4dea256bde23\nR\n\"src/main/java/org/items/Chest.java\u0012,7\\6\\768fc9e076fa68cb423d0b0f6604f4e0296bed89\n\\\n,src/main/java/org/game/Map/Mapgenerator.java\u0012,4\\f\\4fdc75f760398ad335804099c4c2aad3b4db38bd\nX\n(src/main/java/org/game/Map/UnitRoom.java\u0012,9\\3\\933c10faafd44b7f4f2d1678304c648f862e5581\nX\n(src/main/java/org/game/Map/RoomType.java\u0012,0\\9\\098e2fb073f84303e4936b5215044c9bf5a18688\nT\n$src/main/java/org/game/Map/Room.java\u0012,c\\6\\c6f7b65f617fe34dc6a651a2bf566be4a0d2a975\nU\n%src/main/java/org/game/Map/Graph.java\u0012,2\\8\\28d1f759a36d54a51a083e3d0d8d00b338f093d2\n]\n-src/main/java/org/entities/player/Player.java\u0012,e\\4\\e4271d76d0528cc918e2133542540146c36b8cc9\n`\n0src/main/java/org/game/Map/EdgeBetweenRooms.java\u0012,9\\c\\9c5b76ca10ecfaf22d96236316b037e6470b3693\nY\n)src/main/java/org/game/Map/EdgePiece.java\u0012,3\\2\\32b4cbc356009b9e8f6511eeac1b9dfc5d01c561\n\\\n,src/main/java/org/networking/MapHandler.java\u0012,f\\3\\f33af664d2d865bb0ccc96ecd9a7130b9bdfb148\nS\n#src/main/java/org/game/Map/Map.java\u0012,3\\a\\3a83602c799ded541811f282e2524ca707cc351b\nT\n$src/main/java/org/game/Map/Door.java\u0012,9\\5\\95e852f03d23ecabb97806217a07c752c409eb7b\n[\n+src/main/java/org/game/Map/EdgeManager.java\u0012,f\\2\\f2d42c4e44b2723eb7efe0208d64f67bd717e8ff\nQ\n!src/main/java/org/game/Isten.java\u0012,a\\e\\ae6b841d57349f3d394f98633de24bf000774d96\nK\n\u001Bsrc/main/java/org/Main.java\u0012,8\\5\\8562f6886f731299c0b6925e0dca2ed59ddafa0c\nQ\n!src/main/java/org/items/Item.java\u0012,c\\4\\c4bd7d38976ca5aef7092b829c2de7aa2795bfa7\nT\n$src/main/java/org/game/Map/Wall.java\u0012,5\\9\\59f88d28553f94fc6ef2453d83f314324b3d302f\nd\n4src/main/java/org/networking/ClientPacketSender.java\u0012,3\\6\\36f764fb525f2cfaaabf9b6785222f478b762c6d\n`\n0src/main/java/org/networking/HandlerManager.java\u0012,e\\a\\eae9dc057e2fdbe6747a231ce61370cbe2f6501c\n`\n0src/main/java/org/game/Map/Algorithms/Merge.java\u0012,b\\a\\baff089f608458594c4180e74c00e7cdedf66f6c
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/sonarlint/issuestore/index.pb b/.idea/sonarlint/issuestore/index.pb
--- a/.idea/sonarlint/issuestore/index.pb	(revision 2de02ed084cf3446ea9c0020a85b83e8f9ecb48d)
+++ b/.idea/sonarlint/issuestore/index.pb	(date 1715122538686)
@@ -44,4 +44,14 @@
 `
 0src/main/java/org/networking/HandlerManager.java,e\a\eae9dc057e2fdbe6747a231ce61370cbe2f6501c
 `
-0src/main/java/org/game/Map/Algorithms/Merge.java,b\a\baff089f608458594c4180e74c00e7cdedf66f6c
\ No newline at end of file
+0src/main/java/org/game/Map/Algorithms/Merge.java,b\a\baff089f608458594c4180e74c00e7cdedf66f6c
+j
+:src/main/java/org/networking/Packet22EdgePieceChanged.java,e\e\ee5f6236aa51b4f6af044d3fcc4dbaf443e24c03
+b
+2src/main/java/org/networking/Packet04UnitRoom.java,1\6\169d9ada591f37be86a4e8122319c57317a11ee7
+c
+3src/main/java/org/items/usable_items/Camembert.java,e\2\e2e6e4cf9af87debc02da52dc814f27fea01d5c1
+d
+4src/main/java/org/items/usable_items/Transistor.java,f\1\f1e5fb6da1f484afc6699c3f88fb9c3062b14de2
+e
+5src/main/java/org/networking/PlayerStatusHandler.java,6\4\647b353b1eed4c1112055b259e9776df21eb9338
\ No newline at end of file
Index: .idea/sonarlint/securityhotspotstore/index.pb
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\n9\n\tREADME.md\u0012,8\\e\\8ec9a00bfd09b3190ac6b22251dbb1aa95a0579d\nX\n(src/main/java/org/items/ItemManager.java\u0012,5\\8\\58f412e7843066f3f085fcbcffbcd715deb97352\nY\n)src/main/java/org/items/ChestManager.java\u0012,c\\a\\ca0db237d642623320d941e9c23c4dea256bde23\nR\n\"src/main/java/org/items/Chest.java\u0012,7\\6\\768fc9e076fa68cb423d0b0f6604f4e0296bed89\n\\\n,src/main/java/org/game/Map/Mapgenerator.java\u0012,4\\f\\4fdc75f760398ad335804099c4c2aad3b4db38bd\nX\n(src/main/java/org/game/Map/UnitRoom.java\u0012,9\\3\\933c10faafd44b7f4f2d1678304c648f862e5581\nX\n(src/main/java/org/game/Map/RoomType.java\u0012,0\\9\\098e2fb073f84303e4936b5215044c9bf5a18688\nT\n$src/main/java/org/game/Map/Room.java\u0012,c\\6\\c6f7b65f617fe34dc6a651a2bf566be4a0d2a975\nU\n%src/main/java/org/game/Map/Graph.java\u0012,2\\8\\28d1f759a36d54a51a083e3d0d8d00b338f093d2\n]\n-src/main/java/org/entities/player/Player.java\u0012,e\\4\\e4271d76d0528cc918e2133542540146c36b8cc9\n`\n0src/main/java/org/game/Map/EdgeBetweenRooms.java\u0012,9\\c\\9c5b76ca10ecfaf22d96236316b037e6470b3693\nY\n)src/main/java/org/game/Map/EdgePiece.java\u0012,3\\2\\32b4cbc356009b9e8f6511eeac1b9dfc5d01c561\n\\\n,src/main/java/org/networking/MapHandler.java\u0012,f\\3\\f33af664d2d865bb0ccc96ecd9a7130b9bdfb148\nS\n#src/main/java/org/game/Map/Map.java\u0012,3\\a\\3a83602c799ded541811f282e2524ca707cc351b\nT\n$src/main/java/org/game/Map/Door.java\u0012,9\\5\\95e852f03d23ecabb97806217a07c752c409eb7b\n[\n+src/main/java/org/game/Map/EdgeManager.java\u0012,f\\2\\f2d42c4e44b2723eb7efe0208d64f67bd717e8ff\nQ\n!src/main/java/org/game/Isten.java\u0012,a\\e\\ae6b841d57349f3d394f98633de24bf000774d96\nK\n\u001Bsrc/main/java/org/Main.java\u0012,8\\5\\8562f6886f731299c0b6925e0dca2ed59ddafa0c\nQ\n!src/main/java/org/items/Item.java\u0012,c\\4\\c4bd7d38976ca5aef7092b829c2de7aa2795bfa7\nT\n$src/main/java/org/game/Map/Wall.java\u0012,5\\9\\59f88d28553f94fc6ef2453d83f314324b3d302f\nd\n4src/main/java/org/networking/ClientPacketSender.java\u0012,3\\6\\36f764fb525f2cfaaabf9b6785222f478b762c6d\n`\n0src/main/java/org/networking/HandlerManager.java\u0012,e\\a\\eae9dc057e2fdbe6747a231ce61370cbe2f6501c\n`\n0src/main/java/org/game/Map/Algorithms/Merge.java\u0012,b\\a\\baff089f608458594c4180e74c00e7cdedf66f6c
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/sonarlint/securityhotspotstore/index.pb b/.idea/sonarlint/securityhotspotstore/index.pb
--- a/.idea/sonarlint/securityhotspotstore/index.pb	(revision 2de02ed084cf3446ea9c0020a85b83e8f9ecb48d)
+++ b/.idea/sonarlint/securityhotspotstore/index.pb	(date 1715122538712)
@@ -44,4 +44,14 @@
 `
 0src/main/java/org/networking/HandlerManager.java,e\a\eae9dc057e2fdbe6747a231ce61370cbe2f6501c
 `
-0src/main/java/org/game/Map/Algorithms/Merge.java,b\a\baff089f608458594c4180e74c00e7cdedf66f6c
\ No newline at end of file
+0src/main/java/org/game/Map/Algorithms/Merge.java,b\a\baff089f608458594c4180e74c00e7cdedf66f6c
+j
+:src/main/java/org/networking/Packet22EdgePieceChanged.java,e\e\ee5f6236aa51b4f6af044d3fcc4dbaf443e24c03
+b
+2src/main/java/org/networking/Packet04UnitRoom.java,1\6\169d9ada591f37be86a4e8122319c57317a11ee7
+c
+3src/main/java/org/items/usable_items/Camembert.java,e\2\e2e6e4cf9af87debc02da52dc814f27fea01d5c1
+d
+4src/main/java/org/items/usable_items/Transistor.java,f\1\f1e5fb6da1f484afc6699c3f88fb9c3062b14de2
+e
+5src/main/java/org/networking/PlayerStatusHandler.java,6\4\647b353b1eed4c1112055b259e9776df21eb9338
\ No newline at end of file
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"AutoImportSettings\">\r\n    <option name=\"autoReloadType\" value=\"SELECTIVE\" />\r\n  </component>\r\n  <component name=\"ChangeListManager\">\r\n    <list default=\"true\" id=\"3506ab6d-0407-47f2-a7e8-78ebc867e577\" name=\"Changes\" comment=\"it's working\">\r\n      <change beforePath=\"$PROJECT_DIR$/src/main/java/org/entities/player/Player.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/main/java/org/entities/player/Player.java\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/src/main/java/org/game/Isten.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/main/java/org/game/Isten.java\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/src/main/java/org/game/Map/Door.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/main/java/org/game/Map/Door.java\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/src/main/java/org/game/Map/EdgeManager.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/main/java/org/game/Map/EdgeManager.java\" afterDir=\"false\" />\r\n    </list>\r\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\r\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\r\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\r\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\r\n  </component>\r\n  <component name=\"ExternalProjectsData\">\r\n    <projectState path=\"$PROJECT_DIR$\">\r\n      <ProjectState />\r\n    </projectState>\r\n  </component>\r\n  <component name=\"ExternalProjectsManager\">\r\n    <system id=\"GRADLE\">\r\n      <state>\r\n        <task path=\"$PROJECT_DIR$\">\r\n          <activation />\r\n        </task>\r\n        <projects_view>\r\n          <tree_state>\r\n            <expand />\r\n            <select />\r\n          </tree_state>\r\n        </projects_view>\r\n      </state>\r\n    </system>\r\n  </component>\r\n  <component name=\"FileTemplateManagerImpl\">\r\n    <option name=\"RECENT_TEMPLATES\">\r\n      <list>\r\n        <option value=\"Interface\" />\r\n        <option value=\"Class\" />\r\n      </list>\r\n    </option>\r\n  </component>\r\n  <component name=\"Git.Settings\">\r\n    <option name=\"RECENT_BRANCH_BY_REPOSITORY\">\r\n      <map>\r\n        <entry key=\"$PROJECT_DIR$\" value=\"5cd5399fbfcfd5811c762cb41388070c81f45885\" />\r\n      </map>\r\n    </option>\r\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\r\n  </component>\r\n  <component name=\"MarkdownSettingsMigration\">\r\n    <option name=\"stateVersion\" value=\"1\" />\r\n  </component>\r\n  <component name=\"ProjectColorInfo\">{\r\n  &quot;associatedIndex&quot;: 8\r\n}</component>\r\n  <component name=\"ProjectId\" id=\"2frbzqFlsraLkUjUjuqMYUBt0BV\" />\r\n  <component name=\"ProjectViewState\">\r\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\r\n    <option name=\"showLibraryContents\" value=\"true\" />\r\n  </component>\r\n  <component name=\"PropertiesComponent\">{\r\n  &quot;keyToString&quot;: {\r\n    &quot;Downloaded.Files.Path.Enabled&quot;: &quot;false&quot;,\r\n    &quot;Gradle.MultiplayerTester.executor&quot;: &quot;Run&quot;,\r\n    &quot;Gradle.MultiplayerTester.testPacket01.executor&quot;: &quot;Run&quot;,\r\n    &quot;Gradle.MultiplayerTester.testPacket02Constructor.executor&quot;: &quot;Run&quot;,\r\n    &quot;Gradle.iLaby [:Main.main()].executor&quot;: &quot;Run&quot;,\r\n    &quot;Gradle.iLaby [run].executor&quot;: &quot;Run&quot;,\r\n    &quot;Repository.Attach.Annotations&quot;: &quot;false&quot;,\r\n    &quot;Repository.Attach.JavaDocs&quot;: &quot;false&quot;,\r\n    &quot;Repository.Attach.Sources&quot;: &quot;false&quot;,\r\n    &quot;RunOnceActivity.OpenProjectViewOnStart&quot;: &quot;true&quot;,\r\n    &quot;RunOnceActivity.ShowReadmeOnStart&quot;: &quot;true&quot;,\r\n    &quot;WebServerToolWindowFactoryState&quot;: &quot;false&quot;,\r\n    &quot;git-widget-placeholder&quot;: &quot;main&quot;,\r\n    &quot;kotlin-language-version-configured&quot;: &quot;true&quot;,\r\n    &quot;last_opened_file_path&quot;: &quot;C:/Users/kuruc/Downloads/junit-4.13.2.jar&quot;,\r\n    &quot;node.js.detected.package.eslint&quot;: &quot;true&quot;,\r\n    &quot;node.js.detected.package.tslint&quot;: &quot;true&quot;,\r\n    &quot;node.js.selected.package.eslint&quot;: &quot;(autodetect)&quot;,\r\n    &quot;node.js.selected.package.tslint&quot;: &quot;(autodetect)&quot;,\r\n    &quot;nodejs_package_manager_path&quot;: &quot;npm&quot;,\r\n    &quot;project.structure.last.edited&quot;: &quot;Modules&quot;,\r\n    &quot;project.structure.proportion&quot;: &quot;0.15&quot;,\r\n    &quot;project.structure.side.proportion&quot;: &quot;0.2&quot;,\r\n    &quot;settings.editor.selected.configurable&quot;: &quot;reference.settingsdialog.project.gradle&quot;,\r\n    &quot;vue.rearranger.settings.migration&quot;: &quot;true&quot;\r\n  }\r\n}</component>\r\n  <component name=\"RunManager\" selected=\"Gradle.iLaby [run]\">\r\n    <configuration name=\"MultiplayerTester\" type=\"GradleRunConfiguration\" factoryName=\"Gradle\" temporary=\"true\">\r\n      <ExternalSystemSettings>\r\n        <option name=\"executionName\" />\r\n        <option name=\"externalProjectPath\" value=\"$PROJECT_DIR$\" />\r\n        <option name=\"externalSystemIdString\" value=\"GRADLE\" />\r\n        <option name=\"scriptParameters\" value=\"\" />\r\n        <option name=\"taskDescriptions\">\r\n          <list />\r\n        </option>\r\n        <option name=\"taskNames\">\r\n          <list>\r\n            <option value=\":test\" />\r\n            <option value=\"--tests\" />\r\n            <option value=\"&quot;MultiplayerTester&quot;\" />\r\n          </list>\r\n        </option>\r\n        <option name=\"vmOptions\" />\r\n      </ExternalSystemSettings>\r\n      <ExternalSystemDebugServerProcess>false</ExternalSystemDebugServerProcess>\r\n      <ExternalSystemReattachDebugProcess>true</ExternalSystemReattachDebugProcess>\r\n      <DebugAllEnabled>false</DebugAllEnabled>\r\n      <RunAsTest>true</RunAsTest>\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration name=\"MultiplayerTester.testPacket01\" type=\"GradleRunConfiguration\" factoryName=\"Gradle\" temporary=\"true\">\r\n      <ExternalSystemSettings>\r\n        <option name=\"executionName\" />\r\n        <option name=\"externalProjectPath\" value=\"$PROJECT_DIR$\" />\r\n        <option name=\"externalSystemIdString\" value=\"GRADLE\" />\r\n        <option name=\"scriptParameters\" value=\"\" />\r\n        <option name=\"taskDescriptions\">\r\n          <list />\r\n        </option>\r\n        <option name=\"taskNames\">\r\n          <list>\r\n            <option value=\":test\" />\r\n            <option value=\"--tests\" />\r\n            <option value=\"&quot;MultiplayerTester.testPacket01&quot;\" />\r\n          </list>\r\n        </option>\r\n        <option name=\"vmOptions\" />\r\n      </ExternalSystemSettings>\r\n      <ExternalSystemDebugServerProcess>false</ExternalSystemDebugServerProcess>\r\n      <ExternalSystemReattachDebugProcess>true</ExternalSystemReattachDebugProcess>\r\n      <DebugAllEnabled>false</DebugAllEnabled>\r\n      <RunAsTest>true</RunAsTest>\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration name=\"MultiplayerTester.testPacket02Constructor\" type=\"GradleRunConfiguration\" factoryName=\"Gradle\" temporary=\"true\">\r\n      <ExternalSystemSettings>\r\n        <option name=\"executionName\" />\r\n        <option name=\"externalProjectPath\" value=\"$PROJECT_DIR$\" />\r\n        <option name=\"externalSystemIdString\" value=\"GRADLE\" />\r\n        <option name=\"scriptParameters\" value=\"\" />\r\n        <option name=\"taskDescriptions\">\r\n          <list />\r\n        </option>\r\n        <option name=\"taskNames\">\r\n          <list>\r\n            <option value=\":test\" />\r\n            <option value=\"--tests\" />\r\n            <option value=\"&quot;MultiplayerTester.testPacket02Constructor&quot;\" />\r\n          </list>\r\n        </option>\r\n        <option name=\"vmOptions\" />\r\n      </ExternalSystemSettings>\r\n      <ExternalSystemDebugServerProcess>false</ExternalSystemDebugServerProcess>\r\n      <ExternalSystemReattachDebugProcess>true</ExternalSystemReattachDebugProcess>\r\n      <DebugAllEnabled>false</DebugAllEnabled>\r\n      <RunAsTest>true</RunAsTest>\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration name=\"iLaby [run]\" type=\"GradleRunConfiguration\" factoryName=\"Gradle\" singleton=\"false\" nameIsGenerated=\"true\">\r\n      <ExternalSystemSettings>\r\n        <option name=\"executionName\" />\r\n        <option name=\"externalProjectPath\" value=\"$PROJECT_DIR$\" />\r\n        <option name=\"externalSystemIdString\" value=\"GRADLE\" />\r\n        <option name=\"scriptParameters\" value=\"\" />\r\n        <option name=\"taskDescriptions\">\r\n          <list />\r\n        </option>\r\n        <option name=\"taskNames\">\r\n          <list>\r\n            <option value=\"run\" />\r\n          </list>\r\n        </option>\r\n        <option name=\"vmOptions\" />\r\n      </ExternalSystemSettings>\r\n      <ExternalSystemDebugServerProcess>true</ExternalSystemDebugServerProcess>\r\n      <ExternalSystemReattachDebugProcess>true</ExternalSystemReattachDebugProcess>\r\n      <DebugAllEnabled>false</DebugAllEnabled>\r\n      <RunAsTest>false</RunAsTest>\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <list>\r\n      <item itemvalue=\"Gradle.iLaby [run]\" />\r\n      <item itemvalue=\"Gradle.MultiplayerTester\" />\r\n      <item itemvalue=\"Gradle.MultiplayerTester.testPacket02Constructor\" />\r\n      <item itemvalue=\"Gradle.MultiplayerTester.testPacket01\" />\r\n    </list>\r\n    <recent_temporary>\r\n      <list>\r\n        <item itemvalue=\"Gradle.MultiplayerTester.testPacket01\" />\r\n        <item itemvalue=\"Gradle.MultiplayerTester.testPacket02Constructor\" />\r\n        <item itemvalue=\"Gradle.MultiplayerTester\" />\r\n        <item itemvalue=\"Gradle.MultiplayerTester\" />\r\n        <item itemvalue=\"Gradle.MultiplayerTester.testPacket02Constructor\" />\r\n      </list>\r\n    </recent_temporary>\r\n  </component>\r\n  <component name=\"SharedIndexes\">\r\n    <attachedChunks>\r\n      <set>\r\n        <option value=\"jdk-18.0.2-corretto-18.0.2-4caba194b151-5720f15e\" />\r\n        <option value=\"jdk-21.0.2-openjdk-21.0.2-4caba194b151-4f524021\" />\r\n      </set>\r\n    </attachedChunks>\r\n  </component>\r\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"application-level\" UseSingleDictionary=\"true\" transferred=\"true\" />\r\n  <component name=\"TaskManager\">\r\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\r\n      <changelist id=\"3506ab6d-0407-47f2-a7e8-78ebc867e577\" name=\"Changes\" comment=\"\" />\r\n      <created>1714562409879</created>\r\n      <option name=\"number\" value=\"Default\" />\r\n      <option name=\"presentableId\" value=\"Default\" />\r\n      <updated>1714562409879</updated>\r\n      <workItem from=\"1714562410886\" duration=\"908000\" />\r\n      <workItem from=\"1714687853059\" duration=\"1015000\" />\r\n      <workItem from=\"1714731678095\" duration=\"398000\" />\r\n      <workItem from=\"1714740938116\" duration=\"2592000\" />\r\n      <workItem from=\"1714743658125\" duration=\"732000\" />\r\n      <workItem from=\"1714747759256\" duration=\"7383000\" />\r\n      <workItem from=\"1714847163651\" duration=\"324000\" />\r\n      <workItem from=\"1714924570656\" duration=\"7744000\" />\r\n      <workItem from=\"1715002935390\" duration=\"1974000\" />\r\n      <workItem from=\"1715102723676\" duration=\"14303000\" />\r\n    </task>\r\n    <task id=\"LOCAL-00001\" summary=\"it's working\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1714665384490</created>\r\n      <option name=\"number\" value=\"00001\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00001\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1714665384490</updated>\r\n    </task>\r\n    <option name=\"localTasksCounter\" value=\"2\" />\r\n    <servers />\r\n  </component>\r\n  <component name=\"TypeScriptGeneratedFilesManager\">\r\n    <option name=\"version\" value=\"3\" />\r\n  </component>\r\n  <component name=\"Vcs.Log.Tabs.Properties\">\r\n    <option name=\"TAB_STATES\">\r\n      <map>\r\n        <entry key=\"MAIN\">\r\n          <value>\r\n            <State />\r\n          </value>\r\n        </entry>\r\n      </map>\r\n    </option>\r\n  </component>\r\n  <component name=\"VcsManagerConfiguration\">\r\n    <MESSAGE value=\"it's working\" />\r\n    <option name=\"LAST_COMMIT_MESSAGE\" value=\"it's working\" />\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	(revision 2de02ed084cf3446ea9c0020a85b83e8f9ecb48d)
+++ b/.idea/workspace.xml	(date 1715179555021)
@@ -5,10 +5,25 @@
   </component>
   <component name="ChangeListManager">
     <list default="true" id="3506ab6d-0407-47f2-a7e8-78ebc867e577" name="Changes" comment="it's working">
-      <change beforePath="$PROJECT_DIR$/src/main/java/org/entities/player/Player.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/org/entities/player/Player.java" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/src/main/java/org/game/Isten.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/org/game/Isten.java" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/src/main/java/org/game/Map/Door.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/org/game/Map/Door.java" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/src/main/java/org/game/Map/EdgeManager.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/org/game/Map/EdgeManager.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_01_05_2024_13_06_[Changes]/shelved.patch" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_01_05_2024_13_06_[Changes]/sus.amogus" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_01_05_2024_13_06__Changes_.xml" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_01_05_2024_13_38_[Changes]1/shelved.patch" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_01_05_2024_13_38_[Changes]1/sus.amogus" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_01_05_2024_13_38__Changes_1.xml" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/.idea/sonarlint/issuestore/0/9/098e2fb073f84303e4936b5215044c9bf5a18688" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/sonarlint/issuestore/0/9/098e2fb073f84303e4936b5215044c9bf5a18688" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/.idea/sonarlint/issuestore/3/a/3a83602c799ded541811f282e2524ca707cc351b" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/sonarlint/issuestore/3/a/3a83602c799ded541811f282e2524ca707cc351b" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/.idea/sonarlint/issuestore/4/f/4fdc75f760398ad335804099c4c2aad3b4db38bd" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/sonarlint/issuestore/4/f/4fdc75f760398ad335804099c4c2aad3b4db38bd" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/.idea/sonarlint/issuestore/9/3/933c10faafd44b7f4f2d1678304c648f862e5581" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/sonarlint/issuestore/9/3/933c10faafd44b7f4f2d1678304c648f862e5581" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/.idea/sonarlint/issuestore/9/5/95e852f03d23ecabb97806217a07c752c409eb7b" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/sonarlint/issuestore/9/5/95e852f03d23ecabb97806217a07c752c409eb7b" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/.idea/sonarlint/issuestore/a/e/ae6b841d57349f3d394f98633de24bf000774d96" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/sonarlint/issuestore/a/e/ae6b841d57349f3d394f98633de24bf000774d96" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/.idea/sonarlint/issuestore/c/6/c6f7b65f617fe34dc6a651a2bf566be4a0d2a975" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/sonarlint/issuestore/c/6/c6f7b65f617fe34dc6a651a2bf566be4a0d2a975" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/.idea/sonarlint/issuestore/e/4/e4271d76d0528cc918e2133542540146c36b8cc9" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/sonarlint/issuestore/e/4/e4271d76d0528cc918e2133542540146c36b8cc9" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/.idea/sonarlint/issuestore/e/a/eae9dc057e2fdbe6747a231ce61370cbe2f6501c" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/sonarlint/issuestore/e/a/eae9dc057e2fdbe6747a231ce61370cbe2f6501c" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/.idea/sonarlint/issuestore/f/2/f2d42c4e44b2723eb7efe0208d64f67bd717e8ff" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/sonarlint/issuestore/f/2/f2d42c4e44b2723eb7efe0208d64f67bd717e8ff" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/.idea/sonarlint/issuestore/index.pb" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/sonarlint/issuestore/index.pb" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/.idea/sonarlint/securityhotspotstore/index.pb" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/sonarlint/securityhotspotstore/index.pb" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
     </list>
     <option name="SHOW_DIALOG" value="false" />
     <option name="HIGHLIGHT_CONFLICTS" value="true" />
@@ -227,7 +242,8 @@
       <workItem from="1714847163651" duration="324000" />
       <workItem from="1714924570656" duration="7744000" />
       <workItem from="1715002935390" duration="1974000" />
-      <workItem from="1715102723676" duration="14303000" />
+      <workItem from="1715102723676" duration="14729000" />
+      <workItem from="1715178619248" duration="931000" />
     </task>
     <task id="LOCAL-00001" summary="it's working">
       <option name="closed" value="true" />
diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_01_05_2024_13_06_[Changes]/shelved.patch b/.idea/shelf/Uncommitted_changes_before_Update_at_01_05_2024_13_06_[Changes]/shelved.patch
deleted file mode 100644
