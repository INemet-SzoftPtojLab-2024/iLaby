Index: src/main/java/org/game/Map/Map.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package main.java.org.game.Map;\r\n\r\nimport main.java.org.game.Graphics.Image;\r\nimport main.java.org.game.Isten;\r\nimport main.java.org.game.physics.Collider;\r\nimport main.java.org.game.updatable.Updatable;\r\nimport main.java.org.linalg.Vec2;\r\n\r\nimport java.util.*;\r\n\r\n\r\npublic class Map extends Updatable {\r\n    private Mapgenerator mapgenerator;\r\n    ArrayList<Room> rooms;\r\n    private UnitRoom[][] unitRooms;\r\n    private final int mapRowSize;\r\n    private final int mapColumnSize;\r\n    private EdgeManager edgeManager;\r\n    private final int minRoomSize;\r\n    private boolean isGenerated = false;\r\n    //private boolean\r\n    @Override\r\n    public void onStart(Isten isten) {\r\n\r\n        Mapgenerator mapgenerator = new Mapgenerator(this, isten);\r\n        mapgenerator.generateSideWalls();\r\n        //printMap();\r\n    }\r\n\r\n    public void init(Isten isten) {\r\n        this.mapgenerator = new Mapgenerator(this, isten);\r\n        mapgenerator.generate(minRoomSize);\r\n        isGenerated = true;\r\n    }\r\n\r\n    public Map(Isten isten, int rowNumber, int columnNumber, int minRoomSize){\r\n        this.mapRowSize = rowNumber;\r\n        this.mapColumnSize = columnNumber;\r\n        this.minRoomSize = minRoomSize;\r\n        //unitrooms is set in the generator --> onstart\r\n        this.rooms = new ArrayList<>();\r\n        this.edgeManager = new EdgeManager(isten);\r\n        initUnitRooms();\r\n\r\n    }\r\n\r\n    //for testing\r\n    boolean merged = false;\r\n    double delta = 0;\r\n    int cnt = 0;\r\n    int r = 0;\r\n    @Override\r\n    public void onUpdate(Isten isten, double deltaTime) {\r\n        //for testing\r\n        delta += deltaTime;\r\n        if (delta > 3 && cnt < 4 && !merged) {\r\n            //mergeRooms(rooms.get(0), rooms.get(0).getAdjacentRooms().get(0), isten);\r\n            /*if (!splitRooms(rooms.get(r), isten)) r++;\r\n            else {\r\n                r = 0;\r\n            }\r\n\r\n             */\r\n            System.out.println();\r\n            System.out.println();\r\n            //printMap();\r\n            cnt++;\r\n            delta = 0;\r\n            merged = true;\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void onDestroy() {\r\n\r\n    }\r\n    public void initUnitRooms(){\r\n        unitRooms = new UnitRoom[mapRowSize][mapColumnSize];\r\n        for(int i = 0; i<mapRowSize;i++)\r\n        {\r\n            for(int j = 0;j<mapColumnSize;j++)\r\n            {\r\n                unitRooms[i][j] = new UnitRoom(new Vec2(j,i));\r\n            }\r\n        }\r\n    }\r\n\r\n    //csak akkor ha minden ajto nyitva van!!\r\n    //a slitelesnel csak a minroomsize fele engedelyezett\r\n    private boolean splitRooms(Room r1, Isten isten)\r\n    {\r\n        if(r1.getUnitRooms().size() < minRoomSize) return false;\r\n        //egyenlőre minden szoba ami splittel lesz createlve ilyen type-val rendelkezik\r\n        int newID = generateNewRoomID(); //már kész van, teszt miatt nincs hasznalva\r\n        //int newId = 999;\r\n        Room newRoom = new Room(newID);\r\n        int lowestRowIdx = getRoomWithLowestRowIdx(r1);\r\n        ArrayList<UnitRoom> addableUnitRooms = new ArrayList<>();\r\n        int distance = 0;\r\n        ArrayList<UnitRoom> UnitRoomsWithDistanceXFromLowestRow;\r\n        //addig, amíg az új szoba a méret fele nem lesz\r\n        while(addableUnitRooms.size()<r1.getUnitRooms().size()/2){\r\n            UnitRoomsWithDistanceXFromLowestRow=getUnitRoomsWithXDistanceFromLowestRowIdxInOrderByColumn(r1,lowestRowIdx,distance++); //tavolsag novelese, es igy soronkent egyesevel balrol jobbra az osszes unitroom hozzaadasa, amig kell\r\n            for(UnitRoom addableUnitRoom:UnitRoomsWithDistanceXFromLowestRow){\r\n                if(addableUnitRooms.size()<r1.getUnitRooms().size()/2 )\r\n                {\r\n                    addableUnitRooms.add(addableUnitRoom);\r\n                }\r\n\r\n            }\r\n        }\r\n        ArrayList<UnitRoom> oldRoomWithoutNewRoom = getDifference(r1.getUnitRooms(),addableUnitRooms);\r\n        //ellenorzom, hogy osszefuggoek lennének-e: ha igen:\r\n        if( kruskalAlgoImplementation(oldRoomWithoutNewRoom) && kruskalAlgoImplementation(addableUnitRooms)) {\r\n            // removeoljuk a szomszedos roomok szomszedossagi listaibol a szobat, es a func vegen hozzaadjuk a ket szetvalasztott szoba egyiket/mindekettot\r\n            for(Room neighbourRoom : r1.getAdjacentRooms()){\r\n                neighbourRoom.getAdjacentRooms().remove(r1);\r\n            }\r\n            for (UnitRoom addUnitRoomToNewRoom : addableUnitRooms) {\r\n                //kivesszük az előző szobából a  aunitroomot\r\n                addUnitRoomToNewRoom.getOwnerRoom().getUnitRooms().remove(addUnitRoomToNewRoom);\r\n                addUnitRoomToNewRoom.setOwnerRoom(newRoom);\r\n                //hozzáadjuk az új szobához a unitroomot\r\n                newRoom.getUnitRooms().add(addUnitRoomToNewRoom);\r\n            }\r\n            rooms.add(newRoom);\r\n            newRoom.setAdjacentRooms();\r\n            r1.setAdjacentRooms();\r\n\r\n            //set the images\r\n            for(UnitRoom unitRoom : newRoom.getUnitRooms()) {\r\n                unitRoom.addRightImage(isten);\r\n            }\r\n            //update nodeRooms and generate the new ones\r\n            //also updates the images and colliders\r\n            edgeManager.updateEdgesAfterSplit(r1, newRoom);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n\r\n    public static ArrayList<UnitRoom> getDifference(ArrayList<UnitRoom> u1, ArrayList<UnitRoom> u2)\r\n    {\r\n        ArrayList<UnitRoom> difference = new ArrayList<>();\r\n        for (UnitRoom element : u1) {\r\n            if (!u2.contains(element)) {\r\n                difference.add(element);\r\n            }\r\n        }\r\n        return difference;\r\n    }\r\n    //nem biztos hogy így a legjobb\r\n    private boolean wouldRoomBeCoherent(ArrayList<UnitRoom> newRoomUnits)\r\n    {\r\n        UnitRoom starterRoom = newRoomUnits.get(0);\r\n        ArrayList<UnitRoom> coherentGraph = new ArrayList<>();\r\n        coherentGraph.add(starterRoom);\r\n        for(int i = 0;i<newRoomUnits.size();i++){\r\n            for(UnitRoom unitRoomToBeAddedToGraph : newRoomUnits){\r\n                 /*ha a size i-vel egyenlő, vagy kisebb nála, akkor tudjuk, hogy nem alkotnak összefüggő gráfot a UnitRoomok a Roomban,\r\n                    mert különben az előző körhöz képest legalább 1-et fel kellett volna tuidjak venni, vagy pedig már előtte többet kellett volna tudjak felvenni,\r\n                    rekurzív gondolat, mukodik (remelem)*/\r\n                if(coherentGraph.size()> i)\r\n                {\r\n                    if (!unitRoomToBeAddedToGraph.equals(coherentGraph.get(i))\r\n                            && !coherentGraph.contains(unitRoomToBeAddedToGraph)\r\n                            && unitRoomToBeAddedToGraph.isAdjacent(coherentGraph.get(i)))\r\n                    {\r\n                        coherentGraph.add(unitRoomToBeAddedToGraph);\r\n                        //break; ezzel valszeg effektivebb\r\n                    }\r\n                }\r\n                else{\r\n                    System.out.println(\"Nem lennenek koherensek a szobak\");\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        //mivel minden indexen vegig tudtunk menni ezert tudunk truet returnolni, azert biztonsag kedveert meg egy kontrollt bennhagyok\r\n        if(coherentGraph.size() == newRoomUnits.size()) return true;\r\n            //hogyha nem egyenlok akkor false menjen ki, bar egyenloknek kene lenniuk\r\n        else return false;\r\n    }\r\n    //elozo fv, vagyis wouldRoomBeCoherent atirasa generikusra, es akkor egy wouldMapBeCoherent fv-t is helyettesit.\r\n    private<T extends Graph> boolean kruskalAlgoImplementation(ArrayList<T> newCoherentElements)\r\n    {\r\n        T starterRoom = newCoherentElements.get(0);\r\n        ArrayList<T> coherentGraph = new ArrayList<>();\r\n        coherentGraph.add(starterRoom);\r\n        for(int i = 0;i<newCoherentElements.size();i++){\r\n            for(T ElementToBeAddedToGraph : newCoherentElements){\r\n                 /*ha a size i-vel egyenlő, vagy kisebb nála, akkor tudjuk, hogy nem alkotnak összefüggő gráfot a UnitRoomok a Roomban,\r\n                    mert különben az előző körhöz képest legalább 1-et fel kellett volna tuidjak venni, vagy pedig már előtte többet kellett volna tudjak felvenni,\r\n                    rekurzív gondolat, mukodik (remelem)*/\r\n                if(coherentGraph.size()> i)\r\n                {\r\n                    if (!ElementToBeAddedToGraph.equals(coherentGraph.get(i))\r\n                            && !coherentGraph.contains(ElementToBeAddedToGraph)\r\n                            && ElementToBeAddedToGraph.isAdjacent(coherentGraph.get(i)))\r\n                    {\r\n                        coherentGraph.add(ElementToBeAddedToGraph);\r\n                        //break; ezzel valszeg effektivebb\r\n                    }\r\n                }\r\n                else{\r\n                    System.out.println(\"Nem lennenek koherensek a szobak\");\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        //mivel minden indexen vegig tudtunk menni ezert tudunk truet returnolni, azert biztonsag kedveert meg egy kontrollt bennhagyok\r\n        if(coherentGraph.size() == newCoherentElements.size()) return true;\r\n            //hogyha nem egyenlok akkor false menjen ki, bar egyenloknek kene lenniuk\r\n        else return false;\r\n    }\r\n\r\n    //function hogy megtalaljam a legkisebb sorindexet a tombben, viszonyitasi parameter lesz.\r\n    // splitRooms func-on belül használva\r\n    private int getRoomWithLowestRowIdx(Room r1) {\r\n        UnitRoom min = unitRooms[mapRowSize-1][mapColumnSize-1];\r\n        for(UnitRoom unitRoom : r1.getUnitRooms())\r\n        {\r\n            if(unitRoom.getRowNum()<min.getRowNum())\r\n            {\r\n                min = unitRoom;\r\n            }\r\n        }\r\n        return min.getRowNum();\r\n    }\r\n    //function hogy megtalaljam azon UnitRoomokat, amik egy adott szamu soraban vannak a szobanaka alulrol nezve, amit a distance hataroz meg\r\n    // splitRooms func-on belül használva\r\n    private ArrayList<UnitRoom> getUnitRoomsWithXDistanceFromLowestRowIdxInOrderByColumn(Room r1, int lowestRowIdx, int distance) {\r\n        ArrayList<UnitRoom> ret = new ArrayList<>();\r\n        for(UnitRoom unitRoom: r1.getUnitRooms()){\r\n            if(unitRoom.getRowNum()==lowestRowIdx+distance){\r\n                ret.add(unitRoom);\r\n            }\r\n        }\r\n        ret.sort(Comparator.comparing(UnitRoom::getColNum));\r\n        return ret;\r\n    }\r\n\r\n    //ez a fv a mapgenerátorban is hasonlóan szerepel (colliderek és imagek nélkül)\r\n    private void mergeRooms(Room r1, Room r2, Isten isten) {\r\n        if(!r1.isAdjacent(r2) || r1.getID() == r2.getID()){\r\n            System.err.println(\"cant be merged\");\r\n            return;\r\n        }\r\n        System.out.println(r2.getID() + \"(r2) is merged to (r1)\" + r1.getID());\r\n        //remove r2 and keep r1;\r\n\r\n        //set colliders\r\n\r\n        edgeManager.deleteEdge(r1,r2);\r\n        edgeManager.updateEdgesAfterMerge(r1,r2);\r\n\r\n        for(UnitRoom unitRoom : r2.getUnitRooms()){\r\n            //r1.getUnitRooms().add(unitroom);\r\n            unitRoom.setOwnerRoom(r1);\r\n\r\n            //setting the new images of the deleted room\r\n            //this method cares about the renderable items too\r\n            unitRoom.addRightImage(isten);\r\n        }\r\n\r\n        r1.getUnitRooms().addAll(r2.getUnitRooms()); //insted of this: r1.getUnitRooms().add(unitroom);\r\n\r\n        r1.getAdjacentRooms().remove(r2);\r\n        r2.getAdjacentRooms().remove(r1);\r\n        for(Room adj : r2.getAdjacentRooms()){\r\n            if(!r1.getAdjacentRooms().contains(adj) && !adj.equals(r1)){\r\n                //System.out.println(\"adjroom added in r1: \" + adj.getID());\r\n                r1.getAdjacentRooms().add(adj);\r\n            }\r\n            adj.getAdjacentRooms().remove(r2);\r\n            if(!adj.getAdjacentRooms().contains(r1)) {\r\n                adj.getAdjacentRooms().add(r1);\r\n            }\r\n        }\r\n\r\n        r2.getAdjacentRooms().clear();\r\n        r2.getUnitRooms().clear();\r\n\r\n        //r1.setDiscovered(r2.isDiscovered());\r\n        //r1.setPlayerCount(r1.getPlayerCount() + r2.getPlayerCount());\r\n        //r1.setRoomType(r2.getRoomType());\r\n        r1.setMaxPlayerCount(r1.getMaxPlayerCount() + r2.getMaxPlayerCount());\r\n        rooms.remove(r2);\r\n\r\n\r\n    }\r\n\r\n    //merge the rooms until every room has minimumm size of the given number\r\n    private void printMap(){\r\n        for(int i = 0;i < mapRowSize;i++){ //test\r\n            for(int j = 0; j< mapColumnSize;j++){\r\n                if(unitRooms[i][j].getOwnerRoom().getID() < 10) {\r\n                    System.out.print(unitRooms[i][j].getOwnerRoom().getID() + \"     \");\r\n                }\r\n                else if(unitRooms[i][j].getOwnerRoom().getID() >= 10 && unitRooms[i][j].getOwnerRoom().getID() < 100) {\r\n                    System.out.print(unitRooms[i][j].getOwnerRoom().getID() + \"    \");\r\n                }\r\n                else if(unitRooms[i][j].getOwnerRoom().getID() >= 100) {\r\n                    System.out.print(unitRooms[i][j].getOwnerRoom().getID() + \"   \");\r\n                }\r\n            }\r\n            System.out.println();\r\n            System.out.println();\r\n        }\r\n    }\r\n    private int generateNewRoomID(){\r\n        int newID = 0;\r\n        while(true){\r\n            int roomCnt = 0;\r\n            for(Room room : rooms){\r\n                if(room.getID() == newID){\r\n                    newID++;\r\n                    break; //not found, try the next ID\r\n                }\r\n                roomCnt++;\r\n            }\r\n            if(roomCnt == rooms.size()){\r\n                return newID;\r\n            }\r\n\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n    public void setRooms(ArrayList<Room> rooms) {this.rooms = rooms;}\r\n\r\n    public void setUnitRooms(UnitRoom[][] unitRooms) {\r\n        this.unitRooms = unitRooms;\r\n    }\r\n\r\n    public ArrayList<Room> getRooms() {\r\n        return rooms;\r\n    }\r\n\r\n    public UnitRoom[][] getUnitRooms() {\r\n        return unitRooms;\r\n    }\r\n\r\n    public int getMapRowSize() {\r\n        return mapRowSize;\r\n    }\r\n\r\n    public int getMapColumnSize() {\r\n        return mapColumnSize;\r\n    }\r\n    public EdgeManager getEdgeManager(){ return edgeManager;}\r\n    public boolean isGenerated() {\r\n        return isGenerated;\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/game/Map/Map.java b/src/main/java/org/game/Map/Map.java
--- a/src/main/java/org/game/Map/Map.java	(revision 9958912f55a80c03811a2b00d7463850b80669b5)
+++ b/src/main/java/org/game/Map/Map.java	(date 1714664510810)
@@ -41,7 +41,6 @@
         this.rooms = new ArrayList<>();
         this.edgeManager = new EdgeManager(isten);
         initUnitRooms();
-
     }
 
     //for testing
Index: src/main/java/org/networking/Packet.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package main.java.org.networking;\r\n\r\npublic abstract class Packet {\r\n    public static enum PacketTypes {\r\n        INVALID(-1),\r\n        LOGIN(00),\r\n        DISCONNECT(01),\r\n        MOVE(02),\r\n        ANIMATION(03),\r\n        UNITROOM(04),\r\n        VILLAIN(05),\r\n        VILLAINMOVE(06),\r\n        TIMER(07),\r\n        CHESTGENERATION(10),\r\n        CHESTOPENED(11),\r\n        ITEMPICKEDUP(12),\r\n        ITEMDROPPED(13),\r\n        WALL(20),\r\n        DEATH(21);\r\n        private int packetId;\r\n        private PacketTypes(int packetId) {\r\n            this.packetId = packetId;\r\n        }\r\n\r\n        public int getId() {\r\n            return packetId;\r\n        }\r\n    }\r\n\r\n\r\n    public byte packetId;\r\n\r\n    public Packet(int packetId) {\r\n        this.packetId = (byte)packetId;\r\n    }\r\n\r\n    public abstract void writeData(GameClient client);\r\n    public abstract void writeData(GameServer server);\r\n\r\n    public String readData(byte[] data) {\r\n        String message = new String(data).trim();\r\n        //System.out.println(message);\r\n        return message.substring(2);\r\n    }\r\n\r\n\r\n    public static PacketTypes lookupPacket(String packetId) {\r\n        try {\r\n            return lookupPacket(Integer.parseInt(packetId));\r\n        }\r\n        catch(NumberFormatException e) {\r\n            return PacketTypes.INVALID;\r\n        }\r\n\r\n    }\r\n    public static PacketTypes lookupPacket(int id) {\r\n        for(PacketTypes p: PacketTypes.values()) {\r\n            if(p.getId() == id) {\r\n                return p;\r\n            }\r\n        }\r\n        return PacketTypes.INVALID;\r\n    }\r\n\r\n\r\n    public abstract byte[] getData();\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/networking/Packet.java b/src/main/java/org/networking/Packet.java
--- a/src/main/java/org/networking/Packet.java	(revision 9958912f55a80c03811a2b00d7463850b80669b5)
+++ b/src/main/java/org/networking/Packet.java	(date 1714664694431)
@@ -16,7 +16,8 @@
         ITEMPICKEDUP(12),
         ITEMDROPPED(13),
         WALL(20),
-        DEATH(21);
+        DEATH(21),
+        EDGEPIECECHANGED(22);
         private int packetId;
         private PacketTypes(int packetId) {
             this.packetId = packetId;
Index: src/main/java/org/networking/MapHandler.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package main.java.org.networking;\r\n\r\nimport main.java.org.game.Isten;\r\nimport main.java.org.game.Map.EdgeBetweenRooms;\r\nimport main.java.org.game.Map.EdgePiece;\r\nimport main.java.org.game.Map.Map;\r\nimport main.java.org.linalg.Vec2;\r\n\r\npublic class MapHandler extends ServerSideHandler {\r\n\r\n    @Override\r\n    public void create(GameServer server) {\r\n        this.server = server;\r\n        this.isten = server.isten;\r\n        isten.getMap().init(isten);\r\n        isInitialized = true;\r\n        sendDataToWaitingClients();\r\n    }\r\n\r\n    @Override\r\n    public void sendDataToClient(PlayerMP client) {\r\n\r\n        if(!isInitialized) {\r\n            if(!waitingClients.contains(client)) waitingClients.add(client);\r\n            return;\r\n        }\r\n\r\n        Map map = isten.getMap();\r\n        for(int i = 0; i < map.getMapRowSize(); i++) {\r\n            for(int j = 0; j < map.getMapColumnSize(); j++) {\r\n                Vec2 pos = map.getUnitRooms()[i][j].getPosition();\r\n                int type = map.getUnitRooms()[i][j].getOwnerRoom().getRoomType().ordinal();\r\n                Packet04UnitRoom packet = new Packet04UnitRoom(pos.x, pos.y, type);\r\n                server.sendData(packet.getData(), client.ipAddress, client.port);\r\n            }\r\n            try {\r\n                Thread.sleep(15);\r\n            } catch (InterruptedException e) {\r\n                throw new RuntimeException(e);\r\n            }\r\n        }\r\n\r\n\r\n        //\r\n        for(int i = 0; i < map.getEdgeManager().getRoomEdges().size(); i++) {\r\n            EdgeBetweenRooms re = map.getEdgeManager().getRoomEdges().get(i);\r\n            for (int j = 0; j < re.getWalls().size(); j++) {\r\n                EdgePiece edgePiece = re.getWalls().get(j);\r\n                Vec2 pos = edgePiece.getImage().getPosition();\r\n                Vec2 scale = edgePiece.getImage().getScale();\r\n                Packet20Wall packet = new Packet20Wall(pos.x, pos.y, scale.x, scale.y, edgePiece.isDoor());\r\n                server.sendData(packet.getData(), client.ipAddress, client.port);\r\n            }\r\n            try {\r\n                Thread.sleep(5);\r\n            } catch (InterruptedException e) {\r\n                throw new RuntimeException(e);\r\n            }\r\n        }\r\n\r\n\r\n\r\n    }\r\n\r\n    @Override\r\n    public void sendDataToAllClients(Packet packet) {\r\n\r\n\r\n    }\r\n\r\n    @Override\r\n    public void update(Isten isten, double deltaTime) {\r\n\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/networking/MapHandler.java b/src/main/java/org/networking/MapHandler.java
--- a/src/main/java/org/networking/MapHandler.java	(revision 9958912f55a80c03811a2b00d7463850b80669b5)
+++ b/src/main/java/org/networking/MapHandler.java	(date 1714666021072)
@@ -34,7 +34,7 @@
                 server.sendData(packet.getData(), client.ipAddress, client.port);
             }
             try {
-                Thread.sleep(15);
+                Thread.sleep(20);
             } catch (InterruptedException e) {
                 throw new RuntimeException(e);
             }
@@ -72,4 +72,5 @@
     public void update(Isten isten, double deltaTime) {
 
     }
+
 }
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"AutoImportSettings\">\r\n    <option name=\"autoReloadType\" value=\"SELECTIVE\" />\r\n  </component>\r\n  <component name=\"ChangeListManager\">\r\n    <list default=\"true\" id=\"3506ab6d-0407-47f2-a7e8-78ebc867e577\" name=\"Changes\" comment=\"\">\r\n      <change afterPath=\"$PROJECT_DIR$/test/MultiplayerTester.java\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/.idea/misc.xml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/misc.xml\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/.idea/workspace.xml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/workspace.xml\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/src/main/java/org/game/Isten.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/main/java/org/game/Isten.java\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/src/main/java/org/game/UI/Minimap.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/main/java/org/game/UI/Minimap.java\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/src/main/java/org/game/physics/PhysicsEngine.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/main/java/org/game/physics/PhysicsEngine.java\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/src/main/java/org/networking/GameClient.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/main/java/org/networking/GameClient.java\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/src/main/java/org/networking/HandlerManager.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/main/java/org/networking/HandlerManager.java\" afterDir=\"false\" />\r\n    </list>\r\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\r\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\r\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\r\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\r\n  </component>\r\n  <component name=\"ExternalProjectsData\">\r\n    <projectState path=\"$PROJECT_DIR$\">\r\n      <ProjectState />\r\n    </projectState>\r\n  </component>\r\n  <component name=\"ExternalProjectsManager\">\r\n    <system id=\"GRADLE\">\r\n      <state>\r\n        <task path=\"$PROJECT_DIR$\">\r\n          <activation />\r\n        </task>\r\n        <projects_view />\r\n      </state>\r\n    </system>\r\n  </component>\r\n  <component name=\"FileTemplateManagerImpl\">\r\n    <option name=\"RECENT_TEMPLATES\">\r\n      <list>\r\n        <option value=\"Class\" />\r\n      </list>\r\n    </option>\r\n  </component>\r\n  <component name=\"Git.Settings\">\r\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\r\n  </component>\r\n  <component name=\"MarkdownSettingsMigration\">\r\n    <option name=\"stateVersion\" value=\"1\" />\r\n  </component>\r\n  <component name=\"ProjectColorInfo\">{\r\n  &quot;associatedIndex&quot;: 8\r\n}</component>\r\n  <component name=\"ProjectId\" id=\"2frbzqFlsraLkUjUjuqMYUBt0BV\" />\r\n  <component name=\"ProjectViewState\">\r\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\r\n    <option name=\"showLibraryContents\" value=\"true\" />\r\n  </component>\r\n  <component name=\"PropertiesComponent\">{\r\n  &quot;keyToString&quot;: {\r\n    &quot;Downloaded.Files.Path.Enabled&quot;: &quot;false&quot;,\r\n    &quot;Gradle.MultiplayerTester.executor&quot;: &quot;Run&quot;,\r\n    &quot;Gradle.MultiplayerTester.testPacket01.executor&quot;: &quot;Run&quot;,\r\n    &quot;Gradle.MultiplayerTester.testPacket02Constructor.executor&quot;: &quot;Run&quot;,\r\n    &quot;Gradle.iLaby [run].executor&quot;: &quot;Run&quot;,\r\n    &quot;Repository.Attach.Annotations&quot;: &quot;false&quot;,\r\n    &quot;Repository.Attach.JavaDocs&quot;: &quot;false&quot;,\r\n    &quot;Repository.Attach.Sources&quot;: &quot;false&quot;,\r\n    &quot;RunOnceActivity.OpenProjectViewOnStart&quot;: &quot;true&quot;,\r\n    &quot;RunOnceActivity.ShowReadmeOnStart&quot;: &quot;true&quot;,\r\n    &quot;WebServerToolWindowFactoryState&quot;: &quot;false&quot;,\r\n    &quot;git-widget-placeholder&quot;: &quot;main&quot;,\r\n    &quot;kotlin-language-version-configured&quot;: &quot;true&quot;,\r\n    &quot;last_opened_file_path&quot;: &quot;C:/Users/kuruc/Downloads/junit-4.13.2.jar&quot;,\r\n    &quot;node.js.detected.package.eslint&quot;: &quot;true&quot;,\r\n    &quot;node.js.detected.package.tslint&quot;: &quot;true&quot;,\r\n    &quot;node.js.selected.package.eslint&quot;: &quot;(autodetect)&quot;,\r\n    &quot;node.js.selected.package.tslint&quot;: &quot;(autodetect)&quot;,\r\n    &quot;project.structure.last.edited&quot;: &quot;Modules&quot;,\r\n    &quot;project.structure.proportion&quot;: &quot;0.15&quot;,\r\n    &quot;project.structure.side.proportion&quot;: &quot;0.2&quot;,\r\n    &quot;settings.editor.selected.configurable&quot;: &quot;reference.settingsdialog.project.gradle&quot;,\r\n    &quot;vue.rearranger.settings.migration&quot;: &quot;true&quot;\r\n  }\r\n}</component>\r\n  <component name=\"RunManager\" selected=\"Gradle.iLaby [run]\">\r\n    <configuration name=\"MultiplayerTester\" type=\"GradleRunConfiguration\" factoryName=\"Gradle\" temporary=\"true\">\r\n      <ExternalSystemSettings>\r\n        <option name=\"executionName\" />\r\n        <option name=\"externalProjectPath\" value=\"$PROJECT_DIR$\" />\r\n        <option name=\"externalSystemIdString\" value=\"GRADLE\" />\r\n        <option name=\"scriptParameters\" value=\"\" />\r\n        <option name=\"taskDescriptions\">\r\n          <list />\r\n        </option>\r\n        <option name=\"taskNames\">\r\n          <list>\r\n            <option value=\":test\" />\r\n            <option value=\"--tests\" />\r\n            <option value=\"&quot;MultiplayerTester&quot;\" />\r\n          </list>\r\n        </option>\r\n        <option name=\"vmOptions\" />\r\n      </ExternalSystemSettings>\r\n      <ExternalSystemDebugServerProcess>false</ExternalSystemDebugServerProcess>\r\n      <ExternalSystemReattachDebugProcess>true</ExternalSystemReattachDebugProcess>\r\n      <DebugAllEnabled>false</DebugAllEnabled>\r\n      <RunAsTest>true</RunAsTest>\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration name=\"MultiplayerTester.testPacket01\" type=\"GradleRunConfiguration\" factoryName=\"Gradle\" temporary=\"true\">\r\n      <ExternalSystemSettings>\r\n        <option name=\"executionName\" />\r\n        <option name=\"externalProjectPath\" value=\"$PROJECT_DIR$\" />\r\n        <option name=\"externalSystemIdString\" value=\"GRADLE\" />\r\n        <option name=\"scriptParameters\" value=\"\" />\r\n        <option name=\"taskDescriptions\">\r\n          <list />\r\n        </option>\r\n        <option name=\"taskNames\">\r\n          <list>\r\n            <option value=\":test\" />\r\n            <option value=\"--tests\" />\r\n            <option value=\"&quot;MultiplayerTester.testPacket01&quot;\" />\r\n          </list>\r\n        </option>\r\n        <option name=\"vmOptions\" />\r\n      </ExternalSystemSettings>\r\n      <ExternalSystemDebugServerProcess>false</ExternalSystemDebugServerProcess>\r\n      <ExternalSystemReattachDebugProcess>true</ExternalSystemReattachDebugProcess>\r\n      <DebugAllEnabled>false</DebugAllEnabled>\r\n      <RunAsTest>true</RunAsTest>\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration name=\"MultiplayerTester.testPacket02Constructor\" type=\"GradleRunConfiguration\" factoryName=\"Gradle\" temporary=\"true\">\r\n      <ExternalSystemSettings>\r\n        <option name=\"executionName\" />\r\n        <option name=\"externalProjectPath\" value=\"$PROJECT_DIR$\" />\r\n        <option name=\"externalSystemIdString\" value=\"GRADLE\" />\r\n        <option name=\"scriptParameters\" value=\"\" />\r\n        <option name=\"taskDescriptions\">\r\n          <list />\r\n        </option>\r\n        <option name=\"taskNames\">\r\n          <list>\r\n            <option value=\":test\" />\r\n            <option value=\"--tests\" />\r\n            <option value=\"&quot;MultiplayerTester.testPacket02Constructor&quot;\" />\r\n          </list>\r\n        </option>\r\n        <option name=\"vmOptions\" />\r\n      </ExternalSystemSettings>\r\n      <ExternalSystemDebugServerProcess>false</ExternalSystemDebugServerProcess>\r\n      <ExternalSystemReattachDebugProcess>true</ExternalSystemReattachDebugProcess>\r\n      <DebugAllEnabled>false</DebugAllEnabled>\r\n      <RunAsTest>true</RunAsTest>\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration name=\"iLaby [run]\" type=\"GradleRunConfiguration\" factoryName=\"Gradle\" singleton=\"false\" nameIsGenerated=\"true\">\r\n      <ExternalSystemSettings>\r\n        <option name=\"executionName\" />\r\n        <option name=\"externalProjectPath\" value=\"$PROJECT_DIR$\" />\r\n        <option name=\"externalSystemIdString\" value=\"GRADLE\" />\r\n        <option name=\"scriptParameters\" value=\"\" />\r\n        <option name=\"taskDescriptions\">\r\n          <list />\r\n        </option>\r\n        <option name=\"taskNames\">\r\n          <list>\r\n            <option value=\"run\" />\r\n          </list>\r\n        </option>\r\n        <option name=\"vmOptions\" />\r\n      </ExternalSystemSettings>\r\n      <ExternalSystemDebugServerProcess>true</ExternalSystemDebugServerProcess>\r\n      <ExternalSystemReattachDebugProcess>true</ExternalSystemReattachDebugProcess>\r\n      <DebugAllEnabled>false</DebugAllEnabled>\r\n      <RunAsTest>false</RunAsTest>\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <list>\r\n      <item itemvalue=\"Gradle.iLaby [run]\" />\r\n      <item itemvalue=\"Gradle.MultiplayerTester\" />\r\n      <item itemvalue=\"Gradle.MultiplayerTester.testPacket02Constructor\" />\r\n      <item itemvalue=\"Gradle.MultiplayerTester.testPacket01\" />\r\n    </list>\r\n    <recent_temporary>\r\n      <list>\r\n        <item itemvalue=\"Gradle.MultiplayerTester\" />\r\n        <item itemvalue=\"Gradle.MultiplayerTester.testPacket02Constructor\" />\r\n        <item itemvalue=\"Gradle.MultiplayerTester.testPacket01\" />\r\n      </list>\r\n    </recent_temporary>\r\n  </component>\r\n  <component name=\"SharedIndexes\">\r\n    <attachedChunks>\r\n      <set>\r\n        <option value=\"jdk-18.0.2-corretto-18.0.2-4caba194b151-5720f15e\" />\r\n        <option value=\"jdk-21.0.2-openjdk-21.0.2-4caba194b151-4f524021\" />\r\n      </set>\r\n    </attachedChunks>\r\n  </component>\r\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"application-level\" UseSingleDictionary=\"true\" transferred=\"true\" />\r\n  <component name=\"TaskManager\">\r\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\r\n      <changelist id=\"3506ab6d-0407-47f2-a7e8-78ebc867e577\" name=\"Changes\" comment=\"\" />\r\n      <created>1714562409879</created>\r\n      <option name=\"number\" value=\"Default\" />\r\n      <option name=\"presentableId\" value=\"Default\" />\r\n      <updated>1714562409879</updated>\r\n      <workItem from=\"1714562410886\" duration=\"908000\" />\r\n    </task>\r\n    <servers />\r\n  </component>\r\n  <component name=\"TypeScriptGeneratedFilesManager\">\r\n    <option name=\"version\" value=\"3\" />\r\n  </component>\r\n  <component name=\"Vcs.Log.Tabs.Properties\">\r\n    <option name=\"TAB_STATES\">\r\n      <map>\r\n        <entry key=\"MAIN\">\r\n          <value>\r\n            <State />\r\n          </value>\r\n        </entry>\r\n      </map>\r\n    </option>\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	(revision 9958912f55a80c03811a2b00d7463850b80669b5)
+++ b/.idea/workspace.xml	(date 1714731640626)
@@ -5,14 +5,11 @@
   </component>
   <component name="ChangeListManager">
     <list default="true" id="3506ab6d-0407-47f2-a7e8-78ebc867e577" name="Changes" comment="">
-      <change afterPath="$PROJECT_DIR$/test/MultiplayerTester.java" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/.idea/misc.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/misc.xml" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/src/main/java/org/networking/Packet22EdgePieceChanged.java" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/src/main/java/org/game/Isten.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/org/game/Isten.java" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/src/main/java/org/game/UI/Minimap.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/org/game/UI/Minimap.java" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/src/main/java/org/game/physics/PhysicsEngine.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/org/game/physics/PhysicsEngine.java" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/src/main/java/org/networking/GameClient.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/org/networking/GameClient.java" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/src/main/java/org/networking/HandlerManager.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/org/networking/HandlerManager.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/main/java/org/game/Map/Map.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/org/game/Map/Map.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/main/java/org/networking/MapHandler.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/org/networking/MapHandler.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/main/java/org/networking/Packet.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/org/networking/Packet.java" afterDir="false" />
     </list>
     <option name="SHOW_DIALOG" value="false" />
     <option name="HIGHLIGHT_CONFLICTS" value="true" />
Index: src/main/java/org/networking/Packet22EdgePieceChanged.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/networking/Packet22EdgePieceChanged.java b/src/main/java/org/networking/Packet22EdgePieceChanged.java
new file mode 100644
--- /dev/null	(date 1714732588054)
+++ b/src/main/java/org/networking/Packet22EdgePieceChanged.java	(date 1714732588054)
@@ -0,0 +1,44 @@
+package main.java.org.networking;
+
+
+import main.java.org.linalg.Vec2;
+
+public class Packet22EdgePieceChanged extends Packet {
+
+    private float x, y;
+
+    public Packet22EdgePieceChanged(byte[] data) {
+        super(22);
+        String[] dataArray = readData(data).split(",");
+        this.x = Float.parseFloat(dataArray[0]);
+        this.y = Float.parseFloat(dataArray[1]);
+    }
+
+    public Packet22EdgePieceChanged(float x, float y) {
+        super(22);
+        this.x = x;
+        this.y = y;
+    }
+
+    public void writeData(GameClient client) {
+        client.sendData(getData());
+    }
+
+    public void writeData(GameServer server) {
+        server.sendDataToAllClients(getData());
+    }
+
+    public byte[] getData() {
+        return ("22" + x + "," + y).getBytes();
+    }
+
+    public float getX() {
+        return x;
+    }
+
+    public float getY() {
+        return y;
+    }
+
+}
+
