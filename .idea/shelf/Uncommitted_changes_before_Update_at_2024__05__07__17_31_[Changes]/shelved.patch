Index: src/main/java/org/networking/MapHandler.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package main.java.org.networking;\r\n\r\nimport main.java.org.game.Isten;\r\nimport main.java.org.game.Map.*;\r\nimport main.java.org.linalg.Vec2;\r\n\r\nimport java.awt.event.KeyEvent;\r\nimport java.util.Collections;\r\nimport java.util.List;\r\n\r\npublic class MapHandler extends ServerSideHandler {\r\n\r\n    int sec = 0;\r\n    boolean stop = true;\r\n    double delta = 0;\r\n\r\n\r\n    @Override\r\n    public void create(GameServer server) {\r\n        this.server = server;\r\n        this.isten = server.isten;\r\n        isten.getMap().init(isten);\r\n        isInitialized = true;\r\n        sendDataToWaitingClients();\r\n    }\r\n\r\n    @Override\r\n    public void sendDataToClient(PlayerMP client) {\r\n\r\n        if(!isInitialized) {\r\n            if(!waitingClients.contains(client)) waitingClients.add(client);\r\n            return;\r\n        }\r\n\r\n        Map map = isten.getMap();\r\n        for(int i = 0; i < map.getMapRowSize(); i++) {\r\n            for(int j = 0; j < map.getMapColumnSize(); j++) {\r\n                Vec2 pos = map.getUnitRooms()[i][j].getPosition();\r\n                int type = map.getUnitRooms()[i][j].getOwnerRoom().getRoomType().ordinal();\r\n                Packet04UnitRoom packet = new Packet04UnitRoom(pos.x, pos.y, type);\r\n                server.sendData(packet.getData(), client.ipAddress, client.port);\r\n            }\r\n        }\r\n\r\n\r\n        //\r\n        for(int i = 0; i < map.getEdgeManager().getRoomEdges().size(); i++) {\r\n            EdgeBetweenRooms re = map.getEdgeManager().getRoomEdges().get(i);\r\n            for (int j = 0; j < re.getWalls().size(); j++) {\r\n                EdgePiece edgePiece = re.getWalls().get(j);\r\n                Vec2 pos = edgePiece.getImage().getPosition();\r\n                Vec2 scale = edgePiece.getImage().getScale();\r\n                Packet20Wall packet = new Packet20Wall(pos.x, pos.y, scale.x, scale.y, edgePiece.isDoor());\r\n                server.sendData(packet.getData(), client.ipAddress, client.port);\r\n            }\r\n            try {\r\n                Thread.sleep(5);\r\n            } catch (InterruptedException e) {\r\n                throw new RuntimeException(e);\r\n            }\r\n        }\r\n\r\n\r\n\r\n    }\r\n\r\n    @Override\r\n    public void sendDataToAllClients(Packet packet) {\r\n        packet.writeData(server);\r\n    }\r\n\r\n    @Override\r\n    public void update(Isten isten, double deltaTime) {\r\n        //for testing\r\n        if(isten.getInputHandler().isKeyReleased(KeyEvent.VK_SPACE)){\r\n            stop = !stop;\r\n            //if(stop) printMap();\r\n        }\r\n\r\n        if(!stop) {\r\n            delta += deltaTime;\r\n            if (delta > 1) {\r\n                //TESTCASE 1:::\r\n\r\n                if(sec %3==0){\r\n                    Vec2 pos = isten.getMap().addDoorToEdgeWithoutDoor(isten);\r\n                    handleAddOrDeleteDoor(pos, true);\r\n                    //System.out.println(\"ajtoaddolas tortent\");\r\n                }\r\n                else{\r\n                    Vec2 pos = isten.getMap().TakeOutDoor(isten,true);\r\n                    if(pos.x != -1 && pos.y != -1) {\r\n                        handleAddOrDeleteDoor(pos, false);\r\n                        //stop = true;\r\n                        //System.out.println(\"edgeNum: \"+isten.getMap().getEdgeManager().getRoomEdges().size());\r\n                        //System.out.println(\"doorNum: \"+isten.getMap().getEdgeManager().getDoorNum());\r\n                        //System.out.println(\"ajtokivetel tortent\");\r\n                    }\r\n\r\n\r\n                }\r\n                //TESTCASE 2:\r\n                if (sec % 4 == 0) {\r\n                    Collections.shuffle(isten.getMap().getRooms());\r\n                    Room r1 = isten.getMap().getRooms().get(0);\r\n                    Room r2 = isten.getMap().getRooms().get(0).getPhysicallyAdjacentRooms().get(0);\r\n                    handleUnitRoomChange(r2.getUnitRooms(), r1.getRoomType().ordinal());\r\n                    handleWallDeletion(isten.getMap().getEdgeManager().getEdgeBetweenRooms(r1, r2));\r\n                    isten.getMap().mergeRooms(r1, r2, isten);\r\n                    handleRoomEdges(r1);\r\n\r\n                    //System.out.println(\"r1 adjacentrooms Number: \" + rooms.get(0).getPhysicallyAdjacentRooms().size());\r\n\r\n                }\r\n                //TESTCASE 3:\r\n\r\n                if((sec+2)%4==0) {\r\n                    for (Room splittable : isten.getMap().getRooms()) {\r\n                        int newID;\r\n                        if ((newID = isten.getMap().splitRooms(splittable, isten)) != -1) {\r\n\r\n                            for(Room room: isten.getMap().getRooms()) {\r\n                                if(room.getID() == newID) {\r\n                                    handleUnitRoomChange(room.getUnitRooms(), room.getRoomType().ordinal());\r\n                                    handleWallAddition(isten.getMap().getEdgeManager().getEdgeBetweenRooms(splittable, room));\r\n                                    handleRoomEdges(room);\r\n                                    handleRoomEdges(splittable);\r\n                                    break;\r\n                                }\r\n                            }\r\n                            //System.out.println(\"sikerult a split\");\r\n                            //System.out.println(splittable.getID() + \" adjacentrooms: \" + splittable.getPhysicallyAdjacentRooms().size());\r\n                            //System.out.println(splittable.getID() + \" Dooradjacentrooms: \" + splittable.getDoorAdjacentRooms().size());\r\n                            //stop = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n\r\n\r\n                sec++;\r\n                delta = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    private void handleAddOrDeleteDoor(Vec2 pos, boolean isDoor) {\r\n        Packet22EdgePieceChanged packet = new Packet22EdgePieceChanged(pos.x,\r\n                pos.y,\r\n                isDoor);\r\n        sendDataToAllClients(packet);\r\n        try {\r\n            Thread.sleep(5);\r\n        } catch (InterruptedException e) {\r\n            throw new RuntimeException(e);\r\n        }\r\n    }\r\n\r\n    public void handleRoomEdges(Room room) {\r\n        for(EdgeBetweenRooms edgeBetweenRooms: isten.getMap().getEdgeManager().getAllEdgeForARoom(room)) {\r\n            for(EdgePiece edgePiece: edgeBetweenRooms.getWalls()) {\r\n                Packet22EdgePieceChanged packet = new Packet22EdgePieceChanged(edgePiece.getPosition().x,\r\n                        edgePiece.getPosition().y,\r\n                        edgePiece.isDoor());\r\n                sendDataToAllClients(packet);\r\n                try {\r\n                    Thread.sleep(5);\r\n                } catch (InterruptedException e) {\r\n                    throw new RuntimeException(e);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public void handleWallAddition(EdgeBetweenRooms edge) {\r\n        for(EdgePiece edgePiece: edge.getWalls()) {\r\n            Packet20Wall packet = new Packet20Wall(edgePiece.getPosition().x, edgePiece.getPosition().y,\r\n                    edgePiece.getCollider().getScale().x, edgePiece.getCollider().getScale().y,\r\n                    edgePiece.isDoor());\r\n            sendDataToAllClients(packet);\r\n            try {\r\n                Thread.sleep(5);\r\n            } catch (InterruptedException e) {\r\n                throw new RuntimeException(e);\r\n            }\r\n        }\r\n    }\r\n    public void handleWallDeletion(EdgeBetweenRooms edge) {\r\n        for(EdgePiece edgePiece: edge.getWalls()) {\r\n            Packet23WallDelete packet = new Packet23WallDelete(edgePiece.getPosition().x,\r\n                    edgePiece.getPosition().y);\r\n            sendDataToAllClients(packet);\r\n            try {\r\n                Thread.sleep(5);\r\n            } catch (InterruptedException e) {\r\n                throw new RuntimeException(e);\r\n            }\r\n        }\r\n    }\r\n\r\n    public void handleUnitRoomChange(List<UnitRoom> unitRooms, int type) {\r\n\r\n        for(UnitRoom unitRoom: unitRooms) {\r\n            Packet04UnitRoom packet = new Packet04UnitRoom(unitRoom.getPosition().x,\r\n                    unitRoom.getPosition().y, type);\r\n            sendDataToAllClients(packet);\r\n            try {\r\n                Thread.sleep(5);\r\n            } catch (InterruptedException e) {\r\n                throw new RuntimeException(e);\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/networking/MapHandler.java b/src/main/java/org/networking/MapHandler.java
--- a/src/main/java/org/networking/MapHandler.java	(revision 7b1e06b61fea754fde53334cdd606eb9c3e7c55a)
+++ b/src/main/java/org/networking/MapHandler.java	(date 1714850419679)
@@ -82,7 +82,7 @@
             if (delta > 1) {
                 //TESTCASE 1:::
 
-                if(sec %3==0){
+               if(false){
                     Vec2 pos = isten.getMap().addDoorToEdgeWithoutDoor(isten);
                     handleAddOrDeleteDoor(pos, true);
                     //System.out.println("ajtoaddolas tortent");
@@ -96,11 +96,9 @@
                         //System.out.println("doorNum: "+isten.getMap().getEdgeManager().getDoorNum());
                         //System.out.println("ajtokivetel tortent");
                     }
-
-
                 }
                 //TESTCASE 2:
-                if (sec % 4 == 0) {
+               /* if (sec % 4 == 0) {
                     Collections.shuffle(isten.getMap().getRooms());
                     Room r1 = isten.getMap().getRooms().get(0);
                     Room r2 = isten.getMap().getRooms().get(0).getPhysicallyAdjacentRooms().get(0);
@@ -135,7 +133,7 @@
                             break;
                         }
                     }
-                }
+                }*/
 
 
                 sec++;
Index: src/main/java/org/game/Map/Map.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package main.java.org.game.Map;\r\n\r\nimport main.java.org.game.Isten;\r\nimport main.java.org.game.updatable.Updatable;\r\nimport main.java.org.linalg.Vec2;\r\n\r\nimport java.util.*;\r\n\r\n\r\npublic class Map extends Updatable {\r\n    private Mapgenerator mapgenerator;\r\n    ArrayList<Room> rooms;\r\n    private UnitRoom[][] unitRooms;\r\n    private final int mapRowSize;\r\n    private final int mapColumnSize;\r\n    private EdgeManager edgeManager;\r\n    private final int minRoomSize;\r\n    private  boolean isGenerated = false;\r\n\r\n    public Map(Isten isten, int rowNumber, int columnNumber, int minRoomSize){\r\n        this.mapRowSize = rowNumber;\r\n        this.mapColumnSize = columnNumber;\r\n        this.minRoomSize = minRoomSize;\r\n        //unitrooms is set in the generator --> onstart\r\n        this.rooms = new ArrayList<>();\r\n        this.edgeManager = new EdgeManager(isten);\r\n        initUnitRooms();\r\n    }\r\n    public void init(Isten isten) {\r\n        isten.addUpdatable(edgeManager);\r\n        this.mapgenerator = new Mapgenerator(this, isten);\r\n        isGenerated = true;\r\n        mapgenerator.generate(minRoomSize);\r\n    }\r\n    @Override\r\n    public void onStart(Isten isten) {\r\n        Mapgenerator mg = new Mapgenerator(this,isten);\r\n        mg.generateSideWalls();\r\n    }\r\n\r\n    //for testing\r\n\r\n    @Override\r\n    public void onUpdate(Isten isten, double deltaTime) {\r\n\r\n    }\r\n\r\n    @Override\r\n    public void onDestroy() {\r\n\r\n    }\r\n    public void initUnitRooms(){\r\n        unitRooms = new UnitRoom[mapRowSize][mapColumnSize];\r\n        for(int i = 0; i<mapRowSize;i++)\r\n        {\r\n            for(int j = 0;j<mapColumnSize;j++)\r\n            {\r\n                unitRooms[i][j] = new UnitRoom(new Vec2(j,i));\r\n            }\r\n        }\r\n    }\r\n\r\n    //a slitelesnel csak a minroomsize fele engedelyezett\r\n    public int splitRooms(Room r1, Isten isten)\r\n    {\r\n        if(r1.getUnitRooms().size() < minRoomSize) return -1;\r\n        //egyenlőre minden szoba ami splittel lesz createlve ilyen type-val rendelkezik\r\n        int newID = generateNewRoomID();\r\n        Room newRoom = new Room(newID);\r\n        ArrayList<UnitRoom> addableUnitRooms = new ArrayList<>();\r\n        int distance = 0;\r\n        ArrayList<Integer> minMaxRowColValues = r1.getMinMaxRowColValues();\r\n        int highestColIdx = minMaxRowColValues.get(0);\r\n        int lowestColIdx = minMaxRowColValues.get(1);\r\n        int highestRowIdx = minMaxRowColValues.get(2);\r\n        int lowestRowIdx = minMaxRowColValues.get(3);\r\n        //ha a szoba inkább fuggolegesen nagy, akkor a sorokat figyeljuk\r\n        if((highestRowIdx - lowestRowIdx) > (highestColIdx - lowestColIdx)) {\r\n            //int lowestRowIdx = getRoomWithLowestRowIdx(r1);\r\n            ArrayList<UnitRoom> UnitRoomsWithDistanceXFromLowestRow;\r\n            //addig, amíg az új szoba a méret fele nem lesz\r\n            while (addableUnitRooms.size() < r1.getUnitRooms().size() / 2) {\r\n                UnitRoomsWithDistanceXFromLowestRow = r1.getUnitRoomsWithXDistanceFromLowestRowIdxInOrderByColumn(lowestRowIdx, distance++); //tavolsag novelese, es igy soronkent egyesevel balrol jobbra az osszes unitroom hozzaadasa, amig kell\r\n                for (UnitRoom addableUnitRoom : UnitRoomsWithDistanceXFromLowestRow) {\r\n                    if (addableUnitRooms.size() < r1.getUnitRooms().size() / 2) {\r\n                        addableUnitRooms.add(addableUnitRoom);\r\n                    }\r\n\r\n                }\r\n            }\r\n        }else{\r\n            ArrayList<UnitRoom> UnitRoomsWithDistanceXFromLowestColumn;\r\n            while (addableUnitRooms.size() < r1.getUnitRooms().size() / 2) {\r\n                UnitRoomsWithDistanceXFromLowestColumn = r1.getUnitRoomsWithXDistanceFromLowestColumnIdxInOrderByRow(lowestColIdx, distance++); //tavolsag novelese, es igy soronkent egyesevel balrol jobbra az osszes unitroom hozzaadasa, amig kell\r\n                for (UnitRoom addableUnitRoom : UnitRoomsWithDistanceXFromLowestColumn) {\r\n                    if (addableUnitRooms.size() < r1.getUnitRooms().size() / 2) {\r\n                        addableUnitRooms.add(addableUnitRoom);\r\n                    }\r\n\r\n                }\r\n            }\r\n        }\r\n        // a fenti ket ag helyett meg lehetne csinalni a max ertekekkel is, ha nem lesz coherens az eredmeny\r\n        ArrayList<UnitRoom> oldRoomWithoutNewRoom = getDifference(r1.getUnitRooms(),addableUnitRooms);\r\n        //ellenorzom, hogy osszefuggoek lennének-e: ha igen:\r\n        //id mindegy micsoda, itt igazabol nem hasznalom\r\n        if( kruskalForCheckingIfGraphIsCoherent(oldRoomWithoutNewRoom) && kruskalForCheckingIfGraphIsCoherent(addableUnitRooms)) {\r\n            // removeoljuk a szomszedos roomok szomszedossagi listaibol a szobat fizikalisan, es a func vegen hozzaadjuk a ket szetvalasztott szoba egyiket/mindekettot\r\n            for(Room physicalNeighbourRoom : r1.getPhysicallyAdjacentRooms()){\r\n                physicalNeighbourRoom.getPhysicallyAdjacentRooms().remove(r1);\r\n            }\r\n            //itt pedig az ajtos szomszeddossagi listabol is removeoljuk\r\n            for(Room byDoorNeighbourRoom: r1.getDoorAdjacentRooms()){\r\n                byDoorNeighbourRoom.getDoorAdjacentRooms().remove(r1);\r\n            }\r\n            for (UnitRoom addUnitRoomToNewRoom : addableUnitRooms) {\r\n                //kivesszük az előző szobából a  unitroomot\r\n                r1.getUnitRooms().remove(addUnitRoomToNewRoom);\r\n               // addUnitRoomToNewRoom.getOwnerRoom().getUnitRooms().remove(addUnitRoomToNewRoom);\r\n                addUnitRoomToNewRoom.setOwnerRoom(newRoom);\r\n                //hozzáadjuk az új szobához a unitroomot\r\n                newRoom.getUnitRooms().add(addUnitRoomToNewRoom);\r\n            }\r\n            rooms.add(newRoom);\r\n            newRoom.setPhysicallyAdjacentRooms();\r\n            newRoom.getPhysicallyAdjacentRooms().remove(r1);\r\n            r1.setPhysicallyAdjacentRooms();\r\n\r\n            //set the images\r\n            /*\r\n            for(UnitRoom unitRoom : newRoom.getUnitRooms()) {\r\n                unitRoom.addRightImage(isten);\r\n            }\r\n             */\r\n            //update nodeRooms and generate the new ones\r\n            //also updates the images and colliders\r\n            //TODO\r\n            // the new edge has a door if it is possible\r\n            // if door is not added, check if the map is koherent\r\n            edgeManager.updateEdgesAfterSplit(r1, newRoom);\r\n\r\n\r\n            //a splitelt szoba es az uj szoba kozott ketszer lesz??\r\n            setByDoorAdjacentRooms(newRoom);\r\n            //hogy csak egyszer addoljuk hozza, de csak ket iranyu ajtoknal van igy\r\n            newRoom.getDoorAdjacentRooms().remove(r1);\r\n            setByDoorAdjacentRooms(r1);\r\n            return newID;\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    public void setByDoorAdjacentRooms(Room r){\r\n        r.getDoorAdjacentRooms().clear();\r\n        //tesztelesre meg jo lehet\r\n        //ArrayList<EdgeBetweenRooms> edgesOfRoom = edgeManager.getAllEdgeForARoom(r1);\r\n        //az ajtoban tarolhato, hogy egyiranyu-e, meg ezt nem tudjuk fixre\r\n        for(Room adjacentRoom : r.getPhysicallyAdjacentRooms()){\r\n            if(edgeManager.getEdgeBetweenRooms(r,adjacentRoom).hasDoor())\r\n            {\r\n                //az add door miatt mar benne lehet\r\n                r.getDoorAdjacentRooms().add(adjacentRoom);\r\n                adjacentRoom.getDoorAdjacentRooms().add(r);\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n    }\r\n\r\n    public static ArrayList<UnitRoom> getDifference(ArrayList<UnitRoom> u1, ArrayList<UnitRoom> u2)\r\n    {\r\n        ArrayList<UnitRoom> difference = new ArrayList<>();\r\n        for (UnitRoom element : u1) {\r\n            if (!u2.contains(element)) {\r\n                difference.add(element);\r\n            }\r\n        }\r\n        return difference;\r\n    }\r\n    //elozo fv, vagyis wouldRoomBeCoherent atirasa generikusra, es akkor egy wouldMapBeCoherent fv-t is helyettesit.\r\n    public <T extends Graph> boolean kruskalForCheckingIfGraphIsCoherent(ArrayList<T> newCoherentElements)\r\n    {\r\n        T starterRoom = newCoherentElements.get(0);\r\n        ArrayList<T> coherentGraph = new ArrayList<>();\r\n        coherentGraph.add(starterRoom);\r\n        for(int i = 0;i<newCoherentElements.size();i++){\r\n            for(T ElementToBeAddedToGraph : newCoherentElements){\r\n                 /*ha a size i-vel egyenlő, vagy kisebb nála, akkor tudjuk, hogy nem alkotnak összefüggő gráfot a UnitRoomok a Roomban,\r\n                    mert különben az előző körhöz képest legalább 1-et fel kellett volna tuidjak venni, vagy pedig már előtte többet kellett volna tudjak felvenni,\r\n                    rekurzív gondolat, mukodik (remelem)*/\r\n                if(coherentGraph.size()> i)\r\n                {\r\n                    if (!ElementToBeAddedToGraph.equals(coherentGraph.get(i))\r\n                            && !coherentGraph.contains(ElementToBeAddedToGraph)\r\n                            && ElementToBeAddedToGraph.isAdjacent(coherentGraph.get(i)))\r\n                    {\r\n                        coherentGraph.add(ElementToBeAddedToGraph);\r\n\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        //mivel minden indexen vegig tudtunk menni ezert tudunk truet returnolni, azert biztonsag kedveert meg egy kontrollt bennhagyok\r\n        if(coherentGraph.size() == newCoherentElements.size()) return true;\r\n            //hogyha nem egyenlok akkor false menjen ki, bar egyenloknek kene lenniuk\r\n        else return false;\r\n    }\r\n\r\n\r\n    //BFS, ellenorzi hogy a graf osszefuggo-e, iranyitott graf eseten is\r\n    //meg lehetne csinalni T parameterrel is, de akkor kellene egy getAdjacentrooms fv az interfaceba\r\n    private  boolean isGraphKoherent(ArrayList<Room> graphNodes){\r\n        Queue<Room> queue = new LinkedList<>();\r\n        ArrayList<Room> visited = new ArrayList<>();\r\n        //vegig kell menni az osszes csucsbol indulva\r\n        for(Room startNode : graphNodes){\r\n            queue.add(startNode);\r\n            visited.add(startNode);\r\n            while(!queue.isEmpty()){\r\n                Room current = queue.poll();\r\n                for(Room adjacent :current.getDoorAdjacentRooms()){\r\n                    if(!visited.contains(adjacent)){\r\n                        queue.add(adjacent);\r\n                        visited.add(adjacent);\r\n                    }\r\n                }\r\n            }\r\n            if(graphNodes.size() != visited.size()) return false;\r\n            visited.clear();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    //function hogy megtalaljam a legkisebb sorindexet a tombben, viszonyitasi parameter lesz.\r\n    // splitRooms func-on belül használva\r\n    //ez a fv athelyezve a room osztalyba es egy kicsit kiegeszitve az optimalisabb split miatt\r\n    private int getRoomWithLowestRowIdx(Room r1) {\r\n        UnitRoom min = unitRooms[mapRowSize-1][mapColumnSize-1];\r\n        for(UnitRoom unitRoom : r1.getUnitRooms())\r\n        {\r\n            if(unitRoom.getRowNum()<min.getRowNum())\r\n            {\r\n                min = unitRoom;\r\n            }\r\n        }\r\n        return min.getRowNum();\r\n    }\r\n\r\n\r\n    //ez a fv a mapgenerátorban is hasonlóan szerepel (colliderek és imagek nélkül)\r\n    public void mergeRooms(Room r1, Room r2, Isten isten) {\r\n        if(!r1.isPhysicallyAdjacent(r2) || r1.getID() == r2.getID()){\r\n            System.err.println(\"cant be merged\");\r\n            return;\r\n        }\r\n        System.out.println(r2.getID() + \"(r2) is merged to (r1)\" + r1.getID());\r\n        //remove r2 and keep r1;\r\n\r\n        edgeManager.deleteEdge(r1,r2);\r\n        edgeManager.updateEdgesAfterMerge(r1,r2);\r\n\r\n        for(UnitRoom unitRoom : r2.getUnitRooms()){\r\n            //r1.getUnitRooms().add(unitroom);\r\n            unitRoom.setOwnerRoom(r1);\r\n\r\n            //setting the new images of the deleted room\r\n            //this method cares about the renderable items too\r\n            //unitRoom.addRightImage(isten);\r\n        }\r\n\r\n        r1.getUnitRooms().addAll(r2.getUnitRooms()); //insted of this: r1.getUnitRooms().add(unitroom);\r\n\r\n        //kiszedjuk a torolt szobat mindket szomszedossagi listabol\r\n        r1.getPhysicallyAdjacentRooms().remove(r2);\r\n        r1.getDoorAdjacentRooms().remove(r2);\r\n\r\n        //vagy ez kell ide, vagy a feltetel, de igazabol mindegy, hadd maradjon  mind2,de a feltetel jobb,\r\n        // mert a kikommentelt kodresz egyel lejjebb lehet errort dobna\r\n        r2.getDoorAdjacentRooms().remove(r1);\r\n        r2.getPhysicallyAdjacentRooms().remove(r1);\r\n        //vegigiteralunk az r2 fizikalis szomszedossagi listajan\r\n        for(Room adj : r2.getPhysicallyAdjacentRooms()){\r\n            //ha r1 nem tartalmazza r2 fiz szomszedjat, akkor hozzaadjuk r1 listajahoz\r\n            if(!r1.getPhysicallyAdjacentRooms().contains(adj) ){\r\n                //System.out.println(\"adjroom added in r1: \" + adj.getID());\r\n                r1.getPhysicallyAdjacentRooms().add(adj);\r\n            }\r\n            //kivesszük magának r2 szomszédjának a fiz szomszédossági listájából r2-t\r\n            adj.getPhysicallyAdjacentRooms().remove(r2);\r\n            adj.getDoorAdjacentRooms().remove(r2);//!!!!!!!!!!!!!!!!!!!!!!!!!!!\r\n            //vegul ha r1 nem tartalmazzaa a fiz szomszedossagi listajaban r2 szomszedjat, akkor r1 szomszedjava tesszuk\r\n            if(!adj.getPhysicallyAdjacentRooms().contains(r1)) {\r\n                adj.getPhysicallyAdjacentRooms().add(r1);\r\n            }\r\n        }\r\n        //ugyanezt megcsinaljuk az ajton keresztuli szomszedossagra is.\r\n        for(Room physicallyAdjacentRoom: r1.getPhysicallyAdjacentRooms()){\r\n            if(edgeManager.getEdgeBetweenRooms(r1,physicallyAdjacentRoom).hasDoor()){\r\n                if(!r1.getDoorAdjacentRooms().contains(physicallyAdjacentRoom))\r\n                {\r\n                    r1.getDoorAdjacentRooms().add(physicallyAdjacentRoom);\r\n                }\r\n                if(!physicallyAdjacentRoom.getDoorAdjacentRooms().contains(r1))\r\n                {\r\n                    physicallyAdjacentRoom.getDoorAdjacentRooms().add(r1);\r\n                }\r\n\r\n            }\r\n        }\r\n        // a folotti implementaciot haszanljuk most, de elvileg mindketto mukodik\r\n        /*for(Room adj : r2.getDoorAdjacentRooms()){\r\n            if(!r1.getDoorAdjacentRooms().contains(adj)){\r\n                //System.out.println(\"adjroom added in r1: \" + adj.getID());\r\n                r1.getDoorAdjacentRooms().add(adj);\r\n            }\r\n            adj.getDoorAdjacentRooms().remove(r2);\r\n            if(!adj.getDoorAdjacentRooms().contains(r1)) {\r\n                adj.getDoorAdjacentRooms().add(r1);\r\n            }\r\n        }*/\r\n\r\n        //r1.setDiscovered(r2.isDiscovered());\r\n        //r1.setPlayerCount(r1.getPlayerCount() + r2.getPlayerCount());\r\n        //r1.setRoomType(r2.getRoomType());\r\n        r1.setMaxPlayerCount(r1.getMaxPlayerCount() + r2.getMaxPlayerCount());\r\n        rooms.remove(r2);\r\n    }\r\n\r\n    //merge the rooms until every room has minimumm size of the given number\r\n    private void printMap(){\r\n        for(int i = 0;i < mapRowSize;i++){ //test\r\n            for(int j = 0; j< mapColumnSize;j++){\r\n                if(unitRooms[i][j].getOwnerRoom().getID() < 10) {\r\n                    System.out.print(unitRooms[i][j].getOwnerRoom().getID() + \"     \");\r\n                }\r\n                else if(unitRooms[i][j].getOwnerRoom().getID() >= 10 && unitRooms[i][j].getOwnerRoom().getID() < 100) {\r\n                    System.out.print(unitRooms[i][j].getOwnerRoom().getID() + \"    \");\r\n                }\r\n                else if(unitRooms[i][j].getOwnerRoom().getID() >= 100) {\r\n                    System.out.print(unitRooms[i][j].getOwnerRoom().getID() + \"   \");\r\n                }\r\n            }\r\n            System.out.println();\r\n            System.out.println();\r\n        }\r\n    }\r\n    private int generateNewRoomID(){\r\n        int newID = 0;\r\n        while(true){\r\n            int roomCnt = 0;\r\n            for(Room room : rooms){\r\n                if(room.getID() == newID){\r\n                    newID++;\r\n                    break; //not found, try the next ID\r\n                }\r\n                roomCnt++;\r\n            }\r\n            if(roomCnt == rooms.size()){\r\n                return newID;\r\n            }\r\n\r\n\r\n        }\r\n    }\r\n    //egyenlore a fv-t hivom meg, és azon kívül választom meg, hogy melyik két edge között akarom a funcot meghívni, ez változhat\r\n    public Vec2 TakeOutDoor(Isten isten, boolean oneWay){\r\n\r\n        boolean alreadyOneWay = false;\r\n        // ez a visszaaddolas miatt kell, kicsit bonyi, hogy miert, trust me\r\n        boolean r2WasRemovedFromR1 = false;\r\n        boolean r1WasRemovedFromR2 = false;\r\n        Collections.shuffle(edgeManager.getRoomEdges());\r\n        //mindig nagyon ugyanonnan fog maajd ajtot kivenni\r\n        for(EdgeBetweenRooms chosenEdge : edgeManager.getRoomEdges()){\r\n\r\n            //csak akkor veszek ki ajtót, ha mindkét szobának ami között van az edge van legalább 2 szomszédja\r\n            Room r1 = chosenEdge.getNodeRooms().get(0);\r\n            Room r2 = chosenEdge.getNodeRooms().get(1);\r\n            //ha van ajtaja\r\n            if(chosenEdge.hasDoor()) {\r\n                //csak akkor, ha van legalabb 2 ajtaja mindkettonekj, egyebkent mindenkepp szar lenne\r\n                if (r1.getDoorAdjacentRooms().size() >= 2 &&\r\n                        (r2.getDoorAdjacentRooms().size() >= 2)) {\r\n                    //megnezem, hogy ha egyiranyura akarom allitani, akkor mar egyiranyu-e alapbol, mert ha igen, akkor ki lesz veve\r\n                    if( !r1.getDoorAdjacentRooms().contains(r2) || !r2.getDoorAdjacentRooms().contains(r1)) alreadyOneWay = true;\r\n                    //ha nincs benne nem kell lekezelni, max falseot dob\r\n                    if(r1.getDoorAdjacentRooms().remove(r2)) r2WasRemovedFromR1 = true;\r\n                    if(alreadyOneWay || !oneWay){\r\n                        if(r2.getDoorAdjacentRooms().remove(r1)) r1WasRemovedFromR2= true;\r\n                    }\r\n                    //megnézem, hogy osszefuggo lenne-e az uj graph\r\n                    if (isGraphKoherent(rooms)) {\r\n                        EdgeBetweenRooms edgeBeingModified = edgeManager.getEdgeBetweenRooms(r1, r2);//ez pont a chosenEdge\r\n                        ArrayList<EdgePiece> edgePieces = edgeBeingModified.getWalls();\r\n                        for (EdgePiece edgePiece : edgePieces) {\r\n                            if (edgePiece.isDoor()) {\r\n                                System.out.println(\"talatam jot\");\r\n                                //ha ezek egyike igaz, akkor szedem csak ki, és csak ilyenkor returneolok positiont -1, -1. en kivul\r\n                                if(alreadyOneWay || !oneWay){\r\n                                    edgeBeingModified.switchDoorToWall(edgePiece, isten);\r\n\r\n                                    return edgePiece.position;\r\n                                }\r\n                                //mert nem kell allitani a map kirajzolasan, az adjacencylistet nem kell updatelni (remelem)\r\n                                return new Vec2(-1,-1);\r\n                            }\r\n                        }\r\n                    }\r\n                    else\r\n                    {\r\n                        System.out.println(\"Nem lett volna koherens\");\r\n                        //igy a legegyszerubb talan\r\n                        if( r2WasRemovedFromR1) r1.getDoorAdjacentRooms().add(r2);\r\n                        if(r1WasRemovedFromR2)r2.getDoorAdjacentRooms().add(r1);\r\n                    }\r\n                }\r\n                else System.out.println(\"nem volt eleg ajto\");\r\n            }else System.out.println(\"nincs ajto itt\");\r\n        }\r\n        return new Vec2(-1,-1);\r\n    }\r\n    //fv ami az ajtok hozzaadasat valositja meg\r\n    public Vec2 addDoorToEdgeWithoutDoor(Isten isten){\r\n        //vegigiteralok az eleken\r\n        Collections.shuffle(edgeManager.getRoomEdges());\r\n        for(EdgeBetweenRooms chosenEdge: edgeManager.getRoomEdges()){\r\n            //csak olyan el erdekel, amin nincs ajto, ergo a ket szoba nem atjarhato\r\n            if(!chosenEdge.hasDoor()){\r\n                Room r1 = chosenEdge.getNodeRooms().get(0);\r\n                Room r2 = chosenEdge.getNodeRooms().get(1);\r\n                //vegigmegyek a falakon, mert elkepzelheto, hogy van olyan, amire nem illesztheto aajto\r\n                for(EdgePiece chosenPiece: chosenEdge.getWalls()){\r\n                    //ha tudok raa ajtot illeszteni, aakkor ezt megteszem\r\n                    if(chosenEdge.switchWallToDoor(chosenPiece,isten))\r\n                    {\r\n                        //frissitem a szomszedossagi listakat\r\n                        r1.getDoorAdjacentRooms().add(r2);\r\n                        r2.getDoorAdjacentRooms().add(r1);\r\n                        System.out.println(\"Ajto hozzaadva\");\r\n                        return chosenPiece.position;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        //ha nem tudtam ajtot hozzaadni, akkor teli a map\r\n        System.out.println(\"Teli a map\");\r\n        return new Vec2(-1,-1);\r\n    }\r\n\r\n\r\n    public void setRooms(ArrayList<Room> rooms) {this.rooms = rooms;}\r\n\r\n    public void setUnitRooms(UnitRoom[][] unitRooms) {\r\n        this.unitRooms = unitRooms;\r\n    }\r\n\r\n    public ArrayList<Room> getRooms() {\r\n        return rooms;\r\n    }\r\n\r\n    public UnitRoom[][] getUnitRooms() {\r\n        return unitRooms;\r\n    }\r\n\r\n    public int getMapRowSize() {\r\n        return mapRowSize;\r\n    }\r\n\r\n    public int getMapColumnSize() {\r\n        return mapColumnSize;\r\n    }\r\n    public EdgeManager getEdgeManager(){ return edgeManager;}\r\n\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/game/Map/Map.java b/src/main/java/org/game/Map/Map.java
--- a/src/main/java/org/game/Map/Map.java	(revision 7b1e06b61fea754fde53334cdd606eb9c3e7c55a)
+++ b/src/main/java/org/game/Map/Map.java	(date 1714851397002)
@@ -396,14 +396,15 @@
                         ArrayList<EdgePiece> edgePieces = edgeBeingModified.getWalls();
                         for (EdgePiece edgePiece : edgePieces) {
                             if (edgePiece.isDoor()) {
-                                System.out.println("talatam jot");
+
                                 //ha ezek egyike igaz, akkor szedem csak ki, és csak ilyenkor returneolok positiont -1, -1. en kivul
                                 if(alreadyOneWay || !oneWay){
                                     edgeBeingModified.switchDoorToWall(edgePiece, isten);
-
+                                    System.out.println("kiszedek egy ajtot");
                                     return edgePiece.position;
                                 }
                                 //mert nem kell allitani a map kirajzolasan, az adjacencylistet nem kell updatelni (remelem)
+                                System.out.println("egyiranyura allitom az ajtot");
                                 return new Vec2(-1,-1);
                             }
                         }
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"AutoImportSettings\">\r\n    <option name=\"autoReloadType\" value=\"SELECTIVE\" />\r\n  </component>\r\n  <component name=\"ChangeListManager\">\r\n    <list default=\"true\" id=\"3506ab6d-0407-47f2-a7e8-78ebc867e577\" name=\"Changes\" comment=\"it's working\">\r\n      <change beforePath=\"$PROJECT_DIR$/.idea/sonarlint/issuestore/7/6/768fc9e076fa68cb423d0b0f6604f4e0296bed89\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/sonarlint/issuestore/7/6/768fc9e076fa68cb423d0b0f6604f4e0296bed89\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/.idea/sonarlint/issuestore/9/5/95e852f03d23ecabb97806217a07c752c409eb7b\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/sonarlint/issuestore/9/5/95e852f03d23ecabb97806217a07c752c409eb7b\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/.idea/sonarlint/issuestore/9/c/9c5b76ca10ecfaf22d96236316b037e6470b3693\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/sonarlint/issuestore/9/c/9c5b76ca10ecfaf22d96236316b037e6470b3693\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/.idea/sonarlint/issuestore/c/a/ca0db237d642623320d941e9c23c4dea256bde23\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/sonarlint/issuestore/c/a/ca0db237d642623320d941e9c23c4dea256bde23\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/.idea/sonarlint/issuestore/e/4/e4271d76d0528cc918e2133542540146c36b8cc9\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/sonarlint/issuestore/e/4/e4271d76d0528cc918e2133542540146c36b8cc9\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/.idea/sonarlint/issuestore/f/2/f2d42c4e44b2723eb7efe0208d64f67bd717e8ff\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/sonarlint/issuestore/f/2/f2d42c4e44b2723eb7efe0208d64f67bd717e8ff\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/.idea/workspace.xml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/workspace.xml\" afterDir=\"false\" />\r\n    </list>\r\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\r\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\r\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\r\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\r\n  </component>\r\n  <component name=\"ExternalProjectsData\">\r\n    <projectState path=\"$PROJECT_DIR$\">\r\n      <ProjectState />\r\n    </projectState>\r\n  </component>\r\n  <component name=\"ExternalProjectsManager\">\r\n    <system id=\"GRADLE\">\r\n      <state>\r\n        <task path=\"$PROJECT_DIR$\">\r\n          <activation />\r\n        </task>\r\n        <projects_view>\r\n          <tree_state>\r\n            <expand />\r\n            <select />\r\n          </tree_state>\r\n        </projects_view>\r\n      </state>\r\n    </system>\r\n  </component>\r\n  <component name=\"FileTemplateManagerImpl\">\r\n    <option name=\"RECENT_TEMPLATES\">\r\n      <list>\r\n        <option value=\"Class\" />\r\n        <option value=\"Interface\" />\r\n      </list>\r\n    </option>\r\n  </component>\r\n  <component name=\"Git.Settings\">\r\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\r\n  </component>\r\n  <component name=\"MarkdownSettingsMigration\">\r\n    <option name=\"stateVersion\" value=\"1\" />\r\n  </component>\r\n  <component name=\"ProjectColorInfo\">{\r\n  &quot;associatedIndex&quot;: 8\r\n}</component>\r\n  <component name=\"ProjectId\" id=\"2frbzqFlsraLkUjUjuqMYUBt0BV\" />\r\n  <component name=\"ProjectViewState\">\r\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\r\n    <option name=\"showLibraryContents\" value=\"true\" />\r\n  </component>\r\n  <component name=\"PropertiesComponent\">{\r\n  &quot;keyToString&quot;: {\r\n    &quot;Downloaded.Files.Path.Enabled&quot;: &quot;false&quot;,\r\n    &quot;Gradle.MultiplayerTester.executor&quot;: &quot;Run&quot;,\r\n    &quot;Gradle.MultiplayerTester.testPacket01.executor&quot;: &quot;Run&quot;,\r\n    &quot;Gradle.MultiplayerTester.testPacket02Constructor.executor&quot;: &quot;Run&quot;,\r\n    &quot;Gradle.iLaby [run].executor&quot;: &quot;Run&quot;,\r\n    &quot;Repository.Attach.Annotations&quot;: &quot;false&quot;,\r\n    &quot;Repository.Attach.JavaDocs&quot;: &quot;false&quot;,\r\n    &quot;Repository.Attach.Sources&quot;: &quot;false&quot;,\r\n    &quot;RunOnceActivity.OpenProjectViewOnStart&quot;: &quot;true&quot;,\r\n    &quot;RunOnceActivity.ShowReadmeOnStart&quot;: &quot;true&quot;,\r\n    &quot;WebServerToolWindowFactoryState&quot;: &quot;false&quot;,\r\n    &quot;git-widget-placeholder&quot;: &quot;main&quot;,\r\n    &quot;kotlin-language-version-configured&quot;: &quot;true&quot;,\r\n    &quot;last_opened_file_path&quot;: &quot;C:/Users/kuruc/Downloads/junit-4.13.2.jar&quot;,\r\n    &quot;node.js.detected.package.eslint&quot;: &quot;true&quot;,\r\n    &quot;node.js.detected.package.tslint&quot;: &quot;true&quot;,\r\n    &quot;node.js.selected.package.eslint&quot;: &quot;(autodetect)&quot;,\r\n    &quot;node.js.selected.package.tslint&quot;: &quot;(autodetect)&quot;,\r\n    &quot;project.structure.last.edited&quot;: &quot;Modules&quot;,\r\n    &quot;project.structure.proportion&quot;: &quot;0.15&quot;,\r\n    &quot;project.structure.side.proportion&quot;: &quot;0.2&quot;,\r\n    &quot;settings.editor.selected.configurable&quot;: &quot;reference.settingsdialog.project.gradle&quot;,\r\n    &quot;vue.rearranger.settings.migration&quot;: &quot;true&quot;\r\n  }\r\n}</component>\r\n  <component name=\"RunManager\" selected=\"Gradle.iLaby [run]\">\r\n    <configuration name=\"MultiplayerTester\" type=\"GradleRunConfiguration\" factoryName=\"Gradle\" temporary=\"true\">\r\n      <ExternalSystemSettings>\r\n        <option name=\"executionName\" />\r\n        <option name=\"externalProjectPath\" value=\"$PROJECT_DIR$\" />\r\n        <option name=\"externalSystemIdString\" value=\"GRADLE\" />\r\n        <option name=\"scriptParameters\" value=\"\" />\r\n        <option name=\"taskDescriptions\">\r\n          <list />\r\n        </option>\r\n        <option name=\"taskNames\">\r\n          <list>\r\n            <option value=\":test\" />\r\n            <option value=\"--tests\" />\r\n            <option value=\"&quot;MultiplayerTester&quot;\" />\r\n          </list>\r\n        </option>\r\n        <option name=\"vmOptions\" />\r\n      </ExternalSystemSettings>\r\n      <ExternalSystemDebugServerProcess>false</ExternalSystemDebugServerProcess>\r\n      <ExternalSystemReattachDebugProcess>true</ExternalSystemReattachDebugProcess>\r\n      <DebugAllEnabled>false</DebugAllEnabled>\r\n      <RunAsTest>true</RunAsTest>\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration name=\"MultiplayerTester.testPacket01\" type=\"GradleRunConfiguration\" factoryName=\"Gradle\" temporary=\"true\">\r\n      <ExternalSystemSettings>\r\n        <option name=\"executionName\" />\r\n        <option name=\"externalProjectPath\" value=\"$PROJECT_DIR$\" />\r\n        <option name=\"externalSystemIdString\" value=\"GRADLE\" />\r\n        <option name=\"scriptParameters\" value=\"\" />\r\n        <option name=\"taskDescriptions\">\r\n          <list />\r\n        </option>\r\n        <option name=\"taskNames\">\r\n          <list>\r\n            <option value=\":test\" />\r\n            <option value=\"--tests\" />\r\n            <option value=\"&quot;MultiplayerTester.testPacket01&quot;\" />\r\n          </list>\r\n        </option>\r\n        <option name=\"vmOptions\" />\r\n      </ExternalSystemSettings>\r\n      <ExternalSystemDebugServerProcess>false</ExternalSystemDebugServerProcess>\r\n      <ExternalSystemReattachDebugProcess>true</ExternalSystemReattachDebugProcess>\r\n      <DebugAllEnabled>false</DebugAllEnabled>\r\n      <RunAsTest>true</RunAsTest>\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration name=\"MultiplayerTester.testPacket02Constructor\" type=\"GradleRunConfiguration\" factoryName=\"Gradle\" temporary=\"true\">\r\n      <ExternalSystemSettings>\r\n        <option name=\"executionName\" />\r\n        <option name=\"externalProjectPath\" value=\"$PROJECT_DIR$\" />\r\n        <option name=\"externalSystemIdString\" value=\"GRADLE\" />\r\n        <option name=\"scriptParameters\" value=\"\" />\r\n        <option name=\"taskDescriptions\">\r\n          <list />\r\n        </option>\r\n        <option name=\"taskNames\">\r\n          <list>\r\n            <option value=\":test\" />\r\n            <option value=\"--tests\" />\r\n            <option value=\"&quot;MultiplayerTester.testPacket02Constructor&quot;\" />\r\n          </list>\r\n        </option>\r\n        <option name=\"vmOptions\" />\r\n      </ExternalSystemSettings>\r\n      <ExternalSystemDebugServerProcess>false</ExternalSystemDebugServerProcess>\r\n      <ExternalSystemReattachDebugProcess>true</ExternalSystemReattachDebugProcess>\r\n      <DebugAllEnabled>false</DebugAllEnabled>\r\n      <RunAsTest>true</RunAsTest>\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration name=\"iLaby [run]\" type=\"GradleRunConfiguration\" factoryName=\"Gradle\" singleton=\"false\" nameIsGenerated=\"true\">\r\n      <ExternalSystemSettings>\r\n        <option name=\"executionName\" />\r\n        <option name=\"externalProjectPath\" value=\"$PROJECT_DIR$\" />\r\n        <option name=\"externalSystemIdString\" value=\"GRADLE\" />\r\n        <option name=\"scriptParameters\" value=\"\" />\r\n        <option name=\"taskDescriptions\">\r\n          <list />\r\n        </option>\r\n        <option name=\"taskNames\">\r\n          <list>\r\n            <option value=\"run\" />\r\n          </list>\r\n        </option>\r\n        <option name=\"vmOptions\" />\r\n      </ExternalSystemSettings>\r\n      <ExternalSystemDebugServerProcess>true</ExternalSystemDebugServerProcess>\r\n      <ExternalSystemReattachDebugProcess>true</ExternalSystemReattachDebugProcess>\r\n      <DebugAllEnabled>false</DebugAllEnabled>\r\n      <RunAsTest>false</RunAsTest>\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <list>\r\n      <item itemvalue=\"Gradle.iLaby [run]\" />\r\n      <item itemvalue=\"Gradle.MultiplayerTester\" />\r\n      <item itemvalue=\"Gradle.MultiplayerTester.testPacket02Constructor\" />\r\n      <item itemvalue=\"Gradle.MultiplayerTester.testPacket01\" />\r\n    </list>\r\n    <recent_temporary>\r\n      <list>\r\n        <item itemvalue=\"Gradle.MultiplayerTester\" />\r\n        <item itemvalue=\"Gradle.MultiplayerTester.testPacket02Constructor\" />\r\n        <item itemvalue=\"Gradle.MultiplayerTester.testPacket01\" />\r\n      </list>\r\n    </recent_temporary>\r\n  </component>\r\n  <component name=\"SharedIndexes\">\r\n    <attachedChunks>\r\n      <set>\r\n        <option value=\"jdk-18.0.2-corretto-18.0.2-4caba194b151-5720f15e\" />\r\n        <option value=\"jdk-21.0.2-openjdk-21.0.2-4caba194b151-4f524021\" />\r\n      </set>\r\n    </attachedChunks>\r\n  </component>\r\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"application-level\" UseSingleDictionary=\"true\" transferred=\"true\" />\r\n  <component name=\"TaskManager\">\r\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\r\n      <changelist id=\"3506ab6d-0407-47f2-a7e8-78ebc867e577\" name=\"Changes\" comment=\"\" />\r\n      <created>1714562409879</created>\r\n      <option name=\"number\" value=\"Default\" />\r\n      <option name=\"presentableId\" value=\"Default\" />\r\n      <updated>1714562409879</updated>\r\n      <workItem from=\"1714562410886\" duration=\"908000\" />\r\n      <workItem from=\"1714687853059\" duration=\"1015000\" />\r\n      <workItem from=\"1714731678095\" duration=\"398000\" />\r\n      <workItem from=\"1714740938116\" duration=\"2592000\" />\r\n      <workItem from=\"1714743658125\" duration=\"732000\" />\r\n      <workItem from=\"1714747759256\" duration=\"7383000\" />\r\n      <workItem from=\"1714847163651\" duration=\"324000\" />\r\n    </task>\r\n    <task id=\"LOCAL-00001\" summary=\"it's working\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1714665384490</created>\r\n      <option name=\"number\" value=\"00001\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00001\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1714665384490</updated>\r\n    </task>\r\n    <option name=\"localTasksCounter\" value=\"2\" />\r\n    <servers />\r\n  </component>\r\n  <component name=\"TypeScriptGeneratedFilesManager\">\r\n    <option name=\"version\" value=\"3\" />\r\n  </component>\r\n  <component name=\"Vcs.Log.Tabs.Properties\">\r\n    <option name=\"TAB_STATES\">\r\n      <map>\r\n        <entry key=\"MAIN\">\r\n          <value>\r\n            <State />\r\n          </value>\r\n        </entry>\r\n      </map>\r\n    </option>\r\n  </component>\r\n  <component name=\"VcsManagerConfiguration\">\r\n    <MESSAGE value=\"it's working\" />\r\n    <option name=\"LAST_COMMIT_MESSAGE\" value=\"it's working\" />\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	(revision 7b1e06b61fea754fde53334cdd606eb9c3e7c55a)
+++ b/.idea/workspace.xml	(date 1715095798291)
@@ -5,13 +5,9 @@
   </component>
   <component name="ChangeListManager">
     <list default="true" id="3506ab6d-0407-47f2-a7e8-78ebc867e577" name="Changes" comment="it's working">
-      <change beforePath="$PROJECT_DIR$/.idea/sonarlint/issuestore/7/6/768fc9e076fa68cb423d0b0f6604f4e0296bed89" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/sonarlint/issuestore/7/6/768fc9e076fa68cb423d0b0f6604f4e0296bed89" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/.idea/sonarlint/issuestore/9/5/95e852f03d23ecabb97806217a07c752c409eb7b" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/sonarlint/issuestore/9/5/95e852f03d23ecabb97806217a07c752c409eb7b" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/.idea/sonarlint/issuestore/9/c/9c5b76ca10ecfaf22d96236316b037e6470b3693" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/sonarlint/issuestore/9/c/9c5b76ca10ecfaf22d96236316b037e6470b3693" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/.idea/sonarlint/issuestore/c/a/ca0db237d642623320d941e9c23c4dea256bde23" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/sonarlint/issuestore/c/a/ca0db237d642623320d941e9c23c4dea256bde23" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/.idea/sonarlint/issuestore/e/4/e4271d76d0528cc918e2133542540146c36b8cc9" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/sonarlint/issuestore/e/4/e4271d76d0528cc918e2133542540146c36b8cc9" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/.idea/sonarlint/issuestore/f/2/f2d42c4e44b2723eb7efe0208d64f67bd717e8ff" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/sonarlint/issuestore/f/2/f2d42c4e44b2723eb7efe0208d64f67bd717e8ff" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/main/java/org/game/Map/Map.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/org/game/Map/Map.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/main/java/org/networking/MapHandler.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/org/networking/MapHandler.java" afterDir="false" />
     </list>
     <option name="SHOW_DIALOG" value="false" />
     <option name="HIGHLIGHT_CONFLICTS" value="true" />
@@ -60,33 +56,34 @@
     <option name="hideEmptyMiddlePackages" value="true" />
     <option name="showLibraryContents" value="true" />
   </component>
-  <component name="PropertiesComponent">{
-  &quot;keyToString&quot;: {
-    &quot;Downloaded.Files.Path.Enabled&quot;: &quot;false&quot;,
-    &quot;Gradle.MultiplayerTester.executor&quot;: &quot;Run&quot;,
-    &quot;Gradle.MultiplayerTester.testPacket01.executor&quot;: &quot;Run&quot;,
-    &quot;Gradle.MultiplayerTester.testPacket02Constructor.executor&quot;: &quot;Run&quot;,
-    &quot;Gradle.iLaby [run].executor&quot;: &quot;Run&quot;,
-    &quot;Repository.Attach.Annotations&quot;: &quot;false&quot;,
-    &quot;Repository.Attach.JavaDocs&quot;: &quot;false&quot;,
-    &quot;Repository.Attach.Sources&quot;: &quot;false&quot;,
-    &quot;RunOnceActivity.OpenProjectViewOnStart&quot;: &quot;true&quot;,
-    &quot;RunOnceActivity.ShowReadmeOnStart&quot;: &quot;true&quot;,
-    &quot;WebServerToolWindowFactoryState&quot;: &quot;false&quot;,
-    &quot;git-widget-placeholder&quot;: &quot;main&quot;,
-    &quot;kotlin-language-version-configured&quot;: &quot;true&quot;,
-    &quot;last_opened_file_path&quot;: &quot;C:/Users/kuruc/Downloads/junit-4.13.2.jar&quot;,
-    &quot;node.js.detected.package.eslint&quot;: &quot;true&quot;,
-    &quot;node.js.detected.package.tslint&quot;: &quot;true&quot;,
-    &quot;node.js.selected.package.eslint&quot;: &quot;(autodetect)&quot;,
-    &quot;node.js.selected.package.tslint&quot;: &quot;(autodetect)&quot;,
-    &quot;project.structure.last.edited&quot;: &quot;Modules&quot;,
-    &quot;project.structure.proportion&quot;: &quot;0.15&quot;,
-    &quot;project.structure.side.proportion&quot;: &quot;0.2&quot;,
-    &quot;settings.editor.selected.configurable&quot;: &quot;reference.settingsdialog.project.gradle&quot;,
-    &quot;vue.rearranger.settings.migration&quot;: &quot;true&quot;
+  <component name="PropertiesComponent"><![CDATA[{
+  "keyToString": {
+    "Downloaded.Files.Path.Enabled": "false",
+    "Gradle.MultiplayerTester.executor": "Run",
+    "Gradle.MultiplayerTester.testPacket01.executor": "Run",
+    "Gradle.MultiplayerTester.testPacket02Constructor.executor": "Run",
+    "Gradle.iLaby [run].executor": "Run",
+    "Repository.Attach.Annotations": "false",
+    "Repository.Attach.JavaDocs": "false",
+    "Repository.Attach.Sources": "false",
+    "RunOnceActivity.OpenProjectViewOnStart": "true",
+    "RunOnceActivity.ShowReadmeOnStart": "true",
+    "WebServerToolWindowFactoryState": "false",
+    "git-widget-placeholder": "main",
+    "kotlin-language-version-configured": "true",
+    "last_opened_file_path": "C:/Users/kuruc/Downloads/junit-4.13.2.jar",
+    "node.js.detected.package.eslint": "true",
+    "node.js.detected.package.tslint": "true",
+    "node.js.selected.package.eslint": "(autodetect)",
+    "node.js.selected.package.tslint": "(autodetect)",
+    "nodejs_package_manager_path": "npm",
+    "project.structure.last.edited": "Modules",
+    "project.structure.proportion": "0.15",
+    "project.structure.side.proportion": "0.2",
+    "settings.editor.selected.configurable": "reference.settingsdialog.project.gradle",
+    "vue.rearranger.settings.migration": "true"
   }
-}</component>
+}]]></component>
   <component name="RunManager" selected="Gradle.iLaby [run]">
     <configuration name="MultiplayerTester" type="GradleRunConfiguration" factoryName="Gradle" temporary="true">
       <ExternalSystemSettings>
@@ -218,7 +215,7 @@
       <workItem from="1714740938116" duration="2592000" />
       <workItem from="1714743658125" duration="732000" />
       <workItem from="1714747759256" duration="7383000" />
-      <workItem from="1714847163651" duration="324000" />
+      <workItem from="1714847163651" duration="9640000" />
     </task>
     <task id="LOCAL-00001" summary="it's working">
       <option name="closed" value="true" />
