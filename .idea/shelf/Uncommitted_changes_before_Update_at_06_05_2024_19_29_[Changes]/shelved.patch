Index: src/main/java/org/entities/player/Player.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package main.java.org.entities.player;\r\n\r\n\r\nimport main.java.org.entities.villain.Villain;\r\nimport main.java.org.game.Audio.AudioManager;\r\nimport main.java.org.game.Audio.Sound;\r\nimport main.java.org.game.Graphics.*;\r\n\r\nimport main.java.org.entities.Entity;\r\n\r\nimport main.java.org.game.Isten;\r\nimport main.java.org.game.Map.RoomType;\r\nimport main.java.org.game.UI.TimeCounter;\r\nimport main.java.org.game.physics.Collider;\r\nimport main.java.org.items.Item;\r\nimport main.java.org.items.usable_items.Gasmask;\r\nimport main.java.org.linalg.Vec2;\r\nimport main.java.org.networking.Packet03Animation;\r\nimport main.java.org.game.Map.Room;\r\nimport main.java.org.game.Map.UnitRoom;\r\nimport main.java.org.game.PlayerPrefs.PlayerPrefs;\r\nimport main.java.org.game.updatable.Updatable;\r\n\r\nimport java.awt.event.KeyEvent;\r\nimport java.util.ArrayList;\r\n\r\n/**\r\n * The player class, makes almost everything related to the player.\r\n */\r\npublic class Player extends Entity {\r\n\r\n    Collider playerCollider;\r\n    ArrayList<Image> playerImage;\r\n    ImageUI death;\r\n    int activeImage;\r\n    TextUI motivational;\r\n    float time;\r\n    Text playerName;\r\n    boolean alive;  //Bool variable, to store status of player: ded or alive\r\n    Sound playerSound = null;\r\n    double faintingTime;\r\n    boolean isFainted;\r\n    boolean isInGasRoomButHasMask;\r\n    float speed;\r\n    protected Vec2 spawnPosition;\r\n    protected int run = 1;\r\n    protected int skinID;\r\n    public boolean localPlayer = false;\r\n    private Room currentRoom = null;\r\n\r\n    public Player() {\r\n        playerCollider = null;\r\n        playerImage = null;\r\n        death = null;\r\n        motivational = null;\r\n        activeImage = 0;\r\n        time = 0.0f;\r\n        playerName = new Text(PlayerPrefs.getString(\"name\"), new Vec2(0, 0), \"./assets/Bavarian.otf\", 15, 0, 0, 255);\r\n        playerName.setShadowOn(false);\r\n        alive = true;\r\n        spawnPosition = new Vec2(0, 0);\r\n        faintingTime = 0;\r\n        isFainted = false;\r\n        isInGasRoomButHasMask = false;\r\n        speed=2;\r\n    }\r\n\r\n    public Player(String name) {\r\n        playerCollider = null;\r\n        playerImage = null;\r\n        death = null;\r\n        activeImage = 0;\r\n        motivational = null;\r\n        time = 0.0f;\r\n        playerName = new Text(name, new Vec2(0, 0), \"./assets/Monocraft.ttf\", 15, 0, 0, 255);\r\n        playerName.setShadowOn(false);\r\n        alive = true;\r\n        spawnPosition = new Vec2(0, 0);\r\n        faintingTime = 0;\r\n        isFainted = false;\r\n        speed=2;\r\n    }\r\n\r\n    public Player(String name, Vec2 spawnPosition) {\r\n        this(name);\r\n        this.spawnPosition.x = spawnPosition.x;\r\n        this.spawnPosition.y = spawnPosition.y;\r\n    }\r\n\r\n    @Override\r\n    public void onStart(Isten isten) {\r\n        //called when the player is initialized\r\n\r\n        Vec2 playerScale = new Vec2(0.5f, 0.5f);\r\n        Vec2 faintedScale = new Vec2(0.6f, 0.6f);\r\n\r\n        playerCollider = new Collider(new Vec2(spawnPosition.x, spawnPosition.y), playerScale);\r\n        playerCollider.setMovability(true);\r\n        isten.getPhysicsEngine().addCollider(playerCollider);//register collider in the physics engine\r\n\r\n        playerImage = new ArrayList<>();\r\n        playerImage.add(new Image(new Vec2(), playerScale, \"./assets/character/character\" + skinID + \"_right1.png\"));\r\n        playerImage.add(new Image(new Vec2(), playerScale, \"./assets/character/character\" + skinID + \"_right2.png\"));\r\n        playerImage.add(new Image(new Vec2(), playerScale, \"./assets/character/character\" + skinID + \"_left1.png\"));\r\n        playerImage.add(new Image(new Vec2(), playerScale, \"./assets/character/character\" + skinID + \"_left2.png\"));\r\n        playerImage.add(new Image(new Vec2(), faintedScale, \"./assets/character/character\" + skinID + \"_right1_fainted.png\"));\r\n        playerImage.add(new Image(new Vec2(), faintedScale, \"./assets/character/character\" + skinID + \"_right2_fainted1.png\"));\r\n        playerImage.add(new Image(new Vec2(), faintedScale, \"./assets/character/character\" + skinID + \"_left1_fainted.png\"));\r\n        playerImage.add(new Image(new Vec2(), faintedScale, \"./assets/character/character\" + skinID + \"_left2_fainted1.png\"));\r\n        playerImage.add(new Image(new Vec2(), faintedScale, \"./assets/character/character\" + skinID + \"_right2_fainted2.png\"));\r\n        playerImage.add(new Image(new Vec2(), faintedScale, \"./assets/character/character\" + skinID + \"_left2_fainted2.png\"));\r\n        playerImage.add(new Image(new Vec2(), faintedScale, \"./assets/character/character\" + skinID + \"_right1_mask.png\"));\r\n        playerImage.add(new Image(new Vec2(), faintedScale, \"./assets/character/character\" + skinID + \"_right2_mask.png\"));\r\n        playerImage.add(new Image(new Vec2(), faintedScale, \"./assets/character/character\" + skinID + \"_left1_mask.png\"));\r\n        playerImage.add(new Image(new Vec2(), faintedScale, \"./assets/character/character\" + skinID + \"_left2_mask.png\"));\r\n        playerImage.add(new Image(new Vec2(), playerScale, \"./assets/character/character\" + skinID + \"_ded.png\"));\r\n\r\n        for (Image im : playerImage) {\r\n            im.setSortingLayer(-69);\r\n            im.setVisibility(false);\r\n            isten.getRenderer().addRenderable(im);//register images in the renderer\r\n        }\r\n        playerImage.get(playerImage.size() - 1).setSortingLayer(-67);\r\n\r\n        activeImage = 1;\r\n        playerImage.get(activeImage).setVisibility(true);\r\n\r\n        death = new ImageUI(new Vec2(spawnPosition.x, spawnPosition.y), new Vec2(isten.getRenderer().getWidth(), isten.getRenderer().getHeight()), \"./assets/character/ded.png\");\r\n        death.setSortingLayer(-70);\r\n        death.setVisibility(false);\r\n        death.setAlignment(Renderable.CENTER, Renderable.CENTER);\r\n        isten.getRenderer().addRenderable(death);\r\n\r\n        motivational = new TextUI(\"Try again loser.\", new Vec2(0, -170), 26, 200, 200, 200);\r\n        motivational.setSortingLayer(-71);\r\n        motivational.setVisibility(false);\r\n        motivational.setAlignment(Renderable.CENTER, Renderable.CENTER);\r\n        isten.getRenderer().addRenderable(motivational);\r\n\r\n        if (playerName != null) {\r\n            playerName.setVisibility(true);\r\n            playerName.setSortingLayer(-69);\r\n            isten.getRenderer().addRenderable(playerName);\r\n        }\r\n\r\n        //adjust camera zoom\r\n        isten.getCamera().setPixelsPerUnit(100);\r\n\r\n        //preload player sound\r\n        AudioManager.preloadSound(\"./assets/audio/playersound.ogg\");\r\n        AudioManager.preloadSound(\"./assets/audio/died.ogg\");\r\n    }\r\n\r\n    @Override\r\n    public void onUpdate(Isten isten, double deltaTime) {\r\n        //called every frame\r\n        if (alive) {\r\n\r\n            if (isFainted) {\r\n                if (faintingTime > 10) {\r\n                    faintingTime = 0;\r\n                    isFainted = false;\r\n                    speed = 2;\r\n                }\r\n            }\r\n\r\n            Room currentRoom = null;\r\n\r\n            for (Room room : isten.getMap().getRooms()) {\r\n                for (UnitRoom unitRoom : room.getUnitRooms()) {\r\n                    if (playerCollider.getPosition().x >= unitRoom.getPosition().x - 0.5 &&\r\n                            playerCollider.getPosition().x <= unitRoom.getPosition().x + 0.5 &&\r\n                            playerCollider.getPosition().y >= unitRoom.getPosition().y - 0.5 &&\r\n                            playerCollider.getPosition().y <= unitRoom.getPosition().y + 0.5) {\r\n                        currentRoom = room;\r\n                    }\r\n                }\r\n            }\r\n            if(currentRoom != this.currentRoom){\r\n                //Lasd Inventory canAvoidVillain member var\r\n                isten.getInventory().setCanAvoidVillain(false);\r\n                //Ha szobat valt a player, akkor a kovetkezo alkalommar, amikor gegnerrel talalkozik hasznalodnia kell a Tvsz-nek\r\n                isten.getInventory().resetShouldUseChargeForTvsz();\r\n                this.currentRoom = currentRoom;\r\n            }\r\n            if (currentRoom != null && currentRoom.getRoomType() == RoomType.GAS) {\r\n                if (!isten.getInventory().getExistenceOfGasMask()) {\r\n                    faintingTime = 0;\r\n                    isFainted = true;\r\n                    speed = 1;\r\n                    for (int i = 0; i < 5; i++) {\r\n                        if (isten.getInventory().getStoredItems().get(i) != null) {\r\n                            isten.getInventory().getStoredItems().get(i).dropOnGround(new Vec2(currentRoom.getUnitRooms().get(i + 1).getPosition().x, currentRoom.getUnitRooms().get(i + 1).getPosition().y));\r\n                        }\r\n                    }\r\n                    isten.getInventory().dropAllItems(isten);\r\n                    isInGasRoomButHasMask = false;\r\n                }\r\n                else {\r\n                    int index=0;\r\n                    for(;index<isten.getInventory().getSize();index++){\r\n                        if(isten.getInventory().getStoredItems().get(index) instanceof Gasmask) break;\r\n                    }\r\n                    isInGasRoomButHasMask = true;\r\n                    isten.getInventory().getStoredItems().get(index).use(deltaTime);\r\n                }\r\n            } else {\r\n                faintingTime += deltaTime;\r\n                isInGasRoomButHasMask = false;\r\n            }\r\n\r\n            //move the character\r\n            run = 1;\r\n            boolean w = isten.getInputHandler().isKeyDown(KeyEvent.VK_W);\r\n            boolean a = isten.getInputHandler().isKeyDown(KeyEvent.VK_A);\r\n            boolean s = isten.getInputHandler().isKeyDown(KeyEvent.VK_S);\r\n            boolean d = isten.getInputHandler().isKeyDown(KeyEvent.VK_D);\r\n\r\n            if (isten.getInputHandler().isKeyDown(KeyEvent.VK_SHIFT) && !isFainted) run *= 2;//Shift is run\r\n\r\n            if (localPlayer) {\r\n                if (w) {\r\n                    playerCollider.getVelocity().y = 2 * run;\r\n                } else if (!w) playerCollider.getVelocity().y = 0;\r\n                if (a) {\r\n                    playerCollider.getVelocity().x = -2 * run;\r\n                } else if (!a) playerCollider.getVelocity().x = 0;\r\n                if (s) {\r\n                    playerCollider.getVelocity().y = -2 * run;\r\n                } else if (!s && !w) playerCollider.getVelocity().y = 0;\r\n                if (d) {\r\n                    playerCollider.getVelocity().x = 2 * run;\r\n                } else if (!d && !a) playerCollider.getVelocity().x = 0;\r\n            }\r\n            //animation\r\n\r\n            time += deltaTime;\r\n            if (time > 0.2f / run) { //after this much time does the animation changes\r\n                int prev = activeImage;\r\n                boolean leftFacing = prev > 1 && prev < 4 || prev > 5 && prev < 8 || prev > 11 && prev < 14;\r\n                if (isFainted && playerCollider.getVelocity().magnitude() == 0.0f) { //fainted animation\r\n                    if (leftFacing|| prev == 9) activeImage = 7;\r\n                    else activeImage = 5;\r\n                    if (prev == 5) activeImage = 8;\r\n                    if (prev == 7) activeImage = 9;\r\n                }\r\n                else if(isInGasRoomButHasMask){ //mask animation\r\n                    if (playerCollider.getVelocity().x > 0) activeImage = 10;\r\n                    else if (playerCollider.getVelocity().x < 0) activeImage = 12;\r\n                    else if (leftFacing) activeImage = 12;\r\n                    else activeImage = 10;\r\n                    if (prev % 2 == 0 || playerCollider.getVelocity().magnitude() == 0.0f) activeImage++;\r\n                }\r\n                else { //normal animation\r\n                    if (playerCollider.getVelocity().x > 0) activeImage = 0;\r\n                    else if (playerCollider.getVelocity().x < 0) activeImage = 2;\r\n                    else if (leftFacing) activeImage = 2;\r\n                    else activeImage = 0;\r\n                    if (prev % 2 == 0 || playerCollider.getVelocity().magnitude() == 0.0f) activeImage++;\r\n                    if (isFainted) activeImage += 4;\r\n                }\r\n                playerImage.get(prev).setVisibility(false);\r\n                playerImage.get(activeImage).setVisibility(true);\r\n                time = 0.0f;\r\n                sendAnimationData(isten);\r\n            }\r\n\r\n            //move image\r\n            //the origin of the image is in its top right corner, therefore the imagePos looks like this: screenSpace(collider position) - 0.5*imageScale\r\n\r\n            Vec2 playerPosition = playerCollider.getPosition();\r\n            for (int i = 0; i < playerImage.size(); i++) {\r\n                playerImage.get(i).setPosition(playerPosition);\r\n            }\r\n            playerName.setPosition(Vec2.sum(playerPosition, new Vec2(0, (float) 0.5)));\r\n\r\n            //move camera\r\n            if (localPlayer) isten.getCamera().setPosition(playerCollider.getPosition());\r\n\r\n            //play sound\r\n            if (!AudioManager.isPlaying(playerSound) && localPlayer)\r\n                playerSound = AudioManager.playSound(\"./assets/audio/playersound.ogg\");\r\n\r\n            if (TimeCounter.getTimeRemaining() < 0 && alive) {\r\n                alive = false;\r\n                AudioManager.closeSound(playerSound);\r\n            }\r\n\r\n        }\r\n        else {\r\n\r\n            if (!AudioManager.isPlaying(playerSound) && localPlayer)\r\n                playerSound = AudioManager.playSound(\"./assets/audio/died.ogg\");\r\n\r\n            if (activeImage != 14) {\r\n                playerCollider.setVelocity(new Vec2(0));\r\n                playerImage.get(activeImage).setVisibility(false);\r\n                activeImage = 14;\r\n                playerImage.get(activeImage).setVisibility(true);\r\n                if (localPlayer) {\r\n                    death.setVisibility(true);\r\n                    motivational.setVisibility(true);\r\n                }\r\n            }\r\n        }\r\n        death.setScale(new Vec2(isten.getRenderer().getWidth(), isten.getRenderer().getHeight()));\r\n    }\r\n\r\n    public boolean checkIfPlayerInVillainRoom(Isten isten,double deltaTime) {\r\n        Room currentRoom = null;\r\n        for (Updatable u : isten.getUpdatables()) {\r\n            if (u.getClass().equals(Villain.class)) {\r\n                currentRoom = getPlayerRoom(isten, playerCollider.getPosition());\r\n                Villain villain = (Villain) u;\r\n                if ((currentRoom != null && currentRoom.equals(villain.getRoom())) && currentRoom.getRoomType() != RoomType.GAS&&!villain.getIsFainted()) {\r\n                   //Ha van akkora szerencsenk, hogy van item nalunk, ami megmentene megse halunk meg\r\n                    if(!isten.getInventory().avoidVillain(deltaTime)){\r\n                        if (localPlayer && playerSound != null)\r\n                            AudioManager.closeSound(playerSound);\r\n                        return true;\r\n                    }\r\n\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    //kiszerveztem a fenti fv-t, mert nekem is kellett, és máshol később is hasznos lehet, ha kell, unitRoomra is ki lehetne szervezni\r\n    public Room getPlayerRoom(Isten isten, Vec2 playerPos){\r\n        UnitRoom[][] unitRooms= isten.getMap().getUnitRooms();\r\n        for(int i = 0; i < unitRooms.length;i++){\r\n            for(int j = 0; j<unitRooms[i].length;j++){\r\n                if (playerPos.x >= unitRooms[i][j].getPosition().x - 0.5 &&\r\n                        playerPos.x <= unitRooms[i][j].getPosition().x + 0.5 &&\r\n                        playerPos.y >= unitRooms[i][j].getPosition().y - 0.5 &&\r\n                        playerPos.y <= unitRooms[i][j].getPosition().y + 0.5)\r\n                {\r\n                    return unitRooms[i][j].getOwnerRoom();\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    @Override\r\n    public void onDestroy() {\r\n        //not implemented yet\r\n    }\r\n    public Room getCurrentRoom() {\r\n        return currentRoom;\r\n    }\r\n\r\n    public void setAlive(boolean alive) {\r\n        this.alive = alive;\r\n    }\r\n\r\n    public boolean isAlive() {\r\n        return alive;\r\n    }\r\n\r\n    public void setPlayerName(Text playerName) {\r\n        this.playerName = playerName;\r\n    }\r\n\r\n    public Collider getPlayerCollider() {\r\n        return playerCollider;\r\n    }\r\n\r\n    public ArrayList<Image> getPlayerImage() {\r\n        return playerImage;\r\n    }\r\n\r\n    public float getTime() {\r\n        return time;\r\n    }\r\n\r\n    public int getActiveImage() {\r\n        return activeImage;\r\n    }\r\n\r\n    public Text getPlayerName() {\r\n        return playerName;\r\n    }\r\n\r\n    public void setPlayerCollider(Collider collider) {\r\n        this.playerCollider = collider;\r\n    }\r\n\r\n    public void setActiveImage(int activeImage) {\r\n        this.activeImage = activeImage;\r\n    }\r\n\r\n    public void setTime(float time) {\r\n        this.time = time;\r\n    }\r\n\r\n    public void setPlayerImage(ArrayList<Image> playerImage) {\r\n        this.playerImage = playerImage;\r\n    }\r\n\r\n    //Needed for instant animation change\r\n    protected void sendAnimationData(Isten isten) {\r\n        //implemented in PlayerMP -> override\r\n    }\r\n\r\n    public void setSkinID(int skinID) {\r\n        this.skinID = skinID;\r\n    }\r\n\r\n    public int getSkinID() {\r\n        return skinID;\r\n    }\r\n\r\n    public boolean isFainted() {\r\n        return isFainted;\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/entities/player/Player.java b/src/main/java/org/entities/player/Player.java
--- a/src/main/java/org/entities/player/Player.java	(revision 2a081a32d6cdbb313837c52de84c0543f0763b2d)
+++ b/src/main/java/org/entities/player/Player.java	(date 1715016234863)
@@ -46,7 +46,8 @@
     protected int run = 1;
     protected int skinID;
     public boolean localPlayer = false;
-    private Room currentRoom = null;
+    public Room currentRoom = null;
+    private boolean isInGasRoom = false;
 
     public Player() {
         playerCollider = null;
@@ -183,17 +184,24 @@
                 isten.getInventory().resetShouldUseChargeForTvsz();
                 this.currentRoom = currentRoom;
             }
-            if (currentRoom != null && currentRoom.getRoomType() == RoomType.GAS) {
+            if (isInGasRoom) {
+                isInGasRoom = false;
                 if (!isten.getInventory().getExistenceOfGasMask()) {
                     faintingTime = 0;
                     isFainted = true;
                     speed = 1;
-                    for (int i = 0; i < 5; i++) {
-                        if (isten.getInventory().getStoredItems().get(i) != null) {
-                            isten.getInventory().getStoredItems().get(i).dropOnGround(new Vec2(currentRoom.getUnitRooms().get(i + 1).getPosition().x, currentRoom.getUnitRooms().get(i + 1).getPosition().y));
-                        }
-                    }
-                    isten.getInventory().dropAllItems(isten);
+                    if(localPlayer) {
+                        for (int i = 0; i < 5; i++) {
+                            if (isten.getInventory().getStoredItems().get(i) != null) {
+                                //TODO
+                                // Should send item dropped to all clients.
+                                // When on client, throws nullpointer exception
+                                if(isten.getSocketServer() != null) isten.getInventory().getStoredItems().get(i).dropOnGround(new Vec2(currentRoom.getUnitRooms().get(i + 1).getPosition().x, currentRoom.getUnitRooms().get(i + 1).getPosition().y));
+                            }
+                        }
+                        isten.getInventory().dropAllItems(isten);
+                    }
+
                     isInGasRoomButHasMask = false;
                 }
                 else {
@@ -414,4 +422,11 @@
     public boolean isFainted() {
         return isFainted;
     }
+    public void isInGasRoom(boolean b) {
+        isInGasRoom = b;
+    }
+
+    public boolean isInGasRoom() {
+        return isInGasRoom;
+    }
 }
\ No newline at end of file
Index: test/MultiplayerTester.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import main.java.org.game.Isten;\r\nimport main.java.org.linalg.Vec2;\r\nimport main.java.org.networking.*;\r\nimport org.junit.Assert;\r\nimport org.junit.Test;\r\n\r\npublic class MultiplayerTester {\r\n\r\n    @Test\r\n    public void testPacket02Constructor() {\r\n        Packet02Move packet02Move = new Packet02Move(\"username\", 1, 1);\r\n        Assert.assertEquals(packet02Move, new Packet02Move(\"username\", 1, 1));\r\n    }\r\n\r\n    @Test\r\n    public void testPacket03Constructor() {\r\n        Packet03Animation packet03Animation = new Packet03Animation(\"username\", 1);\r\n        Assert.assertEquals(packet03Animation, new Packet03Animation(\"username\", 1));\r\n    }\r\n\r\n    @Test\r\n    public void testPacket04Constructor() {\r\n        Packet04UnitRoom packet04UnitRoom = new Packet04UnitRoom(1,1,1);\r\n        Assert.assertEquals(packet04UnitRoom, new Packet04UnitRoom(1,1,1));\r\n    }\r\n\r\n    @Test\r\n    public void testPacket05Constructor() {\r\n        Packet05Villain packet05Villain = new Packet05Villain(\"villain\", new Vec2(1,1), \"imgpath\", 0, 0);\r\n        Assert.assertEquals(packet05Villain, new Packet05Villain(\"villain\", new Vec2(1,1), \"imgpath\", 0, 0));\r\n    }\r\n\r\n    @Test\r\n    public void testPacket06Constructor() {\r\n        Packet06VillainMove packet06VillainMove = new Packet06VillainMove(\"villain1\", 1, 1);\r\n        Assert.assertEquals(packet06VillainMove, new Packet06VillainMove(\"villain1\", 1, 1));\r\n    }\r\n\r\n    @Test\r\n    public void testPacket07Constructor() {\r\n        Packet07Timer packet07Timer = new Packet07Timer(2.0f);\r\n        Assert.assertEquals(packet07Timer, new Packet07Timer(2.0f));\r\n    }\r\n\r\n    @Test\r\n    public void testPacket21Constructor() {\r\n        Packet21Death packet21Death = new Packet21Death(\"player1\");\r\n        Assert.assertEquals(packet21Death, new Packet21Death(\"player1\"));\r\n    }\r\n\r\n    @Test\r\n    public void testSentPacketEqualsArrivedPacket02() {\r\n        Packet02Move packet = new Packet02Move(\"player1\", 2.0f, 2.0f);\r\n        byte[] data = \"02player1,2.0,2.0\".getBytes();\r\n        Assert.assertEquals(new Packet02Move(data), packet);\r\n    }\r\n\r\n    @Test\r\n    public void testSentPacketEqualsArrivedPacket03() {\r\n        Packet03Animation packet = new Packet03Animation(\"player1\", 1);\r\n        byte[] data = \"03player1,1\".getBytes();\r\n        Assert.assertEquals(new Packet03Animation(data), packet);\r\n    }\r\n\r\n    @Test\r\n    public void testSentPacketEqualsArrivedPacket04() {\r\n        Packet04UnitRoom packet = new Packet04UnitRoom(2.0f, 2.0f, 1);\r\n        byte[] data = \"042.0,2.0,1\".getBytes();\r\n        Assert.assertEquals(new Packet04UnitRoom(data), packet);\r\n    }\r\n\r\n    @Test\r\n    public void testSentPacketEqualsArrivedPacket05() {\r\n        Packet05Villain packet = new Packet05Villain(\"villain1\", new Vec2(1,1), \"imagePath\", 1, 1);\r\n        byte[] data = \"05villain1,1.0,1.0,imagePath,1,1\".getBytes();\r\n        Assert.assertEquals(new Packet05Villain(data), packet);\r\n    }\r\n\r\n    @Test\r\n    public void testSentPacketEqualsArrivedPacket06() {\r\n        Packet06VillainMove packet = new Packet06VillainMove(\"villain1\", 1.0f, 1.0f);\r\n        byte[] data = \"06villain1,1.0,1.0\".getBytes();\r\n        Assert.assertEquals(new Packet06VillainMove(data), packet);\r\n    }\r\n\r\n    @Test\r\n    public void testSentPacketEqualsArrivedPacket07() {\r\n        Packet07Timer packet = new Packet07Timer(3.0);\r\n        byte[] data = \"073.0\".getBytes();\r\n        Assert.assertEquals(new Packet07Timer(data), packet);\r\n    }\r\n\r\n    @Test\r\n    public void testSentPacketEqualsArrivedPacket20() {\r\n        Packet20Wall packet = new Packet20Wall(1.0f, 1.0f, 2.0f, 2.0f, true);\r\n        byte[] data = \"201.0,1.0,2.0,2.0,1\".getBytes();\r\n        Assert.assertEquals(new Packet20Wall(data), packet);\r\n    }\r\n\r\n    @Test\r\n    public void testSentPacketEqualsArrivedPacket21() {\r\n        Packet21Death packet = new Packet21Death(\"player1\");\r\n        byte[] data = \"21player1\".getBytes();\r\n        Assert.assertEquals(new Packet21Death(data), packet);\r\n    }\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/test/MultiplayerTester.java b/test/MultiplayerTester.java
--- a/test/MultiplayerTester.java	(revision 2a081a32d6cdbb313837c52de84c0543f0763b2d)
+++ b/test/MultiplayerTester.java	(date 1715012030993)
@@ -64,8 +64,8 @@
 
     @Test
     public void testSentPacketEqualsArrivedPacket04() {
-        Packet04UnitRoom packet = new Packet04UnitRoom(2.0f, 2.0f, 1);
-        byte[] data = "042.0,2.0,1".getBytes();
+        Packet04UnitRoom packet = new Packet04UnitRoom(1,1,1);
+        byte[] data = "041.0,1.0,1".getBytes();
         Assert.assertEquals(new Packet04UnitRoom(data), packet);
     }
 
Index: src/main/java/org/game/Isten.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>    package main.java.org.game;\r\n\r\nimport main.java.org.entities.villain.Villain;\r\nimport main.java.org.game.Camera.Camera;\r\nimport main.java.org.game.Graphics.*;\r\n\r\nimport main.java.org.entities.player.Player;\r\n\r\nimport main.java.org.game.Input.Input;\r\nimport main.java.org.game.Map.EdgeBetweenRooms;\r\nimport main.java.org.game.Map.EdgeManager;\r\nimport main.java.org.game.Map.EdgePiece;\r\nimport main.java.org.game.Map.Map;\r\nimport main.java.org.game.PlayerPrefs.PlayerPrefs;\r\nimport main.java.org.game.UI.*;\r\nimport main.java.org.game.physics.PhysicsEngine;\r\nimport main.java.org.game.updatable.Updatable;\r\nimport main.java.org.linalg.Vec2;\r\n\r\nimport main.java.org.items.ChestManager;\r\nimport main.java.org.items.ItemManager;\r\n\r\nimport main.java.org.networking.*;\r\n\r\nimport javax.swing.*;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\n    /**\r\n * The main class representing the game part of the program.\r\n */\r\npublic class Isten {\r\n    private HandlerManager handlerManager;\r\n    private final PhysicsEngine physicsEngine;\r\n    protected final GameRenderer renderer;\r\n    protected final ArrayList<Updatable> updatables;\r\n    private final ArrayList<Updatable> pendingAddedUpdatables;\r\n    private final ArrayList<Updatable> pendingRemovedUpdatables;\r\n\r\n    private Map map;\r\n    private Inventory inventory;\r\n    private final Input inputHandler;\r\n    private final ItemManager itemManager;\r\n\r\n    private final Camera camera;\r\n\r\n    private GameClient socketClient;\r\n    private GameServer socketServer;\r\n\r\n    private PlayerMP player;\r\n    private ChestManager chestManager;\r\n    private Minimap minimap;\r\n    private ClientMap clientMap;\r\n\r\n    /**\r\n     * Constructor for Isten.\r\n     * Initializes the physics engine, game renderer, and list of updatables.\r\n     */\r\n    public Isten() {\r\n        inventory=new Inventory(5);\r\n        map=new Map(this, 50, 50, 10);\r\n        chestManager = new ChestManager(175);\r\n        itemManager=new ItemManager();\r\n        inputHandler = new Input();\r\n        camera = new Camera();\r\n        physicsEngine = new PhysicsEngine();\r\n        renderer = new GameRenderer(camera, inputHandler);\r\n        updatables = new ArrayList<>();\r\n        pendingAddedUpdatables = new ArrayList<>();\r\n        pendingRemovedUpdatables = new ArrayList<>();\r\n\r\n        clientMap = new ClientMap();\r\n\r\n        handlerManager = new HandlerManager(this);\r\n        ClientPacketSender.init(this);\r\n    }\r\n\r\n    /**\r\n     * Method to update the game state.\r\n     *\r\n     * @param deltaTime The time elapsed since the last update\r\n     */\r\n    public void update(double deltaTime) {\r\n\r\n\r\n        inputHandler.update();\r\n\r\n        if(socketServer == null || socketServer.isInitialized()) physicsEngine.step(deltaTime);\r\n\r\n\r\n        //remove pending updatables from updatables\r\n        for (Updatable u : pendingRemovedUpdatables)\r\n            if (!u.isDestroyed()) {\r\n                u.setDestroyedTrue();\r\n                u.onDestroy();\r\n            }\r\n        updatables.removeAll(pendingRemovedUpdatables);\r\n        pendingRemovedUpdatables.clear();\r\n\r\n        //add pending updatables to updatables\r\n        updatables.addAll(pendingAddedUpdatables);\r\n        pendingAddedUpdatables.clear();\r\n\r\n        //check if updatable has been initialized\r\n        for (Updatable u : updatables)\r\n            if (!u.isInitialized()) {\r\n                u.setInitializedTrue();\r\n                u.onStart(this);\r\n            }\r\n\r\n\r\n        //call onUpdates\r\n        for (Updatable u : updatables)\r\n            u.onUpdate(this, deltaTime);\r\n\r\n\r\n        //ServerUpdate\r\n        if(socketServer != null) {\r\n            socketServer.updateServer(this, deltaTime);\r\n        }\r\n\r\n\r\n\r\n        //Manage handlers of client\r\n        handlerManager.executeTasks();\r\n\r\n\r\n        //calculate render positions, check for UI inputs and then render\r\n        renderer.calculateRenderedPositions();\r\n        renderer.processUIInputs(inputHandler);\r\n        renderer.repaint();\r\n    }\r\n\r\n    /**\r\n     * Method to initialize the game.\r\n     */\r\n\r\n    public void initMP() {\r\n        //Set localPlayer to true, so that only this player can be moved and followed by the camera on this client\r\n        player = new PlayerMP(PlayerPrefs.getString(\"name\"),null,-1);\r\n\r\n\r\n        player.localPlayer = true;\r\n\r\n        addUpdatables();\r\n        addRenderables();\r\n\r\n        int skinID = PlayerPrefs.getInt(\"skin\");\r\n        player.setSkinID(skinID);\r\n        Packet00Login loginPacket = new Packet00Login(player.getUsername(), 0, 0, skinID);\r\n\r\n        if(socketServer != null) {\r\n            socketServer.addConnection(player,loginPacket);\r\n        }\r\n\r\n        if(JOptionPane.showConfirmDialog(this.getRenderer(), \"Server?\") == 0) {\r\n            socketServer = new GameServer(this);\r\n            socketServer.start();\r\n\r\n        }\r\n        socketClient = new GameClient(this, \"localhost\");\r\n        socketClient.start();\r\n\r\n        loginPacket.writeData(socketClient);\r\n\r\n        update(0);\r\n    }\r\n    public void init() {\r\n        //Create own player\r\n        player = new PlayerMP(PlayerPrefs.getString(\"name\"),null,-1);\r\n\r\n        player.localPlayer = true;\r\n\r\n        addUpdatables();\r\n        addRenderables();\r\n\r\n        int skinID = PlayerPrefs.getInt(\"skin\");\r\n        player.setSkinID(skinID);\r\n        Packet00Login loginPacket = new Packet00Login(player.getUsername(), 0, 0, skinID);\r\n\r\n        if(socketServer != null) {\r\n            socketServer.addConnection(player,loginPacket);\r\n        }\r\n\r\n        socketServer = new GameServer(this);\r\n        socketServer.start();\r\n\r\n        socketClient = new GameClient(this, \"localhost\");\r\n        socketClient.start();\r\n\r\n        loginPacket.writeData(socketClient);\r\n    }\r\n\r\n    /**\r\n     * Method to add renderable objects to the game renderer.\r\n     */\r\n    protected void addRenderables() {\r\n    }\r\n\r\n    /**\r\n     * Method to add updatable objects to the game.\r\n     */\r\n    protected void addUpdatables() {\r\n\r\n        updatables.add(player);\r\n        updatables.add(itemManager);\r\n        updatables.add(inventory);\r\n        updatables.add(map);\r\n        updatables.add(clientMap);\r\n\r\n        updatables.add(chestManager);//majd a játékba nem kell 500 láda, csak szemléltetésképp kell ilyen sok\r\n\r\n\r\n        updatables.add(new TimeCounter());\r\n        updatables.add(new Help());\r\n        updatables.add(new GameMenu());\r\n\r\n        minimap = new Minimap(200,200,20,2);\r\n        updatables.add(minimap);\r\n    }\r\n\r\n    /**\r\n     * Method to get the game renderer.\r\n     *\r\n     * @return The game renderer\r\n     */\r\n    public GameRenderer getRenderer() {\r\n        return renderer;\r\n    }\r\n\r\n    /**\r\n     * returns the physics engine of the isten\r\n     */\r\n    public PhysicsEngine getPhysicsEngine() {\r\n        return physicsEngine;\r\n    }\r\n\r\n    /**\r\n     * returns the inputhandler of the isten\r\n     */\r\n    public Input getInputHandler() {\r\n        return inputHandler;\r\n    }\r\n\r\n    /**\r\n     * returns the camera of the isten\r\n     */\r\n    public Camera getCamera() {\r\n        return this.camera;\r\n    }\r\n\r\n    public Player getPlayer(){return player;}\r\n    public Inventory getInventory(){return inventory;}\r\n    public ItemManager getItemManager(){return itemManager;}\r\n    public Map getMap(){return map;}\r\n\r\n    public void addUpdatable(Updatable u) {\r\n        pendingAddedUpdatables.add(u);\r\n    }\r\n\r\n    public void removeUpdatable(Updatable u) {\r\n        pendingRemovedUpdatables.add(u);\r\n    }\r\n\r\n    public int getPlayerMPIndex(String username) {\r\n        int index = 0;\r\n        for(int i = 0; i < updatables.size(); i++) {\r\n            Updatable u = updatables.get(i);\r\n            if(u instanceof PlayerMP) {\r\n                if(((PlayerMP)u).getUsername().equalsIgnoreCase(username)) {\r\n                    break;\r\n                }\r\n\r\n            }\r\n            index++;\r\n        }\r\n        return index;\r\n    }\r\n\r\n    public int getVillainIndex(String villainName) {\r\n        int index = 0;\r\n        for(int i = 0; i < updatables.size(); i++) {\r\n            Updatable u = updatables.get(i);\r\n            if(u instanceof Villain) {\r\n                if(((Villain)u).getVillainName().equalsIgnoreCase(villainName)) {\r\n                    break;\r\n                }\r\n\r\n            }\r\n            index++;\r\n        }\r\n        return index;\r\n    }\r\n    public Updatable getUpdatable(int index) {\r\n        if(index >= updatables.size()) return null;\r\n        return updatables.get(index);\r\n    }\r\n\r\n    /**\r\n     * returns an ArrayList of updatables of the given type <br>\r\n     * <br>\r\n     * how to use it:\r\n     * ArrayList< Player> alma=new ArrayList<>();\r\n     * alma = isten.getUpdatablesByType(Player.class);\r\n     * @param type the Class of the elements\r\n     * @return an array list of elements\r\n     * @param <E> the type of the queried elements\r\n     */\r\n    public final <E extends Updatable> ArrayList<E> getUpdatablesByType(Class<E> type)\r\n    {\r\n        ArrayList<E> tempList=new ArrayList<>();\r\n        for(int i=0;i<updatables.size();i++)\r\n        {\r\n            if(type.isInstance(updatables.get(i)))\r\n                tempList.add((E)updatables.get(i));\r\n        }\r\n\r\n        return tempList;\r\n    }\r\n\r\n    public GameClient getSocketClient() {\r\n        return socketClient;\r\n    }\r\n\r\n    public ArrayList<Updatable> getUpdatables() {\r\n        return updatables;\r\n    }\r\n\r\n    public GameServer getSocketServer() {\r\n        return socketServer;\r\n    }\r\n\r\n    public HandlerManager getHandlerManager() {\r\n        return handlerManager;\r\n    }\r\n\r\n    public ChestManager getChestManager() { return chestManager; }\r\n    public Minimap getMinimap() {\r\n        return minimap;\r\n    }\r\n\r\n    //ONLY CONTAINS COLLIDERS AND IMAGES OF EDGEPIECES\r\n    public ClientMap getClientMap() {\r\n        return clientMap;\r\n    }\r\n\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/game/Isten.java b/src/main/java/org/game/Isten.java
--- a/src/main/java/org/game/Isten.java	(revision 2a081a32d6cdbb313837c52de84c0543f0763b2d)
+++ b/src/main/java/org/game/Isten.java	(date 1715014570693)
@@ -59,8 +59,8 @@
      */
     public Isten() {
         inventory=new Inventory(5);
-        map=new Map(this, 50, 50, 10);
-        chestManager = new ChestManager(175);
+        map=new Map(this, 50, 50, 4);
+        chestManager = new ChestManager(150);
         itemManager=new ItemManager();
         inputHandler = new Input();
         camera = new Camera();
Index: src/main/java/org/networking/HandlerManager.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package main.java.org.networking;\r\n\r\nimport main.java.org.entities.villain.Villain;\r\nimport main.java.org.game.Graphics.Image;\r\n\r\nimport java.net.InetAddress;\r\nimport java.util.concurrent.locks.Lock;\r\nimport main.java.org.game.Graphics.Text;\r\nimport main.java.org.game.Isten;\r\nimport main.java.org.game.Map.*;\r\nimport main.java.org.game.physics.Collider;\r\nimport main.java.org.game.physics.ColliderGroup;\r\nimport main.java.org.linalg.Vec2;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.Collections;\r\nimport java.util.List;\r\nimport java.util.concurrent.locks.ReentrantLock;\r\nimport java.util.logging.Handler;\r\n\r\npublic class HandlerManager {\r\n\r\n    Isten isten;\r\n\r\n    public HandlerManager(Isten isten) {\r\n        this.isten = isten;\r\n    }\r\n\r\n    private List<TaskType> tasks = new ArrayList<>();\r\n    private List<TaskType> synchronizedTasks = Collections.synchronizedList(tasks);\r\n    private List<HandlerData> handlerDataList = new ArrayList<>();\r\n    private List<HandlerData> synchronizedHandlerDataList = Collections.synchronizedList(handlerDataList);\r\n    public Lock lock = new ReentrantLock();\r\n\r\n    //->>>>>>>>>>>>>>>>//\r\n    //HANDLER DATA\r\n    //->>>>>>>>>>>>>>>>//\r\n    public static abstract class HandlerData {\r\n\r\n    }\r\n\r\n    public static class EdgePieceChangeData extends HandlerData {\r\n        public EdgePieceChangeData(float x, float y, boolean isDoor) {\r\n            this.x = x;\r\n            this.y = y;\r\n            this.isDoor = isDoor;\r\n        }\r\n        public float x;\r\n        public float y;\r\n        public boolean isDoor;\r\n    }\r\n\r\n    public static class WallDeleteData extends HandlerData {\r\n        public WallDeleteData(float x, float y) {\r\n            this.x = x;\r\n            this.y = y;\r\n        }\r\n\r\n        public float x;\r\n        public float y;\r\n    }\r\n\r\n    public static class VillainData extends HandlerData {\r\n        VillainData(String villainName, Vec2 position, String imgPath, int random1, int random2) {\r\n            this.villainName = villainName;\r\n            this.position = position;\r\n            this.imgPath = imgPath;\r\n            this.random1 = random1;\r\n            this.random2 = random2;\r\n        }\r\n\r\n        public String villainName;\r\n        public Vec2 position;\r\n        public String imgPath;\r\n        public int random1;\r\n        public int random2;\r\n    }\r\n\r\n    public static class WallData extends HandlerData {\r\n\r\n        WallData(Vec2 pos, Vec2 scale, boolean isDoor) {\r\n            this.pos = pos;\r\n            this.scale = scale;\r\n            this.isDoor = isDoor;\r\n        }\r\n\r\n        public Vec2 pos;\r\n        public Vec2 scale;\r\n        public boolean isDoor;\r\n    }\r\n\r\n    public static class VillainMoveData extends HandlerData {\r\n        public VillainMoveData(String villainName, Vec2 position) {\r\n            this.villainName = villainName;\r\n            this.position = position;\r\n        }\r\n\r\n        public String villainName;\r\n        public Vec2 position;\r\n    }\r\n\r\n    public static class LoginData extends HandlerData {\r\n        public LoginData(String username, InetAddress inetAddress, int port, Vec2 position, int skinID) {\r\n            this.username = username;\r\n            this.inetAddress = inetAddress;\r\n            this.port = port;\r\n            this.position = position;\r\n            this.skinID = skinID;\r\n        }\r\n\r\n        public String username;\r\n        public Vec2 position;\r\n        public int port;\r\n        public InetAddress inetAddress;\r\n        public int skinID;\r\n    }\r\n\r\n    public static class DoorOpenData extends HandlerData {\r\n        public DoorOpenData(float x, float y, boolean isSolid) {\r\n            this.x = x;\r\n            this.y = y;\r\n            this.isSolid = isSolid;\r\n        }\r\n        public float x;\r\n        public float y;\r\n        public boolean isSolid;\r\n    }\r\n\r\n    //->>>>>>>>>>>>>>>>//\r\n    //EXECUTION\r\n    //->>>>>>>>>>>>>>>>//\r\n    public void executeTasks() {\r\n\r\n        if (synchronizedHandlerDataList.size() != synchronizedTasks.size()) return;\r\n\r\n        while (!synchronizedTasks.isEmpty()) {\r\n\r\n            TaskType task;\r\n            HandlerData data;\r\n\r\n            lock.lock();\r\n            try {\r\n                // Critical section\r\n                // Access shared resources here\r\n                task = getTask();\r\n                data = getHandlerData();\r\n            } finally {\r\n                lock.unlock(); // Release the lock\r\n            }\r\n\r\n            if (task == null || data == null) return;\r\n            switch (task) {\r\n                case Villain: {\r\n                    if (data.getClass() != VillainData.class) return;\r\n                    VillainData villainData = (VillainData) data;\r\n                    villainHandler(villainData);\r\n                    break;\r\n                }\r\n                case VillainMove: {\r\n                    if (data.getClass() != VillainMoveData.class) return;\r\n                    VillainMoveData villainMoveData = (VillainMoveData) data;\r\n                    villainMoveHandler(villainMoveData);\r\n                    break;\r\n                }\r\n                case Wall: {\r\n                    if (data.getClass() != WallData.class) return;\r\n                    WallData wallData = (WallData) data;\r\n                    wallHandler(wallData);\r\n                    break;\r\n                }\r\n                case Login: {\r\n                    if(data.getClass() != LoginData.class) return;\r\n                    LoginData loginData = (LoginData)data;\r\n                    loginHandler(loginData);\r\n                    break;\r\n                }\r\n                case WallDelete: {\r\n                    if(data.getClass() != WallDeleteData.class) return;\r\n                    WallDeleteData wallDeleteData = (WallDeleteData)data;\r\n                    wallDeleteHandler(wallDeleteData);\r\n                    break;\r\n                }\r\n                case EdgePieceChanged: {\r\n                    if(data.getClass() != EdgePieceChangeData.class) return;\r\n                    EdgePieceChangeData edgePieceChangeData = (EdgePieceChangeData)data;\r\n                    edgePieceChangeHandler(edgePieceChangeData);\r\n                    break;\r\n                }\r\n                case DoorOpen: {\r\n                    if(data.getClass() != DoorOpenData.class) return;\r\n                    DoorOpenData doorOpenData = (DoorOpenData)data;\r\n                    doorOpenHandler(doorOpenData);\r\n                    break;\r\n                }\r\n            }\r\n\r\n        }\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    //->>>>>>>>>>>>>>>>//\r\n    //TASKTYPE ENUM\r\n    //->>>>>>>>>>>>>>>>//\r\n    public enum TaskType {\r\n        Villain,\r\n        VillainMove,\r\n        Wall,\r\n        Login,\r\n        WallDelete,\r\n        EdgePieceChanged,\r\n        DoorOpen,\r\n    }\r\n\r\n    synchronized public void addTask(TaskType type) {\r\n        lock.lock();\r\n        try {\r\n            synchronizedTasks.add(type);\r\n        }\r\n        finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n\r\n    synchronized public void addData(HandlerData data) {\r\n        lock.lock();\r\n        try {\r\n            synchronizedHandlerDataList.add(data);\r\n        }\r\n        finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n\r\n    public TaskType getTask() {\r\n        lock.lock();\r\n        try {\r\n            if (tasks.isEmpty()) return null;\r\n            return synchronizedTasks.remove(0);\r\n        }\r\n        finally {\r\n            lock.unlock();\r\n        }\r\n\r\n    }\r\n\r\n    public HandlerData getHandlerData() {\r\n        lock.lock();\r\n        try {\r\n            if (handlerDataList.isEmpty()) return null;\r\n            return synchronizedHandlerDataList.remove(0);\r\n        }\r\n        finally {\r\n            lock.unlock();\r\n        }\r\n\r\n    }\r\n\r\n\r\n    //->>>>>>>>>>>>>>>>//\r\n    //HANDLER FUNCTIONS\r\n    //->>>>>>>>>>>>>>>>//\r\n\r\n    private void doorOpenHandler(DoorOpenData doorOpenData) {\r\n        float x = doorOpenData.x;\r\n        float y = doorOpenData.y;\r\n        boolean isSolid = doorOpenData.isSolid;\r\n\r\n        if(isten.getClientMap().getEdgeBetweenRooms() == null) return;\r\n\r\n        for(int i = 0; i < isten.getClientMap().getEdgeBetweenRooms().getWalls().size(); i++) {\r\n            EdgePiece edgePiece = isten.getClientMap().getEdgeBetweenRooms().getWalls().get(i);\r\n            if(edgePiece.isDoor() && edgePiece.getPosition().x == x && edgePiece.getPosition().y == y) {\r\n                edgePiece.getCollider().setSolidity(isSolid);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    private void wallDeleteHandler(WallDeleteData wallDeleteData) {\r\n\r\n        float x = wallDeleteData.x;\r\n        float y = wallDeleteData.y;\r\n\r\n        if(isten.getClientMap().getEdgeBetweenRooms() == null) return;\r\n\r\n        for(int i = 0; i < isten.getClientMap().getEdgeBetweenRooms().getWalls().size(); i++) {\r\n            EdgePiece edgePiece = isten.getClientMap().getEdgeBetweenRooms().getWalls().get(i);\r\n            if(edgePiece.getPosition().x == x\r\n                    && edgePiece.getPosition().y == y) {\r\n                isten.getClientMap().removeEdgePiece(edgePiece);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    private void wallHandler(WallData wallData) {\r\n        Collider collider = new Collider(wallData.pos, wallData.scale);\r\n\r\n        EdgePiece edgePiece;\r\n\r\n        if (wallData.isDoor) {\r\n            collider.setSolidity(false);\r\n            edgePiece = new Door(collider, collider.getPosition(), null, null);\r\n            edgePiece.setNewImage(\"./assets/doors/doors_leaf_closed.png\", wallData.scale, isten);\r\n\r\n        } else {\r\n            edgePiece = new Wall(collider, collider.getPosition(), null, null);\r\n            edgePiece.setNewImage(\"./assets/walls/wall_mid.png\", wallData.scale, isten);\r\n        }\r\n\r\n        isten.getClientMap().addEdgePiece(edgePiece);\r\n        isten.getClientMap().getEdgeBetweenRooms().addCollider(collider);\r\n\r\n\r\n\r\n    }\r\n\r\n    private void villainHandler(VillainData villainData) {\r\n        Villain villain = new Villain(villainData.villainName, villainData.position, villainData.imgPath);\r\n        //villain.setRoomForVillain(isten.getMap().getRooms(), villainData.random1, villainData.random2);\r\n        isten.addUpdatable(villain);\r\n    }\r\n\r\n    private void villainMoveHandler(VillainMoveData villainMoveData) {\r\n        int index = isten.getVillainIndex(villainMoveData.villainName);\r\n        Villain villain = (Villain) isten.getUpdatable(index);\r\n        if (villain == null) {\r\n            return;\r\n        }\r\n        if (villain.getVillainCollider() != null) {\r\n            Vec2 position = villainMoveData.position;\r\n            villain.getVillainCollider().setPosition(position);\r\n        }\r\n    }\r\n\r\n    private void loginHandler(LoginData loginData) {\r\n        String username = loginData.username;\r\n        InetAddress address = loginData.inetAddress;\r\n        int port = loginData.port;\r\n        Vec2 position = loginData.position;\r\n        int skinID = loginData.skinID;\r\n\r\n        PlayerMP player = new PlayerMP(username, address, port, position);\r\n        player.setSkinID(skinID);\r\n        isten.addUpdatable(player);\r\n    }\r\n\r\n    private void edgePieceChangeHandler(EdgePieceChangeData edgePieceChangeData) {\r\n\r\n        for(int i = 0; i < isten.getClientMap().getEdgeBetweenRooms().getWalls().size(); i++) {\r\n            EdgePiece oldEdgePiece = isten.getClientMap().getEdgeBetweenRooms().getWalls().get(i);\r\n            EdgePiece edgePiece;\r\n\r\n            if(oldEdgePiece.isDoor() != edgePieceChangeData.isDoor\r\n                    && edgePieceChangeData.x == oldEdgePiece.getPosition().x\r\n                    && edgePieceChangeData.y == oldEdgePiece.getPosition().y) {\r\n\r\n                isten.getClientMap().removeEdgePiece(oldEdgePiece);\r\n\r\n                Collider collider = new Collider(oldEdgePiece.getCollider().getPosition(), oldEdgePiece.getCollider().getScale());\r\n                isten.getClientMap().getEdgeBetweenRooms().addCollider(collider);\r\n\r\n                if (edgePieceChangeData.isDoor) {\r\n                    collider.setSolidity(false);\r\n\r\n                    edgePiece = new Door(collider, collider.getPosition(), null, null);\r\n                    edgePiece.setNewImage(\"./assets/doors/doors_leaf_closed.png\", oldEdgePiece.getCollider().getScale(), isten);\r\n                }\r\n                else {\r\n                    collider.setSolidity(true);\r\n                    edgePiece = new Wall(collider, collider.getPosition(), null, null);\r\n                    edgePiece.setNewImage(\"./assets/walls/wall_mid.png\", oldEdgePiece.getCollider().getScale(), isten);\r\n                }\r\n\r\n                isten.getClientMap().addEdgePiece(edgePiece);\r\n                break;\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/networking/HandlerManager.java b/src/main/java/org/networking/HandlerManager.java
--- a/src/main/java/org/networking/HandlerManager.java	(revision 2a081a32d6cdbb313837c52de84c0543f0763b2d)
+++ b/src/main/java/org/networking/HandlerManager.java	(date 1715016539300)
@@ -1,5 +1,6 @@
 package main.java.org.networking;
 
+import main.java.org.entities.player.Player;
 import main.java.org.entities.villain.Villain;
 import main.java.org.game.Graphics.Image;
 
@@ -10,6 +11,7 @@
 import main.java.org.game.Map.*;
 import main.java.org.game.physics.Collider;
 import main.java.org.game.physics.ColliderGroup;
+import main.java.org.game.updatable.Updatable;
 import main.java.org.linalg.Vec2;
 
 import java.util.ArrayList;
@@ -39,6 +41,14 @@
 
     }
 
+    public static class UnitRoomData extends HandlerData {
+        public UnitRoomData(Vec2 position, String path) {
+            this.position = position;
+            this.path = path;
+        }
+        public Vec2 position;
+        public String path;
+    }
     public static class EdgePieceChangeData extends HandlerData {
         public EdgePieceChangeData(float x, float y, boolean isDoor) {
             this.x = x;
@@ -126,6 +136,17 @@
         public boolean isSolid;
     }
 
+    public static class InGasRoomData extends HandlerData {
+        public InGasRoomData(float x, float y, boolean isInGasRoom) {
+            this.x = x;
+            this.y = y;
+            this.isInGasRoom = isInGasRoom;
+        }
+        public float x;
+        public float y;
+        public boolean isInGasRoom;
+    }
+
     //->>>>>>>>>>>>>>>>//
     //EXECUTION
     //->>>>>>>>>>>>>>>>//
@@ -192,13 +213,24 @@
                     doorOpenHandler(doorOpenData);
                     break;
                 }
-            }
-
-        }
+                case UnitRoom:
+                {
+                    if(data.getClass() != UnitRoomData.class) return;
+                    UnitRoomData unitRoomData = (UnitRoomData)data;
+                    unitRoomHandler(unitRoomData);
+                    break;
+                }
+                case InGasRoom: {
+                    if(data.getClass() != InGasRoomData.class) return;
+                    InGasRoomData inGasRoomData = (InGasRoomData)data;
+                    inGasRoomHandler(inGasRoomData);
+                    break;
+                }
+            }
 
+        }
 
     }
-
 
 
     //->>>>>>>>>>>>>>>>//
@@ -212,6 +244,7 @@
         WallDelete,
         EdgePieceChanged,
         DoorOpen,
+        UnitRoom, InGasRoom,
     }
 
     synchronized public void addTask(TaskType type) {
@@ -263,6 +296,22 @@
     //HANDLER FUNCTIONS
     //->>>>>>>>>>>>>>>>//
 
+    private void unitRoomHandler(UnitRoomData unitRoomData) {
+        Vec2 position = unitRoomData.position;
+        String path = unitRoomData.path;
+
+        Map map = isten.getMap();
+
+        for(int i = 0; i < map.getMapRowSize(); i++) {
+            for(int j = 0; j < map.getMapColumnSize(); j++) {
+                if(map.getUnitRooms()[i][j].getPosition().x == position.x &&
+                        map.getUnitRooms()[i][j].getPosition().y == position.y) {
+                    map.getUnitRooms()[i][j].setNewImage(path, isten);
+                }
+            }
+        }
+    }
+
     private void doorOpenHandler(DoorOpenData doorOpenData) {
         float x = doorOpenData.x;
         float y = doorOpenData.y;
@@ -381,5 +430,21 @@
 
         }
 
+
+    }
+
+    private void inGasRoomHandler(InGasRoomData inGasRoomData) {
+        float x = inGasRoomData.x;
+        float y = inGasRoomData.y;
+        boolean isInGasRoom = inGasRoomData.isInGasRoom;
+
+        for(Updatable updatable: isten.getUpdatables()) {
+
+            if(updatable.getClass() == PlayerMP.class ) {
+                PlayerMP player = (PlayerMP)updatable;
+                if(player.getPlayerCollider().getPosition().x == x
+                        && player.getPlayerCollider().getPosition().y == y) player.isInGasRoom(isInGasRoom);
+            }
+        }
     }
 }
\ No newline at end of file
Index: src/main/java/org/networking/GameClient.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package main.java.org.networking;\r\n\r\nimport main.java.org.game.Isten;\r\nimport main.java.org.game.Map.EdgePiece;\r\nimport main.java.org.game.Map.Map;\r\nimport main.java.org.game.UI.TimeCounter;\r\nimport main.java.org.game.physics.Collider;\r\nimport main.java.org.game.physics.ColliderGroup;\r\nimport main.java.org.items.Chest;\r\nimport main.java.org.items.ChestManager;\r\nimport main.java.org.items.Item;\r\nimport main.java.org.items.ItemManager;\r\nimport main.java.org.linalg.Vec2;\r\n\r\nimport java.io.IOException;\r\nimport java.net.*;\r\n\r\npublic class GameClient extends Thread {\r\n    private InetAddress ipAddress;\r\n    private DatagramSocket socket;\r\n    Isten isten;\r\n\r\n    public GameClient(Isten isten, String ipAddress) {\r\n        this.isten = isten;\r\n        try {\r\n            this.socket = new DatagramSocket();\r\n            this.ipAddress = InetAddress.getByName(ipAddress);\r\n        }\r\n        catch(SocketException e) {\r\n            e.printStackTrace();\r\n        }\r\n        catch(UnknownHostException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n    public void run() {\r\n        while(true) {\r\n            byte[] data = new byte[1024];\r\n            DatagramPacket packet = new DatagramPacket(data, data.length);\r\n            try {\r\n                socket.receive(packet);\r\n            } catch (IOException e) {\r\n                throw new RuntimeException(e);\r\n            }\r\n            parsePacket(packet.getData(), packet.getAddress(), packet.getPort());\r\n\r\n        }\r\n    }\r\n\r\n    private void parsePacket(byte[] data, InetAddress address, int port) {\r\n        String message = new String(data).trim();\r\n        Packet.PacketTypes type = Packet.lookupPacket(message.substring(0,2));\r\n        Packet packet = null;\r\n        switch(type) {\r\n            default:\r\n                break;\r\n            case INVALID:\r\n                break;\r\n            case LOGIN:\r\n                packet = new Packet00Login(data);\r\n                handleLogin((Packet00Login) packet, address, port);\r\n                break;\r\n            case DISCONNECT:\r\n                break;\r\n            case MOVE:\r\n                packet = new Packet02Move(data);\r\n                handleMove((Packet02Move) packet);\r\n                break;\r\n            case ANIMATION:\r\n                packet = new Packet03Animation(data);\r\n                handleAnimation((Packet03Animation)packet);\r\n                break;\r\n            case UNITROOM:\r\n                packet = new Packet04UnitRoom(data);\r\n                handleUnitRoom((Packet04UnitRoom)packet);\r\n                break;\r\n            case VILLAIN:\r\n                packet = new Packet05Villain(data);\r\n                handleVillain((Packet05Villain)packet);\r\n                break;\r\n            case VILLAINMOVE:\r\n                packet = new Packet06VillainMove(data);\r\n                handleVillainMove((Packet06VillainMove) packet);\r\n                break;\r\n            case TIMER:\r\n                packet = new Packet07Timer(data);\r\n                handleTimer((Packet07Timer)packet);\r\n                break;\r\n            case CHESTGENERATION:\r\n                packet = new Packet10ChestGeneration(data);\r\n                handleChestGeneration((Packet10ChestGeneration) packet);\r\n                break;\r\n            case CHESTOPENED:\r\n                packet = new Packet11ChestOpened(data);\r\n                handleChestOpened((Packet11ChestOpened) packet);\r\n                break;\r\n            case ITEMPICKEDUP:\r\n                packet = new Packet12ItemPickedUp(data);\r\n                handleItemPickedUp((Packet12ItemPickedUp) packet);\r\n                break;\r\n            case ITEMDROPPED:\r\n                packet = new Packet13ItemDropped(data);\r\n                handleItemDropped((Packet13ItemDropped) packet);\r\n                break;\r\n            case GASMASK:\r\n                packet = new Packet14Gasmask(data);\r\n                handleGasmask((Packet14Gasmask) packet);\r\n                break;\r\n            case WALL:\r\n                //System.out.println(\"GOT WALL PACKET\");\r\n                packet = new Packet20Wall(data);\r\n                handleWall((Packet20Wall) packet);\r\n                break;\r\n            case DEATH:\r\n                packet = new Packet21Death(data);\r\n                handleDeath((Packet21Death)packet);\r\n                break;\r\n            case EDGEPIECECHANGED:\r\n                packet = new Packet22EdgePieceChanged(data);\r\n                handleEdgePieceChanged((Packet22EdgePieceChanged)packet);\r\n                break;\r\n            case WALLDELETE:\r\n                packet = new Packet23WallDelete(data);\r\n                handleWallDelete((Packet23WallDelete)packet);\r\n                break;\r\n            case DOOROPEN:\r\n                packet = new Packet24DoorOpen(data);\r\n                handleDoorOpen((Packet24DoorOpen)packet);\r\n                break;\r\n        }\r\n    }\r\n\r\n    private void handleGasmask(Packet14Gasmask packet) {\r\n        for(int i = 0; i < isten.getUpdatables().size(); i++) {\r\n            if(isten.getUpdatable(i).getClass() == ItemManager.class) {\r\n                isten.getUpdatables().get(i).getItems().get(packet.getItemIndex()).setCapacity(packet.getCapacity());\r\n                isten.getUpdatables().get(i).getItems().get(packet.getItemIndex()).resizeBar(packet.getCapacity());\r\n            }\r\n        }\r\n    }\r\n\r\n    private void handleDoorOpen(Packet24DoorOpen packet) {\r\n        float x = packet.getX();\r\n        float y = packet.getY();\r\n        boolean isSolid = packet.isSolid();\r\n\r\n        HandlerManager hm = isten.getHandlerManager();\r\n        hm.lock.lock();\r\n        try {\r\n            // Critical section\r\n            // Access shared resources here\r\n            hm.addTask(HandlerManager.TaskType.DoorOpen);\r\n            hm.addData(new HandlerManager.DoorOpenData(x,y, isSolid));\r\n        } finally {\r\n            hm.lock.unlock(); // Release the lock\r\n        }\r\n    }\r\n\r\n    private void handleEdgePieceChanged(Packet22EdgePieceChanged packet) {\r\n\r\n        float x = packet.getX();\r\n        float y = packet.getY();\r\n        boolean isDoor = packet.isDoor();\r\n\r\n        HandlerManager hm = isten.getHandlerManager();\r\n        hm.lock.lock();\r\n        try {\r\n            // Critical section\r\n            // Access shared resources here\r\n            hm.addTask(HandlerManager.TaskType.EdgePieceChanged);\r\n            hm.addData(new HandlerManager.EdgePieceChangeData(x,y, isDoor));\r\n        } finally {\r\n            hm.lock.unlock(); // Release the lock\r\n        }\r\n\r\n    }\r\n\r\n    private void handleWallDelete(Packet23WallDelete packet) {\r\n\r\n        float x = packet.getX();\r\n        float y = packet.getY();\r\n\r\n        HandlerManager hm = isten.getHandlerManager();\r\n        hm.lock.lock();\r\n        try {\r\n            // Critical section\r\n            // Access shared resources here\r\n            hm.addTask(HandlerManager.TaskType.WallDelete);\r\n            hm.addData(new HandlerManager.WallDeleteData(x,y));\r\n        } finally {\r\n            hm.lock.unlock(); // Release the lock\r\n        }\r\n\r\n    }\r\n\r\n    private void handleItemDropped(Packet13ItemDropped packet) {\r\n        for(int i = 0; i < isten.getUpdatables().size(); i++) {\r\n            if(isten.getUpdatable(i).getClass() == ItemManager.class) {\r\n                isten.getUpdatables().get(i).getItems().get(packet.getItemIndex()).setLocation(Item.Location.GROUND);\r\n                isten.getUpdatables().get(i).getItems().get(packet.getItemIndex()).getImage().setVisibility(true);\r\n                isten.getUpdatables().get(i).getItems().get(packet.getItemIndex()).getImage().setPosition(packet.getPos());\r\n                isten.getUpdatables().get(i).getItems().get(packet.getItemIndex()).setPosition(packet.getPos());\r\n            }\r\n        }\r\n    }\r\n\r\n    private void handleItemPickedUp(Packet12ItemPickedUp packet) {\r\n        for(int i = 0; i < isten.getUpdatables().size(); i++) {\r\n            if(isten.getUpdatable(i).getClass() == ItemManager.class) {\r\n                isten.getUpdatables().get(i).getItems().get(packet.getItemIndex()).setLocation(Item.Location.INVENTORY);\r\n                isten.getUpdatables().get(i).getItems().get(packet.getItemIndex()).getImage().setVisibility(false);\r\n            }\r\n        }\r\n    }\r\n\r\n    private void handleChestOpened(Packet11ChestOpened packet) {\r\n        for(int i = 0; i < isten.getUpdatables().size(); i++) {\r\n            if(isten.getUpdatable(i).getClass() == ChestManager.class) {\r\n                isten.getUpdatables().get(i).getChests().get(packet.getChestIndex()).open();\r\n            }\r\n        }\r\n    }\r\n\r\n    private int chestGenCount = 0;\r\n    private void handleChestGeneration(Packet10ChestGeneration packet) {\r\n        if(isten.getSocketServer() != null) return;\r\n\r\n        int chestIndex = 0;\r\n        for(int i = 0; i < isten.getUpdatables().size(); i++) {\r\n            if(isten.getUpdatable(i).getClass() == ChestManager.class) {\r\n                chestIndex = i;\r\n                isten.getUpdatables().get(i).getChests().add(new Chest(packet.getPos(),isten,packet.getHeading(), packet.getChestType()));\r\n                chestGenCount++;\r\n            }\r\n        }\r\n\r\n        ColliderGroup chestColliders=new ColliderGroup();\r\n        for (int i = 0; i < isten.getUpdatables().get(chestIndex).getChests().size(); i++) {\r\n            Collider c=new Collider( isten.getUpdatables().get(chestIndex).getChests().get(i).getPosition(),new Vec2(0.15f,0.15f));\r\n            chestColliders.addCollider(c);\r\n        }\r\n        isten.getPhysicsEngine().addColliderGroup(chestColliders);\r\n    }\r\n\r\n    private void handleDeath(Packet21Death packet) {\r\n        String username = packet.getUsername();\r\n\r\n        for(int i = 0; i < isten.getUpdatables().size(); i++) {\r\n            if(isten.getUpdatable(i).getClass() == PlayerMP.class) {\r\n                PlayerMP playerMP = (PlayerMP)isten.getUpdatable(i);\r\n                if(playerMP.getUsername().equalsIgnoreCase(username)) {\r\n                    playerMP.setAlive(false);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private void handleWall(Packet20Wall packet) {\r\n\r\n        //if(isten.getSocketServer() != null) return;\r\n\r\n        Vec2 pos = new Vec2(packet.getPosX(), packet.getPosY());\r\n        Vec2 scale = new Vec2(packet.getScaleX(), packet.getScaleY());\r\n        boolean isDoor = packet.isDoor();\r\n\r\n        HandlerManager hm = isten.getHandlerManager();\r\n        hm.lock.lock();\r\n            try {\r\n                // Critical section\r\n                // Access shared resources here\r\n                hm.addTask(HandlerManager.TaskType.Wall);\r\n                hm.addData(new HandlerManager.WallData(pos, scale, isDoor));\r\n            } finally {\r\n                hm.lock.unlock(); // Release the lock\r\n            }\r\n    }\r\n\r\n    private void handleUnitRoom(Packet04UnitRoom packet) {\r\n        Vec2 position = new Vec2(packet.getX(), packet.getY());\r\n        int type = packet.getType();\r\n        String path = \"./assets/floors/floor\" + (type+1) + \".png\";\r\n        Map map = isten.getMap();\r\n        for(int i = 0; i < map.getMapRowSize(); i++) {\r\n            for(int j = 0; j < map.getMapColumnSize(); j++) {\r\n                if(map.getUnitRooms()[i][j].getPosition().x == position.x &&\r\n                map.getUnitRooms()[i][j].getPosition().y == position.y) {\r\n                    map.getUnitRooms()[i][j].setNewImage(path, isten);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private void handleTimer(Packet07Timer packet) {\r\n        double timeRemaining = packet.getTimeRemaining();\r\n        TimeCounter.setTimeRemaining(timeRemaining);\r\n    }\r\n\r\n    private void handleVillainMove(Packet06VillainMove packet) {\r\n        String villainName = packet.getVillainName();\r\n        Vec2 position = new Vec2(packet.getX(), packet.getY());\r\n\r\n        HandlerManager hm = isten.getHandlerManager();\r\n        hm.lock.lock();\r\n            try {\r\n                // Critical section\r\n                // Access shared resources here\r\n                hm.addTask(HandlerManager.TaskType.VillainMove);\r\n                hm.addData(new HandlerManager.VillainMoveData(villainName, position));\r\n            } finally {\r\n                hm.lock.unlock(); // Release the lock\r\n            }\r\n    }\r\n\r\n    private void handleVillain(Packet05Villain packet) {\r\n        String villainName = packet.getVillainName();\r\n        Vec2 position = packet.getPosition();\r\n        String imagePath = packet.getImagePath();\r\n        int random1 = packet.getRandom1();\r\n        int random2 = packet.getRandom2();\r\n\r\n        HandlerManager hm = isten.getHandlerManager();\r\n        hm.lock.lock();\r\n            try {\r\n                // Critical section\r\n                // Access shared resources here\r\n                hm.addTask(HandlerManager.TaskType.Villain);\r\n                hm.addData(new HandlerManager.VillainData(villainName, position, imagePath, random1, random2));\r\n            } finally {\r\n                hm.lock.unlock(); // Release the lock\r\n            }\r\n    }\r\n\r\n    private void handleAnimation(Packet03Animation packet) {\r\n        int index = isten.getPlayerMPIndex(packet.getUsername());\r\n        PlayerMP player = (PlayerMP)isten.getUpdatable(index);\r\n        if(player == null || player.localPlayer || player.getPlayerImage() == null) return;\r\n        for(int i = 0; i < player.getPlayerImage().size(); i++) {\r\n            player.getPlayerImage().get(i).setVisibility(false);\r\n        }\r\n        player.setActiveImage(packet.getActiveImage());\r\n        if(!player.getPlayerImage().isEmpty() && packet.getActiveImage() < player.getPlayerImage().size()) player.getPlayerImage().get(packet.getActiveImage()).setVisibility(true);\r\n    }\r\n\r\n    private void handleLogin(Packet00Login packet, InetAddress address, int port) {\r\n        PlayerMP player = null;\r\n        Vec2 position = new Vec2(packet.getX(), packet.getY());\r\n        String username = packet.getUsername();\r\n        int skinID = packet.getSkinID();\r\n\r\n        HandlerManager hm = isten.getHandlerManager();\r\n        hm.lock.lock();\r\n        try {\r\n            hm.addTask(HandlerManager.TaskType.Login);\r\n            hm.addData(new HandlerManager.LoginData(username, address, port, position, skinID));\r\n        }\r\n        finally {\r\n            hm.lock.unlock();\r\n        }\r\n    }\r\n\r\n    private void handleMove(Packet02Move packet) {\r\n        String username = packet.getUsername();\r\n\r\n        int index = isten.getPlayerMPIndex(username);\r\n        PlayerMP player = (PlayerMP)isten.getUpdatable(index);\r\n        if(player == null) return;\r\n        if(player.getPlayerCollider() != null) player.getPlayerCollider().setPosition(new Vec2(packet.getX(), packet.getY()));\r\n    }\r\n\r\n    public void sendData(byte[] data) {\r\n        DatagramPacket packet = new DatagramPacket(data, data.length, ipAddress, 1331);\r\n        try {\r\n            socket.send(packet);\r\n        } catch (IOException e) {\r\n            throw new RuntimeException(e);\r\n        }\r\n    }\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/networking/GameClient.java b/src/main/java/org/networking/GameClient.java
--- a/src/main/java/org/networking/GameClient.java	(revision 2a081a32d6cdbb313837c52de84c0543f0763b2d)
+++ b/src/main/java/org/networking/GameClient.java	(date 1715014436104)
@@ -128,6 +128,27 @@
                 packet = new Packet24DoorOpen(data);
                 handleDoorOpen((Packet24DoorOpen)packet);
                 break;
+            case INGASROOM:
+                packet = new Packet26InGasRoom(data);
+                handleInGasRoom((Packet26InGasRoom)packet);
+                break;
+        }
+    }
+
+    private void handleInGasRoom(Packet26InGasRoom packet) {
+        float x = packet.getX();
+        float y = packet.getY();
+        boolean isInGasRoom = packet.isInGasRoom();
+
+        HandlerManager hm = isten.getHandlerManager();
+        hm.lock.lock();
+        try {
+            // Critical section
+            // Access shared resources here
+            hm.addTask(HandlerManager.TaskType.InGasRoom);
+            hm.addData(new HandlerManager.InGasRoomData(x,y, isInGasRoom));
+        } finally {
+            hm.lock.unlock(); // Release the lock
         }
     }
 
@@ -280,14 +301,16 @@
         Vec2 position = new Vec2(packet.getX(), packet.getY());
         int type = packet.getType();
         String path = "./assets/floors/floor" + (type+1) + ".png";
-        Map map = isten.getMap();
-        for(int i = 0; i < map.getMapRowSize(); i++) {
-            for(int j = 0; j < map.getMapColumnSize(); j++) {
-                if(map.getUnitRooms()[i][j].getPosition().x == position.x &&
-                map.getUnitRooms()[i][j].getPosition().y == position.y) {
-                    map.getUnitRooms()[i][j].setNewImage(path, isten);
-                }
-            }
+
+        HandlerManager hm = isten.getHandlerManager();
+        hm.lock.lock();
+        try {
+            // Critical section
+            // Access shared resources here
+            hm.addTask(HandlerManager.TaskType.UnitRoom);
+            hm.addData(new HandlerManager.UnitRoomData(position, path));
+        } finally {
+            hm.lock.unlock(); // Release the lock
         }
     }
 
Index: src/main/java/org/networking/Packet.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package main.java.org.networking;\r\n\r\npublic abstract class Packet {\r\n    public static enum PacketTypes {\r\n        INVALID(-1),\r\n        LOGIN(00),\r\n        DISCONNECT(01),\r\n        MOVE(02),\r\n        ANIMATION(03),\r\n        UNITROOM(04),\r\n        VILLAIN(05),\r\n        VILLAINMOVE(06),\r\n        TIMER(07),\r\n        CHESTGENERATION(10),\r\n        CHESTOPENED(11),\r\n        ITEMPICKEDUP(12),\r\n        ITEMDROPPED(13),\r\n        GASMASK(14),\r\n        WALL(20),\r\n        DEATH(21),\r\n        EDGEPIECECHANGED(22),\r\n        WALLDELETE(23),\r\n        DOOROPEN(24),\r\n        PLAYERPOSFORDOOROPEN(25);\r\n        private int packetId;\r\n        private PacketTypes(int packetId) {\r\n            this.packetId = packetId;\r\n        }\r\n\r\n        public int getId() {\r\n            return packetId;\r\n        }\r\n    }\r\n\r\n\r\n    public byte packetId;\r\n\r\n    public Packet(int packetId) {\r\n        this.packetId = (byte)packetId;\r\n    }\r\n\r\n    public abstract void writeData(GameClient client);\r\n    public abstract void writeData(GameServer server);\r\n\r\n    public String readData(byte[] data) {\r\n        String message = new String(data).trim();\r\n        //System.out.println(message);\r\n        return message.substring(2);\r\n    }\r\n\r\n\r\n    public static PacketTypes lookupPacket(String packetId) {\r\n        try {\r\n            return lookupPacket(Integer.parseInt(packetId));\r\n        }\r\n        catch(NumberFormatException e) {\r\n            return PacketTypes.INVALID;\r\n        }\r\n\r\n    }\r\n    public static PacketTypes lookupPacket(int id) {\r\n        for(PacketTypes p: PacketTypes.values()) {\r\n            if(p.getId() == id) {\r\n                return p;\r\n            }\r\n        }\r\n        return PacketTypes.INVALID;\r\n    }\r\n\r\n\r\n    public abstract byte[] getData();\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/networking/Packet.java b/src/main/java/org/networking/Packet.java
--- a/src/main/java/org/networking/Packet.java	(revision 2a081a32d6cdbb313837c52de84c0543f0763b2d)
+++ b/src/main/java/org/networking/Packet.java	(date 1715013292588)
@@ -21,7 +21,8 @@
         EDGEPIECECHANGED(22),
         WALLDELETE(23),
         DOOROPEN(24),
-        PLAYERPOSFORDOOROPEN(25);
+        PLAYERPOSFORDOOROPEN(25),
+        INGASROOM(26);
         private int packetId;
         private PacketTypes(int packetId) {
             this.packetId = packetId;
Index: src/main/java/org/networking/DeathHandler.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/networking/DeathHandler.java b/src/main/java/org/networking/PlayerStatusHandler.java
rename from src/main/java/org/networking/DeathHandler.java
rename to src/main/java/org/networking/PlayerStatusHandler.java
--- a/src/main/java/org/networking/DeathHandler.java	(revision 2a081a32d6cdbb313837c52de84c0543f0763b2d)
+++ b/src/main/java/org/networking/PlayerStatusHandler.java	(date 1715016278613)
@@ -1,11 +1,11 @@
 package main.java.org.networking;
 
-import main.java.org.entities.player.Player;
 import main.java.org.game.Isten;
+import main.java.org.game.Map.Room;
+import main.java.org.game.Map.RoomType;
+import main.java.org.game.Map.UnitRoom;
 
-import java.util.ArrayList;
-
-public class DeathHandler extends ServerSideHandler {
+public class PlayerStatusHandler extends ServerSideHandler {
 
     private double currTime = 0;
     private void checkIfPlayerInRoomWithVillain(PlayerMP player,double deltaTime) {
@@ -18,6 +18,19 @@
         }
     }
 
+    private void checkIfPlayerInGasRoom(PlayerMP player){
+        if(player.getCurrentRoom() != null && player.getCurrentRoom().getRoomType() == RoomType.GAS) {
+            Packet26InGasRoom packet = new Packet26InGasRoom(player.getPlayerCollider().getPosition().x,
+                    player.getPlayerCollider().getPosition().y, true);
+            sendDataToAllClients(packet);
+        }
+        else {
+            Packet26InGasRoom packet = new Packet26InGasRoom(player.getPlayerCollider().getPosition().x,
+                    player.getPlayerCollider().getPosition().y, false);
+            //sendDataToAllClients(packet);
+        }
+    }
+
     @Override
     public void create(GameServer server) {
         this.server = server;
@@ -46,7 +59,18 @@
             for(int i = 0; i < isten.getUpdatables().size(); i++) {
                 if(isten.getUpdatable(i).getClass() == PlayerMP.class) {
                     PlayerMP player = (PlayerMP)isten.getUpdatable(i);
+                    for (Room room : isten.getMap().getRooms()) {
+                        for (UnitRoom unitRoom : room.getUnitRooms()) {
+                            if (player.getPlayerCollider().getPosition().x >= unitRoom.getPosition().x - 0.5 &&
+                                    player.getPlayerCollider().getPosition().x <= unitRoom.getPosition().x + 0.5 &&
+                                    player.getPlayerCollider().getPosition().y >= unitRoom.getPosition().y - 0.5 &&
+                                    player.getPlayerCollider().getPosition().y <= unitRoom.getPosition().y + 0.5) {
+                                player.currentRoom = room;
+                            }
+                        }
+                    }
                     checkIfPlayerInRoomWithVillain(player,deltaTime);
+                    checkIfPlayerInGasRoom(player);
                 }
             }
         }
Index: src/main/java/org/entities/villain/Villain.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package main.java.org.entities.villain;\r\n\r\nimport main.java.org.entities.Entity;\r\nimport main.java.org.game.Graphics.Image;\r\nimport main.java.org.game.Graphics.Text;\r\nimport main.java.org.game.Isten;\r\nimport main.java.org.game.Map.RoomType;\r\nimport main.java.org.game.Map.UnitRoom;\r\nimport main.java.org.game.physics.Collider;\r\nimport main.java.org.linalg.Vec2;\r\n\r\nimport main.java.org.game.Map.Map;\r\nimport main.java.org.game.Map.Room;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.Collections;\r\n\r\nimport java.util.Random;\r\n\r\n/**\r\n * The villain class, makes almost everything related to the villain.\r\n */\r\npublic class Villain extends Entity {\r\n    static ArrayList<Room> roomsWithVillains = new ArrayList<>();\r\n    Image villainImage;\r\n    static ArrayList<Image> faintedVillainImages=new ArrayList<>();\r\n    Collider villainCollider;\r\n    Text villainName;\r\n    double timeElapsed;\r\n    int direction;\r\n    Vec2 position;\r\n    String imagePath;\r\n    float velocity;\r\n    double sum;\r\n    Room room;\r\n    boolean isFainted;\r\n    UnitRoom currentUnitRoom;\r\n    UnitRoom prevUnitRoom;\r\n    private int random1, random2;\r\n\r\n    public Villain() {\r\n        villainCollider = null;\r\n        villainImage = null;\r\n        timeElapsed = 0;\r\n        villainName = null;\r\n        direction=1;\r\n        velocity = 0.5f;\r\n        sum = 0.0;\r\n        room = null;\r\n        isFainted=false;\r\n    }\r\n    public Villain(String name, String iP) {\r\n        this(name, new Vec2(0,0), iP);\r\n    }\r\n\r\n    public Villain(String name, Vec2 pos, String iP) {\r\n        villainCollider = null;\r\n        villainImage = null;\r\n        timeElapsed = 0;\r\n        villainName = new Text(name, new Vec2(0, 0), \"./assets/Monocraft.ttf\", 15, 255, 0, 0);\r\n        villainName.setShadowOn(false);\r\n        direction=1;\r\n        position = pos;\r\n        imagePath = iP;\r\n        velocity = 0.5f;\r\n        sum = 0.0;\r\n        room = null;\r\n\r\n    }\r\n    @Override\r\n    public void onStart(Isten isten) {\r\n        Vec2 playerScale = new Vec2(0.6f, 0.6f);\r\n\r\n        villainCollider = new Collider(position, playerScale);\r\n        villainCollider.setMovability(true);\r\n        isten.getPhysicsEngine().addCollider(villainCollider);//register collider in the physics engine\r\n\r\n        villainImage = new Image(new Vec2(), playerScale, imagePath);\r\n        faintedVillainImages.add(new Image(new Vec2(),new Vec2(0.7f, 0.7f),imagePath.substring(0,imagePath.length()-4)+\"_fainted1.png\"));\r\n        faintedVillainImages.add(new Image(new Vec2(),new Vec2(0.7f, 0.7f),imagePath.substring(0,imagePath.length()-4)+\"_fainted2.png\"));\r\n        //System.out.println(imagePath.substring(0,imagePath.length()-4)+\"_fainted1.png\");\r\n        villainImage.setSortingLayer(-50);\r\n        faintedVillainImages.get(0).setSortingLayer(-40);faintedVillainImages.get(1).setSortingLayer(-40);\r\n        villainImage.setVisibility(true);\r\n        isten.getRenderer().addRenderable(villainImage);//register images in the renderer\r\n        isten.getRenderer().addRenderable(faintedVillainImages.get(0));//register images in the renderer\r\n        isten.getRenderer().addRenderable(faintedVillainImages.get(1));//register images in the renderer\r\n\r\n        if (villainName != null) {\r\n            villainName.setVisibility(true);\r\n            villainName.setSortingLayer(-50);\r\n            isten.getRenderer().addRenderable(villainName);\r\n        }\r\n        //isten.getCamera().setPixelsPerUnit(100);\r\n\r\n        Map map = isten.getMap();\r\n\r\n        for (Room room : map.getRooms()) {\r\n            for (UnitRoom unitRoom : room.getUnitRooms()) {\r\n                if (position.x >= unitRoom.getPosition().x - 0.5 &&\r\n                        position.x <= unitRoom.getPosition().x + 0.5 &&\r\n                        position.y >= unitRoom.getPosition().y - 0.5 &&\r\n                        position.y <= unitRoom.getPosition().y + 0.5) {\r\n                    currentUnitRoom = unitRoom;\r\n                }\r\n            }\r\n        }\r\n        prevUnitRoom = currentUnitRoom;\r\n    }\r\n\r\n    @Override\r\n    public void onUpdate(Isten isten, double deltaTime) {\r\n        timeElapsed+=deltaTime;\r\n        Vec2 playerPosition = villainCollider.getPosition();\r\n        //villainImage.setPosition(playerPosition);\r\n        faintedVillainImages.get(0).setPosition(playerPosition);\r\n        faintedVillainImages.get(0).setPosition(playerPosition);\r\n        villainName.setPosition(Vec2.sum(playerPosition, new Vec2(0, (float) 0.5)));\r\n        if(isFainted) {\r\n            if ((timeElapsed*1000000) % 1000000 < 500000) {\r\n                setVillainImage(isten,faintedVillainImages.get(0));\r\n            }\r\n            else {\r\n                setVillainImage(isten,faintedVillainImages.get(1));\r\n            }\r\n        }\r\n    }\r\n    public boolean isInGasRoom(Isten isten)\r\n    {\r\n        Room currentRoom = null;\r\n        for (Room room : isten.getMap().getRooms()) {\r\n            for (UnitRoom unitRoom : room.getUnitRooms()) {\r\n                if (villainCollider.getPosition().x >= unitRoom.getPosition().x - 0.5 &&\r\n                        villainCollider.getPosition().x <= unitRoom.getPosition().x + 0.5 &&\r\n                        villainCollider.getPosition().y >= unitRoom.getPosition().y - 0.5 &&\r\n                        villainCollider.getPosition().y <= unitRoom.getPosition().y + 0.5) {\r\n                    currentRoom = room;\r\n                }\r\n            }\r\n        }\r\n        if(currentRoom!= null && currentRoom.getRoomType()== RoomType.GAS)return true;\r\n        else return false;\r\n    }\r\n    public void move(Isten isten, double deltaTime) {\r\n        if(!isInGasRoom(isten)/*&&!isFainted*/) {\r\n            sum += deltaTime;\r\n            Vec2 playerPosition = villainCollider.getPosition();\r\n            Random random = new Random();\r\n            villainImage.setPosition(playerPosition);\r\n            //faintedVillainImages.get(0).setPosition(playerPosition);\r\n            //faintedVillainImages.get(1).setPosition(playerPosition);\r\n            villainName.setPosition(Vec2.sum(playerPosition, new Vec2(0, (float) 0.5)));\r\n\r\n\r\n            if (sum < 2) return;\r\n            Map map = isten.getMap();\r\n\r\n            for (Room room : map.getRooms()) {\r\n                for (UnitRoom unitRoom : room.getUnitRooms()) {\r\n                    if (villainCollider.getPosition().x >= unitRoom.getPosition().x - 0.5 &&\r\n                            villainCollider.getPosition().x <= unitRoom.getPosition().x + 0.5 &&\r\n                            villainCollider.getPosition().y >= unitRoom.getPosition().y - 0.5 &&\r\n                            villainCollider.getPosition().y <= unitRoom.getPosition().y + 0.5) {\r\n                        currentUnitRoom = unitRoom;\r\n                    }\r\n                }\r\n            }\r\n            int randomNumber = random.nextInt(3);\r\n            if (villainCollider.getVelocity().x < 0) {\r\n                if (currentUnitRoom.isLeftDoor()) {\r\n                    villainCollider.getVelocity().x = 0;\r\n                    switch (randomNumber) {\r\n                        case 0:\r\n                            villainCollider.getVelocity().x = velocity;\r\n                            break;\r\n                        case 1:\r\n                            villainCollider.getVelocity().y = velocity;\r\n                            break;\r\n                        case 2:\r\n                            villainCollider.getVelocity().y = -velocity;\r\n                            break;\r\n                    }\r\n                }\r\n            }\r\n            if (villainCollider.getVelocity().x > 0) {\r\n                if (currentUnitRoom.isRightDoor()) {\r\n                    villainCollider.getVelocity().x = 0;\r\n                    switch (randomNumber) {\r\n                        case 0:\r\n                            villainCollider.getVelocity().x = -velocity;\r\n                            break;\r\n                        case 1:\r\n                            villainCollider.getVelocity().y = velocity;\r\n                            break;\r\n                        case 2:\r\n                            villainCollider.getVelocity().y = -velocity;\r\n                            break;\r\n                    }\r\n                }\r\n            }\r\n            if (villainCollider.getVelocity().y > 0) {\r\n                if (currentUnitRoom.isTopDoor()) {\r\n                    villainCollider.getVelocity().y = 0;\r\n                    switch (randomNumber) {\r\n                        case 0:\r\n                            villainCollider.getVelocity().x = velocity;\r\n                            break;\r\n                        case 1:\r\n                            villainCollider.getVelocity().y = -velocity;\r\n                            break;\r\n                        case 2:\r\n                            villainCollider.getVelocity().x = -velocity;\r\n                            break;\r\n                    }\r\n                }\r\n            }\r\n            if (villainCollider.getVelocity().y < 0) {\r\n                if (currentUnitRoom.isBottomDoor()) {\r\n                    villainCollider.getVelocity().y = 0;\r\n                    switch (randomNumber) {\r\n                        case 0:\r\n                            villainCollider.getVelocity().x = velocity;\r\n                            break;\r\n                        case 1:\r\n                            villainCollider.getVelocity().y = velocity;\r\n                            break;\r\n                        case 2:\r\n                            villainCollider.getVelocity().x = -velocity;\r\n                            break;\r\n                    }\r\n                }\r\n            }\r\n            if (villainCollider.getVelocity().x == 0 && villainCollider.getVelocity().y == 0) {\r\n                randomNumber = random.nextInt(4);\r\n                switch (randomNumber) {\r\n                    case 0:\r\n                        villainCollider.getVelocity().x = velocity;\r\n                        villainCollider.getVelocity().y = 0.0f;\r\n                        break;\r\n                    case 1:\r\n                        villainCollider.getVelocity().x = -velocity;\r\n                        villainCollider.getVelocity().y = 0.0f;\r\n                        break;\r\n                    case 2:\r\n                        villainCollider.getVelocity().y = velocity;\r\n                        villainCollider.getVelocity().x = 0.0f;\r\n                        break;\r\n                    case 3:\r\n                        villainCollider.getVelocity().y = -velocity;\r\n                        villainCollider.getVelocity().x = 0.0f;\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n        else setFainted();\r\n\r\n    }\r\n\r\n    public float[] randomPositions(ArrayList<Room> rooms) {\r\n        //Collections.shuffle(rooms);\r\n        Random rand = new Random();\r\n\r\n        Room selectedRoom;\r\n\r\n        do {\r\n            random1 = rand.nextInt(rooms.size() - 1);\r\n            selectedRoom = rooms.get(random1);\r\n        } while (roomsWithVillains.contains(selectedRoom) || isStartUnitRoomInRoom(selectedRoom)|| selectedRoom.getRoomType()== RoomType.GAS);\r\n\r\n        random2 = rand.nextInt(selectedRoom.getUnitRooms().size());\r\n        UnitRoom selectedUnitRoom = selectedRoom.getUnitRooms().get(random2);\r\n        roomsWithVillains.add(selectedRoom);\r\n        room = selectedRoom;\r\n        return new float[]{random1, random2, selectedUnitRoom.getPosition().x, selectedUnitRoom.getPosition().y};\r\n    }\r\n\r\n    public void setRoomForVillain(ArrayList<Room> rooms, int selectedRoomIndex, int selectedUnitRoomIndex) {\r\n        Room selectedRoom = rooms.get(selectedRoomIndex);\r\n        UnitRoom selectedUnitRoom = selectedRoom.getUnitRooms().get(selectedUnitRoomIndex);\r\n        roomsWithVillains.add(selectedRoom);\r\n        room = selectedRoom;\r\n    }\r\n\r\n    boolean isStartUnitRoomInRoom(Room room) {\r\n        for (UnitRoom unitRoom : room.getUnitRooms()) {\r\n            if (unitRoom.getPosition().x == 0 && unitRoom.getPosition().y == 0) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    @Override\r\n    public void onDestroy() {\r\n    }\r\n\r\n\r\n    public String getVillainName() {\r\n        return villainName.getText();\r\n    }\r\n\r\n    public Vec2 getPosition() {\r\n        return position;\r\n    }\r\n\r\n    public String getImagePath() {\r\n        return imagePath;\r\n    }\r\n\r\n    public Collider getVillainCollider() {\r\n        return villainCollider;\r\n    }\r\n\r\n    public void setVillainCollider(Isten isten, Collider collider) {\r\n        villainCollider = collider;\r\n        isten.getPhysicsEngine().addCollider(villainCollider);//register collider in the physics engine\r\n    }\r\n\r\n    public void setVillainImage(Isten isten, Image image) {\r\n        villainImage = image;\r\n        isten.getRenderer().addRenderable(villainImage);\r\n    }\r\n    public Room getRoom() {\r\n        return room;\r\n    }\r\n\r\n    public void setPosition(Vec2 vec2) {\r\n        position = vec2;\r\n    }\r\n\r\n    public int getRandom1() {\r\n        return random1;\r\n    }\r\n\r\n    public int getRandom2() {\r\n        return random2;\r\n    }\r\n\r\n    public void setRandom1(int random1) {\r\n        this.random1 = random1;\r\n    }\r\n\r\n    public void setRandom2(int random2) {\r\n        this.random2 = random2;\r\n    }\r\n    public boolean getIsFainted(){return isFainted;}\r\n    public void setFainted(){\r\n        isFainted=true;\r\n        villainImage.setVisibility(false);\r\n    }\r\n    public void setVelocity(float velocity) {\r\n        villainCollider.setVelocity(new Vec2(velocity, velocity));\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/entities/villain/Villain.java b/src/main/java/org/entities/villain/Villain.java
--- a/src/main/java/org/entities/villain/Villain.java	(revision 2a081a32d6cdbb313837c52de84c0543f0763b2d)
+++ b/src/main/java/org/entities/villain/Villain.java	(date 1714982469340)
@@ -112,9 +112,9 @@
     public void onUpdate(Isten isten, double deltaTime) {
         timeElapsed+=deltaTime;
         Vec2 playerPosition = villainCollider.getPosition();
-        //villainImage.setPosition(playerPosition);
-        faintedVillainImages.get(0).setPosition(playerPosition);
+        villainImage.setPosition(playerPosition);
         faintedVillainImages.get(0).setPosition(playerPosition);
+        faintedVillainImages.get(1).setPosition(playerPosition);
         villainName.setPosition(Vec2.sum(playerPosition, new Vec2(0, (float) 0.5)));
         if(isFainted) {
             if ((timeElapsed*1000000) % 1000000 < 500000) {
@@ -124,6 +124,16 @@
                 setVillainImage(isten,faintedVillainImages.get(1));
             }
         }
+        for (Room room : isten.getMap().getRooms()) {
+            for (UnitRoom unitRoom : room.getUnitRooms()) {
+                if (villainCollider.getPosition().x >= unitRoom.getPosition().x - 0.5 &&
+                        villainCollider.getPosition().x <= unitRoom.getPosition().x + 0.5 &&
+                        villainCollider.getPosition().y >= unitRoom.getPosition().y - 0.5 &&
+                        villainCollider.getPosition().y <= unitRoom.getPosition().y + 0.5) {
+                    currentUnitRoom = unitRoom;
+                }
+            }
+        }
     }
     public boolean isInGasRoom(Isten isten)
     {
@@ -152,19 +162,8 @@
             villainName.setPosition(Vec2.sum(playerPosition, new Vec2(0, (float) 0.5)));
 
 
-            if (sum < 2) return;
-            Map map = isten.getMap();
+            if (sum < 2 || currentUnitRoom == null) return;
 
-            for (Room room : map.getRooms()) {
-                for (UnitRoom unitRoom : room.getUnitRooms()) {
-                    if (villainCollider.getPosition().x >= unitRoom.getPosition().x - 0.5 &&
-                            villainCollider.getPosition().x <= unitRoom.getPosition().x + 0.5 &&
-                            villainCollider.getPosition().y >= unitRoom.getPosition().y - 0.5 &&
-                            villainCollider.getPosition().y <= unitRoom.getPosition().y + 0.5) {
-                        currentUnitRoom = unitRoom;
-                    }
-                }
-            }
             int randomNumber = random.nextInt(3);
             if (villainCollider.getVelocity().x < 0) {
                 if (currentUnitRoom.isLeftDoor()) {
Index: src/main/java/org/networking/Packet26InGasRoom.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/networking/Packet26InGasRoom.java b/src/main/java/org/networking/Packet26InGasRoom.java
new file mode 100644
--- /dev/null	(date 1715014430584)
+++ b/src/main/java/org/networking/Packet26InGasRoom.java	(date 1715014430584)
@@ -0,0 +1,47 @@
+package main.java.org.networking;
+
+public class Packet26InGasRoom extends Packet {
+    private float x,y;
+    private boolean isInGasRoom;
+
+    public Packet26InGasRoom(byte[] data) {
+        super(26);
+        String[] dataArray = readData(data).split(",");
+        this.x = Float.parseFloat(dataArray[0]);
+        this.y = Float.parseFloat(dataArray[1]);
+        this.isInGasRoom = Boolean.parseBoolean(dataArray[2]);
+    }
+
+    public Packet26InGasRoom(float x, float y, boolean isInGasRoom) {
+        super(26);
+        this.x = x;
+        this.y = y;
+        this.isInGasRoom = isInGasRoom;
+    }
+
+    public void writeData(GameClient client) {
+        client.sendData(getData());
+    }
+
+    public void writeData(GameServer server) {
+        server.sendDataToAllClients(getData());
+    }
+
+    public byte[] getData() {
+        return ("26" + this.x + "," + this.y + "," + isInGasRoom).getBytes();
+
+    }
+
+    public float getX() {
+        return x;
+    }
+
+    public float getY() {
+        return y;
+    }
+
+    public boolean isInGasRoom() {
+        return isInGasRoom;
+    }
+}
+
Index: src/main/java/org/networking/ClientMap.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package main.java.org.networking;\r\n\r\nimport main.java.org.game.Isten;\r\nimport main.java.org.game.Map.Door;\r\nimport main.java.org.game.Map.EdgeBetweenRooms;\r\nimport main.java.org.game.Map.EdgePiece;\r\nimport main.java.org.game.updatable.Updatable;\r\n\r\nimport java.awt.event.KeyEvent;\r\n\r\npublic class ClientMap extends Updatable {\r\n\r\n    private EdgeBetweenRooms edgeBetweenRooms;\r\n    private Isten isten;\r\n\r\n    public void addEdgePiece(EdgePiece edgePiece) {\r\n        edgeBetweenRooms.getWalls().add(edgePiece);\r\n    }\r\n    @Override\r\n    public void onStart(Isten isten) {\r\n        this.isten = isten;\r\n        edgeBetweenRooms = new EdgeBetweenRooms();\r\n        isten.getPhysicsEngine().addColliderGroup(edgeBetweenRooms.getColliderGroup());\r\n    }\r\n\r\n    @Override\r\n    public void onUpdate(Isten isten, double deltaTime) {\r\n        //check if door is opened by player\r\n        if(isten.getInputHandler().isKeyReleased(KeyEvent.VK_O)) {\r\n            Packet25PlayerPosForDoorOpen packet = new Packet25PlayerPosForDoorOpen(isten.getPlayer().getPlayerCollider().getPosition().x,\r\n                    isten.getPlayer().getPlayerCollider().getPosition().y);\r\n            packet.writeData(isten.getSocketClient());\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void onDestroy() {\r\n\r\n    }\r\n\r\n    public EdgeBetweenRooms getEdgeBetweenRooms() {\r\n        return edgeBetweenRooms;\r\n    }\r\n\r\n    public void removeEdgePiece(EdgePiece piece) {\r\n        isten.getRenderer().deleteRenderable(piece.getImage());\r\n        edgeBetweenRooms.getColliderGroup().removeCollider(piece.getCollider());\r\n        edgeBetweenRooms.getWalls().remove(piece);\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/networking/ClientMap.java b/src/main/java/org/networking/ClientMap.java
--- a/src/main/java/org/networking/ClientMap.java	(revision 2a081a32d6cdbb313837c52de84c0543f0763b2d)
+++ b/src/main/java/org/networking/ClientMap.java	(date 1715011293029)
@@ -12,6 +12,8 @@
 
     private EdgeBetweenRooms edgeBetweenRooms;
     private Isten isten;
+    public static int mapWidth;
+    public static int mapHeight;
 
     public void addEdgePiece(EdgePiece edgePiece) {
         edgeBetweenRooms.getWalls().add(edgePiece);
@@ -19,6 +21,8 @@
     @Override
     public void onStart(Isten isten) {
         this.isten = isten;
+        ClientMap.mapWidth = isten.getMap().getMapColumnSize();
+        ClientMap.mapHeight = isten.getMap().getMapRowSize();
         edgeBetweenRooms = new EdgeBetweenRooms();
         isten.getPhysicsEngine().addColliderGroup(edgeBetweenRooms.getColliderGroup());
     }
Index: src/main/java/org/networking/GameServer.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package main.java.org.networking;\r\n\r\nimport main.java.org.game.Isten;\r\nimport java.io.IOException;\r\nimport java.net.DatagramPacket;\r\nimport java.net.DatagramSocket;\r\nimport java.net.*;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\nimport main.java.org.items.ChestManager;\r\nimport main.java.org.items.Item;\r\nimport main.java.org.items.ItemManager;\r\nimport main.java.org.linalg.Vec2;\r\nimport main.java.org.networking.Packet.PacketTypes;\r\n\r\npublic class GameServer extends Thread {\r\n    private ArrayList<ServerSideHandler> serverSideHandlers;\r\n    private VillainHandler villainHandler;\r\n    private MapHandler mapHandler;\r\n    private TimeHandler timeHandler;\r\n    private DeathHandler deathHandler;\r\n    private ChestGenerationHandler chestGenerationHandler;\r\n    private DatagramSocket socket;\r\n\r\n    private ArrayList<byte[]> events = new ArrayList<>();\r\n\r\n    Isten isten;\r\n    boolean isInitialized = false;\r\n\r\n    //Notification for gamemanager, that the server is initialized, so it can enter the gameloop\r\n    SharedObject InitializationLock;\r\n\r\n    //Just values, not references for the actual players\r\n    //When changing something in one of the connectedPlayers it won't change anything on the actual players in updatable\r\n    private List<PlayerMP> connectedPlayers = new ArrayList<>();\r\n    public GameServer(Isten isten) {\r\n        this.isten = isten;\r\n        InitializationLock = new SharedObject();\r\n        try {\r\n            this.socket = new DatagramSocket(1331);\r\n        }\r\n        catch(SocketException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n    public void run() {\r\n        System.out.println(\"ITS THE SERVER!\");\r\n        startServer();\r\n        while(true) {\r\n            //Get packets from clients\r\n            byte[] data = new byte[1024];\r\n            DatagramPacket packet = new DatagramPacket(data, data.length);\r\n            try {\r\n                socket.receive(packet);\r\n            } catch (IOException e) {\r\n                throw new RuntimeException(e);\r\n            }\r\n            parsePacket(packet.getData(), packet.getAddress(), packet.getPort());\r\n        }\r\n    }\r\n\r\n    private void startServer() {\r\n        serverSideHandlers = new ArrayList<ServerSideHandler>();\r\n        mapHandler = new MapHandler();\r\n        timeHandler = new TimeHandler();\r\n        villainHandler = new VillainHandler();\r\n        deathHandler = new DeathHandler();\r\n        chestGenerationHandler = new ChestGenerationHandler();\r\n\r\n        serverSideHandlers.add(mapHandler);\r\n        serverSideHandlers.add(timeHandler);\r\n        serverSideHandlers.add(villainHandler);\r\n        serverSideHandlers.add(deathHandler);\r\n        serverSideHandlers.add(chestGenerationHandler);\r\n\r\n        for(ServerSideHandler serverSideHandler: serverSideHandlers) {\r\n            serverSideHandler.create(this);\r\n            serverSideHandler.setInitialized(true);\r\n        }\r\n        isInitialized = true;\r\n        //Send notification to game manager, so that it can start the game loop\r\n        InitializationLock.sendNotification();\r\n\r\n    }\r\n\r\n    public void updateServer(Isten isten, double deltaTime) {\r\n        for(ServerSideHandler serverSideHandler: serverSideHandlers) {\r\n            if(serverSideHandler.isInitialized && isInitialized) serverSideHandler.update(isten, deltaTime);\r\n        }\r\n    }\r\n\r\n    //Parse packet to string\r\n    private void parsePacket(byte[] data, InetAddress address, int port) {\r\n        String message = new String(data).trim();\r\n        PacketTypes type = Packet.lookupPacket(message.substring(0,2));\r\n        Packet packet = null;\r\n        switch(type) {\r\n            default:\r\n                break;\r\n            case INVALID:\r\n                break;\r\n            case LOGIN:\r\n                packet = new Packet00Login(data);\r\n                handleLogin((Packet00Login)packet, address, port);\r\n                break;\r\n            case DISCONNECT:\r\n                break;\r\n            case MOVE:\r\n                packet = new Packet02Move(data);\r\n                handleMove(((Packet02Move)packet));\r\n                break;\r\n            case ANIMATION:\r\n                packet = new Packet03Animation(data);\r\n                handleAnimation((Packet03Animation) packet);\r\n                break;\r\n            case CHESTOPENED:\r\n                packet = new Packet11ChestOpened(data);\r\n                handleChestOpened((Packet11ChestOpened) packet);\r\n                break;\r\n            case ITEMPICKEDUP:\r\n                packet = new Packet12ItemPickedUp(data);\r\n                handleItemPickedUp((Packet12ItemPickedUp) packet);\r\n                break;\r\n            case ITEMDROPPED:\r\n                packet = new Packet13ItemDropped(data);\r\n                handleItemDropped((Packet13ItemDropped) packet);\r\n                break;\r\n            case GASMASK:\r\n                packet = new Packet14Gasmask(data);\r\n                handleGasmask((Packet14Gasmask) packet);\r\n                break;\r\n            case DOOROPEN:\r\n                packet = new Packet24DoorOpen(data);\r\n                handleDoorOpen((Packet24DoorOpen)packet);\r\n                break;\r\n            case PLAYERPOSFORDOOROPEN:\r\n                packet = new Packet25PlayerPosForDoorOpen(data);\r\n                handlePlayerPosForDoorOpen((Packet25PlayerPosForDoorOpen)packet);\r\n                break;\r\n        }\r\n    }\r\n\r\n    private void handleGasmask(Packet14Gasmask packet) {\r\n        for(int i = 0; i < isten.getUpdatables().size(); i++) {\r\n            if(isten.getUpdatable(i).getClass() == ItemManager.class) {\r\n                isten.getUpdatables().get(i).getItems().get(packet.getItemIndex()).setCapacity(packet.getCapacity());\r\n                isten.getUpdatables().get(i).getItems().get(packet.getItemIndex()).resizeBar(packet.getCapacity());\r\n            }\r\n        }\r\n        sendDataToAllClients(packet.getData());\r\n    }\r\n\r\n    private void handlePlayerPosForDoorOpen(Packet25PlayerPosForDoorOpen packet) {\r\n        mapHandler.CheckIfPlayerOpenedDoor(packet);\r\n    }\r\n\r\n    private void handleDoorOpen(Packet24DoorOpen packet) {\r\n        mapHandler.handleDoorOpen(packet);\r\n    }\r\n\r\n    private void handleItemDropped(Packet13ItemDropped packet) {\r\n        for(int i = 0; i < isten.getUpdatables().size(); i++) {\r\n            if(isten.getUpdatable(i).getClass() == ItemManager.class) {\r\n                isten.getUpdatables().get(i).getItems().get(packet.getItemIndex()).setLocation(Item.Location.GROUND);\r\n                isten.getUpdatables().get(i).getItems().get(packet.getItemIndex()).getImage().setVisibility(true);\r\n                isten.getUpdatables().get(i).getItems().get(packet.getItemIndex()).getImage().setPosition(packet.getPos());\r\n                isten.getUpdatables().get(i).getItems().get(packet.getItemIndex()).setPosition(packet.getPos());\r\n            }\r\n        }\r\n        events.add(packet.getData());\r\n        sendDataToAllClients(packet.getData());\r\n    }\r\n\r\n    private void handleItemPickedUp(Packet12ItemPickedUp packet) {\r\n        for(int i = 0; i < isten.getUpdatables().size(); i++) {\r\n            if(isten.getUpdatable(i).getClass() == ItemManager.class) {\r\n                isten.getUpdatables().get(i).getItems().get(packet.getItemIndex()).setLocation(Item.Location.INVENTORY);\r\n                isten.getUpdatables().get(i).getItems().get(packet.getItemIndex()).getImage().setVisibility(false);\r\n            }\r\n        }\r\n        events.add(packet.getData());\r\n        sendDataToAllClients(packet.getData());\r\n    }\r\n\r\n    private void handleChestOpened(Packet11ChestOpened packet) {\r\n        for(int i = 0; i < isten.getUpdatables().size(); i++) {\r\n            if(isten.getUpdatable(i).getClass() == ChestManager.class) {\r\n                isten.getUpdatables().get(i).getChests().get(packet.getChestIndex()).open();\r\n            }\r\n        }\r\n        events.add(packet.getData());\r\n        sendDataToAllClients(packet.getData());\r\n    }\r\n\r\n    //handle Animation Packet\r\n    private void handleAnimation(Packet03Animation packet) {\r\n        packet.writeData(this);\r\n    }\r\n\r\n    //handle Login Packet\r\n    private void handleLogin(Packet00Login packet, InetAddress address, int port) {\r\n        PlayerMP player = null;\r\n        player = new PlayerMP(packet.getUsername(), address, port);\r\n        player.setSkinID(packet.getSkinID());\r\n        this.addConnection(player, packet);\r\n\r\n        //Handle creation of villains - when player joins, the server generated villains are generated on client as well\r\n        handlePlayerJoinedData(player);\r\n    }\r\n\r\n    private void handlePlayerJoinedData(PlayerMP player) {\r\n        mapHandler.sendDataToClient(player);\r\n        villainHandler.sendDataToClient(player);\r\n        chestGenerationHandler.sendDataToClient(player);\r\n        for (byte[] data : events) sendDataToAllClients(data);\r\n    }\r\n\r\n    //handle Move Packet\r\n    private void handleMove(Packet02Move packet) {\r\n        packet.writeData(this);\r\n    }\r\n\r\n    public void addConnection(PlayerMP player, Packet00Login packet) {\r\n        boolean alreadyConnected = false;\r\n        for (PlayerMP p : this.connectedPlayers) {\r\n            if(player.getUsername().equalsIgnoreCase(p.getUsername())) {\r\n                if(p.ipAddress == null) {\r\n                    p.ipAddress = player.ipAddress;\r\n                }\r\n                if(p.port == -1) {\r\n                    p.port = player.port;\r\n                }\r\n                alreadyConnected = true;\r\n            }\r\n            else {\r\n                //New player's position is (0,0) -> later: spawnPoints\r\n                //Send data to the already connected players, that the new player exists\r\n                packet = new Packet00Login(player.getUsername(), 0, 0, player.getSkinID());\r\n                sendData(packet.getData(), p.ipAddress, p.port);\r\n\r\n                //Send position as well, so that the players spawn at their current position\r\n                //Send data to the new player, that the already connected player exists\r\n                int index = isten.getPlayerMPIndex(p.getUsername());\r\n                Vec2 pos = ((PlayerMP)isten.getUpdatable(index)).getPlayerCollider().getPosition();\r\n                packet = new Packet00Login(p.getUsername(), pos.x, pos.y, p.getSkinID());\r\n                sendData(packet.getData(), player.ipAddress, player.port);\r\n\r\n            }\r\n        }\r\n        if(!alreadyConnected) {\r\n            //If the player has not been connected before, then add it to connectedPlayers\r\n            this.connectedPlayers.add(player);\r\n        }\r\n    }\r\n\r\n    //Send data to one client\r\n    public void sendData(byte[] data, InetAddress ipAddress, int port) {\r\n        DatagramPacket packet = new DatagramPacket(data, data.length, ipAddress, port);\r\n        try {\r\n            socket.send(packet);\r\n        } catch (IOException e) {\r\n            throw new RuntimeException(e);\r\n        }\r\n    }\r\n\r\n    //Send data to all clients\r\n    public void sendDataToAllClients(byte[] data) {\r\n        for(int i = 0; i < connectedPlayers.size(); i++) {\r\n            PlayerMP p = connectedPlayers.get(i);\r\n            sendData(data, p.ipAddress, p.port);\r\n        }\r\n    }\r\n\r\n    public boolean isInitialized() {\r\n        return isInitialized;\r\n    }\r\n\r\n    public SharedObject getInitializationLock() {\r\n        return InitializationLock;\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/networking/GameServer.java b/src/main/java/org/networking/GameServer.java
--- a/src/main/java/org/networking/GameServer.java	(revision 2a081a32d6cdbb313837c52de84c0543f0763b2d)
+++ b/src/main/java/org/networking/GameServer.java	(date 1715013043225)
@@ -19,7 +19,7 @@
     private VillainHandler villainHandler;
     private MapHandler mapHandler;
     private TimeHandler timeHandler;
-    private DeathHandler deathHandler;
+    private PlayerStatusHandler playerStatusHandler;
     private ChestGenerationHandler chestGenerationHandler;
     private DatagramSocket socket;
 
@@ -66,13 +66,13 @@
         mapHandler = new MapHandler();
         timeHandler = new TimeHandler();
         villainHandler = new VillainHandler();
-        deathHandler = new DeathHandler();
+        playerStatusHandler = new PlayerStatusHandler();
         chestGenerationHandler = new ChestGenerationHandler();
 
         serverSideHandlers.add(mapHandler);
         serverSideHandlers.add(timeHandler);
         serverSideHandlers.add(villainHandler);
-        serverSideHandlers.add(deathHandler);
+        serverSideHandlers.add(playerStatusHandler);
         serverSideHandlers.add(chestGenerationHandler);
 
         for(ServerSideHandler serverSideHandler: serverSideHandlers) {
Index: src/main/java/org/networking/VillainHandler.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package main.java.org.networking;\r\n\r\nimport main.java.org.entities.villain.Villain;\r\nimport main.java.org.game.Isten;\r\nimport main.java.org.game.Map.Room;\r\nimport main.java.org.game.physics.Collider;\r\nimport main.java.org.linalg.Vec2;\r\n\r\nimport java.net.DatagramPacket;\r\nimport java.util.ArrayList;\r\nimport java.util.Random;\r\n\r\n//Handles villain creation and update for Server\r\npublic class VillainHandler extends ServerSideHandler {\r\n\r\n    ArrayList<Villain> villains = new ArrayList<>();\r\n    ArrayList<Villain> villainSkeletons = new ArrayList<>();\r\n\r\n    private double currTime = 0;\r\n    @Override\r\n    public void create(GameServer server) {\r\n        this.server = server;\r\n        this.isten = server.isten;\r\n        villains = new ArrayList<>();\r\n        createVillains();\r\n        isInitialized = true;\r\n        sendDataToWaitingClients();\r\n    }\r\n\r\n    public void createVillains() {\r\n\r\n\r\n        villainSkeletons.add(new Villain(\"Villain1\", \"./assets/villain/villain1.png\"));\r\n        villainSkeletons.add(new Villain(\"Villain2\",  \"./assets/villain/villain1.png\"));\r\n        villainSkeletons.add(new Villain(\"Villain3\",  \"./assets/villain/villain1.png\"));\r\n        villainSkeletons.add(new Villain(\"Villain4\",  \"./assets/villain/villain1.png\"));\r\n        villainSkeletons.add(new Villain(\"Villain5\",  \"./assets/villain/villain1.png\"));\r\n        villainSkeletons.add(new Villain(\"Villain6\",  \"./assets/villain/villain1.png\"));\r\n        villainSkeletons.add(new Villain(\"Villain7\",  \"./assets/villain/villain3.png\"));\r\n        villainSkeletons.add(new Villain(\"Villain8\",  \"./assets/villain/villain3.png\"));\r\n        villainSkeletons.add(new Villain(\"Gajdos\",  \"./assets/villain/villain1.png\"));\r\n        villainSkeletons.add(new Villain(\"Csuka\",  \"./assets/villain/villain2.png\"));\r\n\r\n        for(Villain villain: villainSkeletons) {\r\n            float[] data = villain.randomPositions(isten.getMap().getRooms());\r\n            int random1 = (int)data[0];\r\n            int random2 = (int)data[1];\r\n            Vec2 pos = new Vec2(data[2], data[3]);\r\n            villain.setPosition(pos);\r\n        }\r\n\r\n    }\r\n\r\n    @Override\r\n    public void sendDataToClient(PlayerMP client) {\r\n\r\n        if(!isInitialized) {\r\n            if(!waitingClients.contains(client)) waitingClients.add(client);\r\n            return;\r\n        }\r\n\r\n        for(int i = 0; i < villainSkeletons.size(); i++) {\r\n            Packet05Villain packet = new Packet05Villain(villainSkeletons.get(i).getVillainName(),\r\n                    villainSkeletons.get(i).getPosition(),\r\n                    villainSkeletons.get(i).getImagePath(),\r\n                    villainSkeletons.get(i).getRandom1(),\r\n                    villainSkeletons.get(i).getRandom2());\r\n            server.sendData(packet.getData(), client.ipAddress, client.port);\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void sendDataToAllClients(Packet packet) {\r\n        //send to every client\r\n        packet.writeData(server);\r\n    }\r\n\r\n    @Override\r\n    public void update(Isten isten, double deltaTime) {\r\n\r\n        if(currTime < 10000) {\r\n            currTime += deltaTime;\r\n        }\r\n        else currTime = 0;\r\n\r\n\r\n        for(Villain skeleton: villainSkeletons) {\r\n            int index = isten.getVillainIndex(skeleton.getVillainName());\r\n            Villain villain = (Villain)isten.getUpdatable(index);\r\n\r\n            if(villain == null || !villain.isInitialized()) continue;\r\n\r\n\r\n            if(villain.getRoom() == null) {\r\n                villain.setRoomForVillain(isten.getMap().getRooms(), skeleton.getRandom1(), skeleton.getRandom2());\r\n            }\r\n\r\n            villain.move(isten, deltaTime);\r\n            if (villain.isInGasRoom(isten)){\r\n                villain.setVelocity(0.0f);\r\n            }\r\n\r\n\r\n            if((int)(currTime * 100) % 2 == 0) {\r\n                Packet06VillainMove packet = new Packet06VillainMove(villain.getVillainName(),\r\n                        villain.getVillainCollider().getPosition().x,\r\n                        villain.getVillainCollider().getPosition().y);\r\n                sendDataToAllClients(packet);\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/networking/VillainHandler.java b/src/main/java/org/networking/VillainHandler.java
--- a/src/main/java/org/networking/VillainHandler.java	(revision 2a081a32d6cdbb313837c52de84c0543f0763b2d)
+++ b/src/main/java/org/networking/VillainHandler.java	(date 1714981392567)
@@ -34,17 +34,15 @@
         villainSkeletons.add(new Villain("Villain2",  "./assets/villain/villain1.png"));
         villainSkeletons.add(new Villain("Villain3",  "./assets/villain/villain1.png"));
         villainSkeletons.add(new Villain("Villain4",  "./assets/villain/villain1.png"));
-        villainSkeletons.add(new Villain("Villain5",  "./assets/villain/villain1.png"));
-        villainSkeletons.add(new Villain("Villain6",  "./assets/villain/villain1.png"));
-        villainSkeletons.add(new Villain("Villain7",  "./assets/villain/villain3.png"));
-        villainSkeletons.add(new Villain("Villain8",  "./assets/villain/villain3.png"));
+        //villainSkeletons.add(new Villain("Villain5",  "./assets/villain/villain1.png"));
+        //villainSkeletons.add(new Villain("Villain6",  "./assets/villain/villain1.png"));
+        //villainSkeletons.add(new Villain("Villain7",  "./assets/villain/villain3.png"));
+        //villainSkeletons.add(new Villain("Villain8",  "./assets/villain/villain3.png"));
         villainSkeletons.add(new Villain("Gajdos",  "./assets/villain/villain1.png"));
         villainSkeletons.add(new Villain("Csuka",  "./assets/villain/villain2.png"));
 
         for(Villain villain: villainSkeletons) {
             float[] data = villain.randomPositions(isten.getMap().getRooms());
-            int random1 = (int)data[0];
-            int random2 = (int)data[1];
             Vec2 pos = new Vec2(data[2], data[3]);
             villain.setPosition(pos);
         }
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"AutoImportSettings\">\r\n    <option name=\"autoReloadType\" value=\"SELECTIVE\" />\r\n  </component>\r\n  <component name=\"ChangeListManager\">\r\n    <list default=\"true\" id=\"3506ab6d-0407-47f2-a7e8-78ebc867e577\" name=\"Changes\" comment=\"it's working\">\r\n      <change beforePath=\"$PROJECT_DIR$/.idea/misc.xml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/misc.xml\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/.idea/workspace.xml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/workspace.xml\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/src/main/java/org/entities/player/Player.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/main/java/org/entities/player/Player.java\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/src/main/java/org/game/Map/Door.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/main/java/org/game/Map/Door.java\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/src/main/java/org/game/Map/EdgeManager.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/main/java/org/game/Map/EdgeManager.java\" afterDir=\"false\" />\r\n    </list>\r\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\r\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\r\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\r\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\r\n  </component>\r\n  <component name=\"ExternalProjectsData\">\r\n    <projectState path=\"$PROJECT_DIR$\">\r\n      <ProjectState />\r\n    </projectState>\r\n  </component>\r\n  <component name=\"ExternalProjectsManager\">\r\n    <system id=\"GRADLE\">\r\n      <state>\r\n        <task path=\"$PROJECT_DIR$\">\r\n          <activation />\r\n        </task>\r\n        <projects_view>\r\n          <tree_state>\r\n            <expand />\r\n            <select />\r\n          </tree_state>\r\n        </projects_view>\r\n      </state>\r\n    </system>\r\n  </component>\r\n  <component name=\"FileTemplateManagerImpl\">\r\n    <option name=\"RECENT_TEMPLATES\">\r\n      <list>\r\n        <option value=\"Class\" />\r\n        <option value=\"Interface\" />\r\n      </list>\r\n    </option>\r\n  </component>\r\n  <component name=\"Git.Settings\">\r\n    <option name=\"RECENT_BRANCH_BY_REPOSITORY\">\r\n      <map>\r\n        <entry key=\"$PROJECT_DIR$\" value=\"5cd5399fbfcfd5811c762cb41388070c81f45885\" />\r\n      </map>\r\n    </option>\r\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\r\n  </component>\r\n  <component name=\"MarkdownSettingsMigration\">\r\n    <option name=\"stateVersion\" value=\"1\" />\r\n  </component>\r\n  <component name=\"ProjectColorInfo\">{\r\n  &quot;associatedIndex&quot;: 8\r\n}</component>\r\n  <component name=\"ProjectId\" id=\"2frbzqFlsraLkUjUjuqMYUBt0BV\" />\r\n  <component name=\"ProjectViewState\">\r\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\r\n    <option name=\"showLibraryContents\" value=\"true\" />\r\n  </component>\r\n  <component name=\"PropertiesComponent\">{\r\n  &quot;keyToString&quot;: {\r\n    &quot;Downloaded.Files.Path.Enabled&quot;: &quot;false&quot;,\r\n    &quot;Gradle.MultiplayerTester.executor&quot;: &quot;Run&quot;,\r\n    &quot;Gradle.MultiplayerTester.testPacket01.executor&quot;: &quot;Run&quot;,\r\n    &quot;Gradle.MultiplayerTester.testPacket02Constructor.executor&quot;: &quot;Run&quot;,\r\n    &quot;Gradle.iLaby [run].executor&quot;: &quot;Run&quot;,\r\n    &quot;Repository.Attach.Annotations&quot;: &quot;false&quot;,\r\n    &quot;Repository.Attach.JavaDocs&quot;: &quot;false&quot;,\r\n    &quot;Repository.Attach.Sources&quot;: &quot;false&quot;,\r\n    &quot;RunOnceActivity.OpenProjectViewOnStart&quot;: &quot;true&quot;,\r\n    &quot;RunOnceActivity.ShowReadmeOnStart&quot;: &quot;true&quot;,\r\n    &quot;WebServerToolWindowFactoryState&quot;: &quot;false&quot;,\r\n    &quot;git-widget-placeholder&quot;: &quot;main&quot;,\r\n    &quot;kotlin-language-version-configured&quot;: &quot;true&quot;,\r\n    &quot;last_opened_file_path&quot;: &quot;C:/Users/kuruc/Downloads/junit-4.13.2.jar&quot;,\r\n    &quot;node.js.detected.package.eslint&quot;: &quot;true&quot;,\r\n    &quot;node.js.detected.package.tslint&quot;: &quot;true&quot;,\r\n    &quot;node.js.selected.package.eslint&quot;: &quot;(autodetect)&quot;,\r\n    &quot;node.js.selected.package.tslint&quot;: &quot;(autodetect)&quot;,\r\n    &quot;nodejs_package_manager_path&quot;: &quot;npm&quot;,\r\n    &quot;project.structure.last.edited&quot;: &quot;Modules&quot;,\r\n    &quot;project.structure.proportion&quot;: &quot;0.15&quot;,\r\n    &quot;project.structure.side.proportion&quot;: &quot;0.2&quot;,\r\n    &quot;settings.editor.selected.configurable&quot;: &quot;reference.settingsdialog.project.gradle&quot;,\r\n    &quot;vue.rearranger.settings.migration&quot;: &quot;true&quot;\r\n  }\r\n}</component>\r\n  <component name=\"RunManager\" selected=\"Gradle.iLaby [run]\">\r\n    <configuration name=\"MultiplayerTester\" type=\"GradleRunConfiguration\" factoryName=\"Gradle\" temporary=\"true\">\r\n      <ExternalSystemSettings>\r\n        <option name=\"executionName\" />\r\n        <option name=\"externalProjectPath\" value=\"$PROJECT_DIR$\" />\r\n        <option name=\"externalSystemIdString\" value=\"GRADLE\" />\r\n        <option name=\"scriptParameters\" value=\"\" />\r\n        <option name=\"taskDescriptions\">\r\n          <list />\r\n        </option>\r\n        <option name=\"taskNames\">\r\n          <list>\r\n            <option value=\":test\" />\r\n            <option value=\"--tests\" />\r\n            <option value=\"&quot;MultiplayerTester&quot;\" />\r\n          </list>\r\n        </option>\r\n        <option name=\"vmOptions\" />\r\n      </ExternalSystemSettings>\r\n      <ExternalSystemDebugServerProcess>false</ExternalSystemDebugServerProcess>\r\n      <ExternalSystemReattachDebugProcess>true</ExternalSystemReattachDebugProcess>\r\n      <DebugAllEnabled>false</DebugAllEnabled>\r\n      <RunAsTest>true</RunAsTest>\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration name=\"MultiplayerTester.testPacket01\" type=\"GradleRunConfiguration\" factoryName=\"Gradle\" temporary=\"true\">\r\n      <ExternalSystemSettings>\r\n        <option name=\"executionName\" />\r\n        <option name=\"externalProjectPath\" value=\"$PROJECT_DIR$\" />\r\n        <option name=\"externalSystemIdString\" value=\"GRADLE\" />\r\n        <option name=\"scriptParameters\" value=\"\" />\r\n        <option name=\"taskDescriptions\">\r\n          <list />\r\n        </option>\r\n        <option name=\"taskNames\">\r\n          <list>\r\n            <option value=\":test\" />\r\n            <option value=\"--tests\" />\r\n            <option value=\"&quot;MultiplayerTester.testPacket01&quot;\" />\r\n          </list>\r\n        </option>\r\n        <option name=\"vmOptions\" />\r\n      </ExternalSystemSettings>\r\n      <ExternalSystemDebugServerProcess>false</ExternalSystemDebugServerProcess>\r\n      <ExternalSystemReattachDebugProcess>true</ExternalSystemReattachDebugProcess>\r\n      <DebugAllEnabled>false</DebugAllEnabled>\r\n      <RunAsTest>true</RunAsTest>\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration name=\"MultiplayerTester.testPacket02Constructor\" type=\"GradleRunConfiguration\" factoryName=\"Gradle\" temporary=\"true\">\r\n      <ExternalSystemSettings>\r\n        <option name=\"executionName\" />\r\n        <option name=\"externalProjectPath\" value=\"$PROJECT_DIR$\" />\r\n        <option name=\"externalSystemIdString\" value=\"GRADLE\" />\r\n        <option name=\"scriptParameters\" value=\"\" />\r\n        <option name=\"taskDescriptions\">\r\n          <list />\r\n        </option>\r\n        <option name=\"taskNames\">\r\n          <list>\r\n            <option value=\":test\" />\r\n            <option value=\"--tests\" />\r\n            <option value=\"&quot;MultiplayerTester.testPacket02Constructor&quot;\" />\r\n          </list>\r\n        </option>\r\n        <option name=\"vmOptions\" />\r\n      </ExternalSystemSettings>\r\n      <ExternalSystemDebugServerProcess>false</ExternalSystemDebugServerProcess>\r\n      <ExternalSystemReattachDebugProcess>true</ExternalSystemReattachDebugProcess>\r\n      <DebugAllEnabled>false</DebugAllEnabled>\r\n      <RunAsTest>true</RunAsTest>\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration name=\"iLaby [run]\" type=\"GradleRunConfiguration\" factoryName=\"Gradle\" singleton=\"false\" nameIsGenerated=\"true\">\r\n      <ExternalSystemSettings>\r\n        <option name=\"executionName\" />\r\n        <option name=\"externalProjectPath\" value=\"$PROJECT_DIR$\" />\r\n        <option name=\"externalSystemIdString\" value=\"GRADLE\" />\r\n        <option name=\"scriptParameters\" value=\"--scan\" />\r\n        <option name=\"taskDescriptions\">\r\n          <list />\r\n        </option>\r\n        <option name=\"taskNames\">\r\n          <list>\r\n            <option value=\"run\" />\r\n          </list>\r\n        </option>\r\n        <option name=\"vmOptions\" />\r\n      </ExternalSystemSettings>\r\n      <ExternalSystemDebugServerProcess>true</ExternalSystemDebugServerProcess>\r\n      <ExternalSystemReattachDebugProcess>true</ExternalSystemReattachDebugProcess>\r\n      <DebugAllEnabled>false</DebugAllEnabled>\r\n      <RunAsTest>false</RunAsTest>\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <list>\r\n      <item itemvalue=\"Gradle.iLaby [run]\" />\r\n      <item itemvalue=\"Gradle.MultiplayerTester\" />\r\n      <item itemvalue=\"Gradle.MultiplayerTester.testPacket02Constructor\" />\r\n      <item itemvalue=\"Gradle.MultiplayerTester.testPacket01\" />\r\n    </list>\r\n    <recent_temporary>\r\n      <list>\r\n        <item itemvalue=\"Gradle.MultiplayerTester.testPacket01\" />\r\n        <item itemvalue=\"Gradle.MultiplayerTester.testPacket02Constructor\" />\r\n        <item itemvalue=\"Gradle.MultiplayerTester\" />\r\n        <item itemvalue=\"Gradle.MultiplayerTester\" />\r\n        <item itemvalue=\"Gradle.MultiplayerTester.testPacket02Constructor\" />\r\n      </list>\r\n    </recent_temporary>\r\n  </component>\r\n  <component name=\"SharedIndexes\">\r\n    <attachedChunks>\r\n      <set>\r\n        <option value=\"jdk-21.0.2-corretto-21.0.2-4caba194b151-51586f01\" />\r\n      </set>\r\n    </attachedChunks>\r\n  </component>\r\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"application-level\" UseSingleDictionary=\"true\" transferred=\"true\" />\r\n  <component name=\"TaskManager\">\r\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\r\n      <changelist id=\"3506ab6d-0407-47f2-a7e8-78ebc867e577\" name=\"Changes\" comment=\"\" />\r\n      <created>1714562409879</created>\r\n      <option name=\"number\" value=\"Default\" />\r\n      <option name=\"presentableId\" value=\"Default\" />\r\n      <updated>1714562409879</updated>\r\n      <workItem from=\"1714562410886\" duration=\"908000\" />\r\n      <workItem from=\"1714687853059\" duration=\"1015000\" />\r\n      <workItem from=\"1714731678095\" duration=\"398000\" />\r\n      <workItem from=\"1714740938116\" duration=\"2592000\" />\r\n      <workItem from=\"1714743658125\" duration=\"732000\" />\r\n      <workItem from=\"1714747759256\" duration=\"7383000\" />\r\n      <workItem from=\"1714847163651\" duration=\"324000\" />\r\n      <workItem from=\"1714924570656\" duration=\"7744000\" />\r\n    </task>\r\n    <task id=\"LOCAL-00001\" summary=\"it's working\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1714665384490</created>\r\n      <option name=\"number\" value=\"00001\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00001\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1714665384490</updated>\r\n    </task>\r\n    <option name=\"localTasksCounter\" value=\"2\" />\r\n    <servers />\r\n  </component>\r\n  <component name=\"TypeScriptGeneratedFilesManager\">\r\n    <option name=\"version\" value=\"3\" />\r\n  </component>\r\n  <component name=\"Vcs.Log.Tabs.Properties\">\r\n    <option name=\"TAB_STATES\">\r\n      <map>\r\n        <entry key=\"MAIN\">\r\n          <value>\r\n            <State />\r\n          </value>\r\n        </entry>\r\n      </map>\r\n    </option>\r\n  </component>\r\n  <component name=\"VcsManagerConfiguration\">\r\n    <MESSAGE value=\"it's working\" />\r\n    <option name=\"LAST_COMMIT_MESSAGE\" value=\"it's working\" />\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	(revision 2a081a32d6cdbb313837c52de84c0543f0763b2d)
+++ b/.idea/workspace.xml	(date 1715013292657)
@@ -5,11 +5,21 @@
   </component>
   <component name="ChangeListManager">
     <list default="true" id="3506ab6d-0407-47f2-a7e8-78ebc867e577" name="Changes" comment="it's working">
-      <change beforePath="$PROJECT_DIR$/.idea/misc.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/misc.xml" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/src/main/java/org/networking/Packet26InGasRoom.java" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/src/main/java/org/entities/player/Player.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/org/entities/player/Player.java" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/src/main/java/org/game/Map/Door.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/org/game/Map/Door.java" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/src/main/java/org/game/Map/EdgeManager.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/org/game/Map/EdgeManager.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/main/java/org/entities/villain/Villain.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/org/entities/villain/Villain.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/main/java/org/game/Isten.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/org/game/Isten.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/main/java/org/networking/ClientMap.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/org/networking/ClientMap.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/main/java/org/networking/DeathHandler.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/org/networking/PlayerStatusHandler.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/main/java/org/networking/GameClient.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/org/networking/GameClient.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/main/java/org/networking/GameServer.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/org/networking/GameServer.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/main/java/org/networking/HandlerManager.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/org/networking/HandlerManager.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/main/java/org/networking/MapHandler.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/org/networking/MapHandler.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/main/java/org/networking/Packet.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/org/networking/Packet.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/main/java/org/networking/Packet04UnitRoom.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/org/networking/Packet04UnitRoom.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/main/java/org/networking/VillainHandler.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/org/networking/VillainHandler.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/test/MultiplayerTester.java" beforeDir="false" afterPath="$PROJECT_DIR$/test/MultiplayerTester.java" afterDir="false" />
     </list>
     <option name="SHOW_DIALOG" value="false" />
     <option name="HIGHLIGHT_CONFLICTS" value="true" />
@@ -39,8 +49,8 @@
   <component name="FileTemplateManagerImpl">
     <option name="RECENT_TEMPLATES">
       <list>
-        <option value="Class" />
         <option value="Interface" />
+        <option value="Class" />
       </list>
     </option>
   </component>
@@ -169,7 +179,7 @@
         <option name="executionName" />
         <option name="externalProjectPath" value="$PROJECT_DIR$" />
         <option name="externalSystemIdString" value="GRADLE" />
-        <option name="scriptParameters" value="--scan" />
+        <option name="scriptParameters" value="--scan --stacktrace" />
         <option name="taskDescriptions">
           <list />
         </option>
Index: src/main/java/org/networking/Packet04UnitRoom.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package main.java.org.networking;\r\n\r\npublic class Packet04UnitRoom extends Packet {\r\n\r\n    private float x;\r\n    private float y;\r\n    private int type;\r\n    public Packet04UnitRoom(byte[] data) {\r\n        super(04);\r\n        String[] dataArray = readData(data).split(\",\");\r\n        this.x = Float.parseFloat(dataArray[0]);\r\n        this.y = Float.parseFloat(dataArray[1]);\r\n        this.type = Integer.parseInt(dataArray[2]);\r\n        //System.out.println(\"dataArray0: \" + dataArray[0] + \"dataArray1: \" + dataArray[1] + \"dataArray2: \" + dataArray[2]);\r\n\r\n    }\r\n\r\n    public Packet04UnitRoom(float x, float y, int type) {\r\n        super(04);\r\n        this.x = x;\r\n        this.y = y;\r\n        this.type = type;\r\n    }\r\n\r\n    @Override\r\n    public void writeData(GameClient client) {\r\n        client.sendData(getData());\r\n    }\r\n\r\n    @Override\r\n    public void writeData(GameServer server) {\r\n        server.sendDataToAllClients(getData());\r\n    }\r\n\r\n    @Override\r\n    public byte[] getData() {\r\n        return (\"04\" + this.x + \",\" + this.y + \",\" + this.type).getBytes();\r\n    }\r\n\r\n    public int getType() {\r\n        return type;\r\n    }\r\n\r\n    public float getX() {\r\n        return x;\r\n    }\r\n\r\n    public float getY() {\r\n        return y;\r\n    }\r\n}\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/networking/Packet04UnitRoom.java b/src/main/java/org/networking/Packet04UnitRoom.java
--- a/src/main/java/org/networking/Packet04UnitRoom.java	(revision 2a081a32d6cdbb313837c52de84c0543f0763b2d)
+++ b/src/main/java/org/networking/Packet04UnitRoom.java	(date 1715012031001)
@@ -1,5 +1,7 @@
 package main.java.org.networking;
 
+import java.util.Arrays;
+
 public class Packet04UnitRoom extends Packet {
 
     private float x;
@@ -7,14 +9,17 @@
     private int type;
     public Packet04UnitRoom(byte[] data) {
         super(04);
+
+
         String[] dataArray = readData(data).split(",");
-        this.x = Float.parseFloat(dataArray[0]);
+        this.x = Float.parseFloat(dataArray[0]);;
         this.y = Float.parseFloat(dataArray[1]);
         this.type = Integer.parseInt(dataArray[2]);
         //System.out.println("dataArray0: " + dataArray[0] + "dataArray1: " + dataArray[1] + "dataArray2: " + dataArray[2]);
 
     }
 
+
     public Packet04UnitRoom(float x, float y, int type) {
         super(04);
         this.x = x;
Index: src/main/java/org/networking/MapHandler.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package main.java.org.networking;\r\n\r\nimport main.java.org.game.Isten;\r\nimport main.java.org.game.Map.*;\r\nimport main.java.org.linalg.Vec2;\r\n\r\nimport java.awt.event.KeyEvent;\r\nimport java.util.Collections;\r\nimport java.util.List;\r\n\r\npublic class MapHandler extends ServerSideHandler {\r\n\r\n    int sec = 0;\r\n    boolean stop = true;\r\n    double delta = 0;\r\n\r\n\r\n    @Override\r\n    public void create(GameServer server) {\r\n        this.server = server;\r\n        this.isten = server.isten;\r\n        isten.getMap().init(isten);\r\n        isInitialized = true;\r\n        sendDataToWaitingClients();\r\n    }\r\n\r\n    @Override\r\n    public void sendDataToClient(PlayerMP client) {\r\n\r\n        if(!isInitialized) {\r\n            if(!waitingClients.contains(client)) waitingClients.add(client);\r\n            return;\r\n        }\r\n\r\n        Map map = isten.getMap();\r\n        for(int i = 0; i < map.getMapRowSize(); i++) {\r\n            for(int j = 0; j < map.getMapColumnSize(); j++) {\r\n                Vec2 pos = map.getUnitRooms()[i][j].getPosition();\r\n                int type = map.getUnitRooms()[i][j].getOwnerRoom().getRoomType().ordinal();\r\n                Packet04UnitRoom packet = new Packet04UnitRoom(pos.x, pos.y, type);\r\n                server.sendData(packet.getData(), client.ipAddress, client.port);\r\n            }\r\n        }\r\n\r\n\r\n        //\r\n        for(int i = 0; i < map.getEdgeManager().getRoomEdges().size(); i++) {\r\n            EdgeBetweenRooms re = map.getEdgeManager().getRoomEdges().get(i);\r\n            for (int j = 0; j < re.getWalls().size(); j++) {\r\n                EdgePiece edgePiece = re.getWalls().get(j);\r\n                Vec2 pos = edgePiece.getCollider().getPosition();\r\n                Vec2 scale = edgePiece.getCollider().getScale();\r\n                Packet20Wall packet = new Packet20Wall(pos.x, pos.y, scale.x, scale.y, edgePiece.isDoor());\r\n                server.sendData(packet.getData(), client.ipAddress, client.port);\r\n            }\r\n            /*\r\n            try {\r\n                Thread.sleep(5);\r\n            } catch (InterruptedException e) {\r\n                throw new RuntimeException(e);\r\n            }\r\n\r\n             */\r\n        }\r\n\r\n\r\n\r\n    }\r\n\r\n    @Override\r\n    public void sendDataToAllClients(Packet packet) {\r\n        packet.writeData(server);\r\n    }\r\n\r\n    @Override\r\n    public void update(Isten isten, double deltaTime) {\r\n        //for testing\r\n        if(isten.getInputHandler().isKeyReleased(KeyEvent.VK_SPACE)){\r\n            stop = !stop;\r\n            //if(stop) printMap();\r\n        }\r\n\r\n        if(!stop) {\r\n            delta += deltaTime;\r\n            if (delta > 1) {\r\n                //TESTCASE 1:::\r\n\r\n\r\n                if(sec %3==0){\r\n                    Vec2 pos = isten.getMap().addDoorToEdgeWithoutDoor(isten);\r\n                    handleAddOrDeleteDoor(pos, true);\r\n                    //System.out.println(\"ajtoaddolas tortent\");\r\n                }\r\n                else{\r\n                    Vec2 pos = isten.getMap().TakeOutDoor(isten,true);\r\n                    if(pos.x != -1 && pos.y != -1) {\r\n                        handleAddOrDeleteDoor(pos, false);\r\n                        //stop = true;\r\n                        //System.out.println(\"edgeNum: \"+isten.getMap().getEdgeManager().getRoomEdges().size());\r\n                        //System.out.println(\"doorNum: \"+isten.getMap().getEdgeManager().getDoorNum());\r\n                        //System.out.println(\"ajtokivetel tortent\");\r\n                    }\r\n\r\n\r\n                }\r\n\r\n\r\n\r\n\r\n\r\n                //TESTCASE 2:\r\n                if (sec % 4 == 0) {\r\n                    Collections.shuffle(isten.getMap().getRooms());\r\n\r\n                    Room r1 = isten.getMap().getRooms().get(0);\r\n                    Room r2 = isten.getMap().getRooms().get(0).getPhysicallyAdjacentRooms().get(0);\r\n                    handleUnitRoomChange(r2.getUnitRooms(), r1.getRoomType().ordinal());\r\n                    handleWallDeletion(isten.getMap().getEdgeManager().getEdgeBetweenRooms(r1, r2));\r\n                    isten.getMap().mergeRooms(r1, r2, isten);\r\n                    handleRoomEdges(r1);\r\n\r\n                    //System.out.println(\"r1 adjacentrooms Number: \" + rooms.get(0).getPhysicallyAdjacentRooms().size());\r\n\r\n                }\r\n                //TESTCASE 3:\r\n\r\n                if((sec+2)%4==0) {\r\n                    for (Room splittable : isten.getMap().getRooms()) {\r\n                        int newID;\r\n                        if ((newID = isten.getMap().splitRooms(splittable, isten)) != -1) {\r\n\r\n                            for(Room room: isten.getMap().getRooms()) {\r\n                                if(room.getID() == newID) {\r\n                                    handleUnitRoomChange(room.getUnitRooms(), room.getRoomType().ordinal());\r\n                                    handleWallAddition(isten.getMap().getEdgeManager().getEdgeBetweenRooms(splittable, room));\r\n                                    handleRoomEdges(room);\r\n                                    handleRoomEdges(splittable);\r\n                                    break;\r\n                                }\r\n                            }\r\n                            //System.out.println(\"sikerult a split\");\r\n                            //System.out.println(splittable.getID() + \" adjacentrooms: \" + splittable.getPhysicallyAdjacentRooms().size());\r\n                            //System.out.println(splittable.getID() + \" Dooradjacentrooms: \" + splittable.getDoorAdjacentRooms().size());\r\n                            //stop = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n\r\n\r\n\r\n\r\n                sec++;\r\n                delta = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    private void handleAddOrDeleteDoor(Vec2 pos, boolean isDoor) {\r\n        Packet22EdgePieceChanged packet = new Packet22EdgePieceChanged(pos.x,\r\n                pos.y,\r\n                isDoor);\r\n        sendDataToAllClients(packet);\r\n        /*\r\n        try {\r\n            Thread.sleep(5);\r\n        } catch (InterruptedException e) {\r\n            throw new RuntimeException(e);\r\n        }\r\n\r\n         */\r\n    }\r\n\r\n    public void handleRoomEdges(Room room) {\r\n        for(EdgeBetweenRooms edgeBetweenRooms: isten.getMap().getEdgeManager().getAllEdgeForARoom(room)) {\r\n            for(EdgePiece edgePiece: edgeBetweenRooms.getWalls()) {\r\n                Packet22EdgePieceChanged packet = new Packet22EdgePieceChanged(edgePiece.getPosition().x,\r\n                        edgePiece.getPosition().y,\r\n                        edgePiece.isDoor());\r\n                sendDataToAllClients(packet);\r\n                /*\r\n                try {\r\n                    Thread.sleep(5);\r\n                } catch (InterruptedException e) {\r\n                    throw new RuntimeException(e);\r\n                }\r\n\r\n                 */\r\n            }\r\n        }\r\n    }\r\n\r\n    public void handleWallAddition(EdgeBetweenRooms edge) {\r\n        for(EdgePiece edgePiece: edge.getWalls()) {\r\n            Packet20Wall packet = new Packet20Wall(edgePiece.getPosition().x, edgePiece.getPosition().y,\r\n                    edgePiece.getCollider().getScale().x, edgePiece.getCollider().getScale().y,\r\n                    edgePiece.isDoor());\r\n            sendDataToAllClients(packet);\r\n            /*\r\n            try {\r\n                Thread.sleep(5);\r\n            } catch (InterruptedException e) {\r\n                throw new RuntimeException(e);\r\n            }\r\n\r\n             */\r\n        }\r\n    }\r\n    public void handleWallDeletion(EdgeBetweenRooms edge) {\r\n        for(EdgePiece edgePiece: edge.getWalls()) {\r\n            Packet23WallDelete packet = new Packet23WallDelete(edgePiece.getPosition().x,\r\n                    edgePiece.getPosition().y);\r\n            sendDataToAllClients(packet);\r\n            /*\r\n            try {\r\n                Thread.sleep(5);\r\n            } catch (InterruptedException e) {\r\n                throw new RuntimeException(e);\r\n            }\r\n\r\n             */\r\n        }\r\n    }\r\n\r\n    public void handleUnitRoomChange(List<UnitRoom> unitRooms, int type) {\r\n\r\n        for(UnitRoom unitRoom: unitRooms) {\r\n            Packet04UnitRoom packet = new Packet04UnitRoom(unitRoom.getPosition().x,\r\n                    unitRoom.getPosition().y, type);\r\n            sendDataToAllClients(packet);\r\n            /*\r\n            try {\r\n                Thread.sleep(5);\r\n            } catch (InterruptedException e) {\r\n                throw new RuntimeException(e);\r\n            }\r\n\r\n             */\r\n        }\r\n\r\n    }\r\n\r\n    public void CheckIfPlayerOpenedDoor(Packet25PlayerPosForDoorOpen packet) {\r\n\r\n        Vec2 doorPos = isten.getMap().getEdgeManager().OpenDoor(new Vec2(packet.getX(), packet.getY()));\r\n        if(doorPos.x == -1 && doorPos.y == -1) return;\r\n\r\n        Packet24DoorOpen packet24DoorOpen = new Packet24DoorOpen(doorPos.x, doorPos.y, false);\r\n        packet24DoorOpen.writeData(isten.getSocketClient());\r\n\r\n    }\r\n\r\n    public void handleDoorOpen(Packet24DoorOpen packet) {\r\n\r\n        for(int i = 0; i < isten.getMap().getEdgeManager().getRoomEdges().size(); i++) {\r\n            EdgeBetweenRooms re = isten.getMap().getEdgeManager().getRoomEdges().get(i);\r\n            for (int j = 0; j < re.getWalls().size(); j++) {\r\n                EdgePiece edgePiece = re.getWalls().get(j);\r\n                if(packet.getX() == edgePiece.getPosition().x &&\r\n                        packet.getY() == edgePiece.getPosition().y) {\r\n                    edgePiece.getCollider().setSolidity(packet.isSolid());\r\n                }\r\n            }\r\n        }\r\n\r\n        sendDataToAllClients(packet);\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/networking/MapHandler.java b/src/main/java/org/networking/MapHandler.java
--- a/src/main/java/org/networking/MapHandler.java	(revision 2a081a32d6cdbb313837c52de84c0543f0763b2d)
+++ b/src/main/java/org/networking/MapHandler.java	(date 1715012048224)
@@ -257,6 +257,7 @@
             EdgeBetweenRooms re = isten.getMap().getEdgeManager().getRoomEdges().get(i);
             for (int j = 0; j < re.getWalls().size(); j++) {
                 EdgePiece edgePiece = re.getWalls().get(j);
+                if(edgePiece == null || edgePiece.getPosition() == null) return;
                 if(packet.getX() == edgePiece.getPosition().x &&
                         packet.getY() == edgePiece.getPosition().y) {
                     edgePiece.getCollider().setSolidity(packet.isSolid());
