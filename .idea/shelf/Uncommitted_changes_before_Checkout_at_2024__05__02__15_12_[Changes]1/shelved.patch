Index: src/main/java/org/game/Map/Map.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package main.java.org.game.Map;\r\n\r\nimport main.java.org.game.Graphics.Image;\r\nimport main.java.org.game.Isten;\r\nimport main.java.org.game.physics.Collider;\r\nimport main.java.org.game.updatable.Updatable;\r\nimport main.java.org.linalg.Vec2;\r\n\r\nimport java.util.*;\r\n\r\n\r\npublic class Map extends Updatable {\r\n    private Mapgenerator mapgenerator;\r\n    ArrayList<Room> rooms;\r\n    private UnitRoom[][] unitRooms;\r\n    private final int mapRowSize;\r\n    private final int mapColumnSize;\r\n    private EdgeManager edgeManager;\r\n    private final int minRoomSize;\r\n    private boolean isGenerated = false;\r\n    //private boolean\r\n    @Override\r\n    public void onStart(Isten isten) {\r\n\r\n        Mapgenerator mapgenerator = new Mapgenerator(this, isten);\r\n        mapgenerator.generateSideWalls();\r\n        //printMap();\r\n    }\r\n\r\n    public void init(Isten isten) {\r\n        this.mapgenerator = new Mapgenerator(this, isten);\r\n        mapgenerator.generate(minRoomSize);\r\n        isGenerated = true;\r\n    }\r\n\r\n    public Map(Isten isten, int rowNumber, int columnNumber, int minRoomSize){\r\n        this.mapRowSize = rowNumber;\r\n        this.mapColumnSize = columnNumber;\r\n        this.minRoomSize = minRoomSize;\r\n        //unitrooms is set in the generator --> onstart\r\n        this.rooms = new ArrayList<>();\r\n        this.edgeManager = new EdgeManager(isten);\r\n        initUnitRooms();\r\n\r\n    }\r\n\r\n    //for testing\r\n    boolean merged = false;\r\n    double delta = 0;\r\n    int cnt = 0;\r\n    int r = 0;\r\n    @Override\r\n    public void onUpdate(Isten isten, double deltaTime) {\r\n        //for testing\r\n        delta += deltaTime;\r\n        if (delta > 3 && cnt < 4 && !merged) {\r\n            //mergeRooms(rooms.get(0), rooms.get(0).getAdjacentRooms().get(0), isten);\r\n            /*if (!splitRooms(rooms.get(r), isten)) r++;\r\n            else {\r\n                r = 0;\r\n            }\r\n\r\n             */\r\n            System.out.println();\r\n            System.out.println();\r\n            //printMap();\r\n            cnt++;\r\n            delta = 0;\r\n            merged = true;\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void onDestroy() {\r\n\r\n    }\r\n    public void initUnitRooms(){\r\n        unitRooms = new UnitRoom[mapRowSize][mapColumnSize];\r\n        for(int i = 0; i<mapRowSize;i++)\r\n        {\r\n            for(int j = 0;j<mapColumnSize;j++)\r\n            {\r\n                unitRooms[i][j] = new UnitRoom(new Vec2(j,i));\r\n            }\r\n        }\r\n    }\r\n\r\n    //csak akkor ha minden ajto nyitva van!!\r\n    //a slitelesnel csak a minroomsize fele engedelyezett\r\n    private boolean splitRooms(Room r1, Isten isten)\r\n    {\r\n        if(r1.getUnitRooms().size() < minRoomSize) return false;\r\n        //egyenlőre minden szoba ami splittel lesz createlve ilyen type-val rendelkezik\r\n        int newID = generateNewRoomID(); //már kész van, teszt miatt nincs hasznalva\r\n        //int newId = 999;\r\n        Room newRoom = new Room(newID);\r\n        int lowestRowIdx = getRoomWithLowestRowIdx(r1);\r\n        ArrayList<UnitRoom> addableUnitRooms = new ArrayList<>();\r\n        int distance = 0;\r\n        ArrayList<UnitRoom> UnitRoomsWithDistanceXFromLowestRow;\r\n        //addig, amíg az új szoba a méret fele nem lesz\r\n        while(addableUnitRooms.size()<r1.getUnitRooms().size()/2){\r\n            UnitRoomsWithDistanceXFromLowestRow=getUnitRoomsWithXDistanceFromLowestRowIdxInOrderByColumn(r1,lowestRowIdx,distance++); //tavolsag novelese, es igy soronkent egyesevel balrol jobbra az osszes unitroom hozzaadasa, amig kell\r\n            for(UnitRoom addableUnitRoom:UnitRoomsWithDistanceXFromLowestRow){\r\n                if(addableUnitRooms.size()<r1.getUnitRooms().size()/2 )\r\n                {\r\n                    addableUnitRooms.add(addableUnitRoom);\r\n                }\r\n\r\n            }\r\n        }\r\n        ArrayList<UnitRoom> oldRoomWithoutNewRoom = getDifference(r1.getUnitRooms(),addableUnitRooms);\r\n        //ellenorzom, hogy osszefuggoek lennének-e: ha igen:\r\n        if( kruskalAlgoImplementation(oldRoomWithoutNewRoom) && kruskalAlgoImplementation(addableUnitRooms)) {\r\n            // removeoljuk a szomszedos roomok szomszedossagi listaibol a szobat, es a func vegen hozzaadjuk a ket szetvalasztott szoba egyiket/mindekettot\r\n            for(Room neighbourRoom : r1.getAdjacentRooms()){\r\n                neighbourRoom.getAdjacentRooms().remove(r1);\r\n            }\r\n            for (UnitRoom addUnitRoomToNewRoom : addableUnitRooms) {\r\n                //kivesszük az előző szobából a  aunitroomot\r\n                addUnitRoomToNewRoom.getOwnerRoom().getUnitRooms().remove(addUnitRoomToNewRoom);\r\n                addUnitRoomToNewRoom.setOwnerRoom(newRoom);\r\n                //hozzáadjuk az új szobához a unitroomot\r\n                newRoom.getUnitRooms().add(addUnitRoomToNewRoom);\r\n            }\r\n            rooms.add(newRoom);\r\n            newRoom.setAdjacentRooms();\r\n            r1.setAdjacentRooms();\r\n\r\n            //set the images\r\n            for(UnitRoom unitRoom : newRoom.getUnitRooms()) {\r\n                unitRoom.addRightImage(isten);\r\n            }\r\n            //update nodeRooms and generate the new ones\r\n            //also updates the images and colliders\r\n            edgeManager.updateEdgesAfterSplit(r1, newRoom);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n\r\n    public static ArrayList<UnitRoom> getDifference(ArrayList<UnitRoom> u1, ArrayList<UnitRoom> u2)\r\n    {\r\n        ArrayList<UnitRoom> difference = new ArrayList<>();\r\n        for (UnitRoom element : u1) {\r\n            if (!u2.contains(element)) {\r\n                difference.add(element);\r\n            }\r\n        }\r\n        return difference;\r\n    }\r\n    //nem biztos hogy így a legjobb\r\n    private boolean wouldRoomBeCoherent(ArrayList<UnitRoom> newRoomUnits)\r\n    {\r\n        UnitRoom starterRoom = newRoomUnits.get(0);\r\n        ArrayList<UnitRoom> coherentGraph = new ArrayList<>();\r\n        coherentGraph.add(starterRoom);\r\n        for(int i = 0;i<newRoomUnits.size();i++){\r\n            for(UnitRoom unitRoomToBeAddedToGraph : newRoomUnits){\r\n                 /*ha a size i-vel egyenlő, vagy kisebb nála, akkor tudjuk, hogy nem alkotnak összefüggő gráfot a UnitRoomok a Roomban,\r\n                    mert különben az előző körhöz képest legalább 1-et fel kellett volna tuidjak venni, vagy pedig már előtte többet kellett volna tudjak felvenni,\r\n                    rekurzív gondolat, mukodik (remelem)*/\r\n                if(coherentGraph.size()> i)\r\n                {\r\n                    if (!unitRoomToBeAddedToGraph.equals(coherentGraph.get(i))\r\n                            && !coherentGraph.contains(unitRoomToBeAddedToGraph)\r\n                            && unitRoomToBeAddedToGraph.isAdjacent(coherentGraph.get(i)))\r\n                    {\r\n                        coherentGraph.add(unitRoomToBeAddedToGraph);\r\n                        //break; ezzel valszeg effektivebb\r\n                    }\r\n                }\r\n                else{\r\n                    System.out.println(\"Nem lennenek koherensek a szobak\");\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        //mivel minden indexen vegig tudtunk menni ezert tudunk truet returnolni, azert biztonsag kedveert meg egy kontrollt bennhagyok\r\n        if(coherentGraph.size() == newRoomUnits.size()) return true;\r\n            //hogyha nem egyenlok akkor false menjen ki, bar egyenloknek kene lenniuk\r\n        else return false;\r\n    }\r\n    //elozo fv, vagyis wouldRoomBeCoherent atirasa generikusra, es akkor egy wouldMapBeCoherent fv-t is helyettesit.\r\n    private<T extends Graph> boolean kruskalAlgoImplementation(ArrayList<T> newCoherentElements)\r\n    {\r\n        T starterRoom = newCoherentElements.get(0);\r\n        ArrayList<T> coherentGraph = new ArrayList<>();\r\n        coherentGraph.add(starterRoom);\r\n        for(int i = 0;i<newCoherentElements.size();i++){\r\n            for(T ElementToBeAddedToGraph : newCoherentElements){\r\n                 /*ha a size i-vel egyenlő, vagy kisebb nála, akkor tudjuk, hogy nem alkotnak összefüggő gráfot a UnitRoomok a Roomban,\r\n                    mert különben az előző körhöz képest legalább 1-et fel kellett volna tuidjak venni, vagy pedig már előtte többet kellett volna tudjak felvenni,\r\n                    rekurzív gondolat, mukodik (remelem)*/\r\n                if(coherentGraph.size()> i)\r\n                {\r\n                    if (!ElementToBeAddedToGraph.equals(coherentGraph.get(i))\r\n                            && !coherentGraph.contains(ElementToBeAddedToGraph)\r\n                            && ElementToBeAddedToGraph.isAdjacent(coherentGraph.get(i)))\r\n                    {\r\n                        coherentGraph.add(ElementToBeAddedToGraph);\r\n                        //break; ezzel valszeg effektivebb\r\n                    }\r\n                }\r\n                else{\r\n                    System.out.println(\"Nem lennenek koherensek a szobak\");\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        //mivel minden indexen vegig tudtunk menni ezert tudunk truet returnolni, azert biztonsag kedveert meg egy kontrollt bennhagyok\r\n        if(coherentGraph.size() == newCoherentElements.size()) return true;\r\n            //hogyha nem egyenlok akkor false menjen ki, bar egyenloknek kene lenniuk\r\n        else return false;\r\n    }\r\n\r\n    //function hogy megtalaljam a legkisebb sorindexet a tombben, viszonyitasi parameter lesz.\r\n    // splitRooms func-on belül használva\r\n    private int getRoomWithLowestRowIdx(Room r1) {\r\n        UnitRoom min = unitRooms[mapRowSize-1][mapColumnSize-1];\r\n        for(UnitRoom unitRoom : r1.getUnitRooms())\r\n        {\r\n            if(unitRoom.getRowNum()<min.getRowNum())\r\n            {\r\n                min = unitRoom;\r\n            }\r\n        }\r\n        return min.getRowNum();\r\n    }\r\n    //function hogy megtalaljam azon UnitRoomokat, amik egy adott szamu soraban vannak a szobanaka alulrol nezve, amit a distance hataroz meg\r\n    // splitRooms func-on belül használva\r\n    private ArrayList<UnitRoom> getUnitRoomsWithXDistanceFromLowestRowIdxInOrderByColumn(Room r1, int lowestRowIdx, int distance) {\r\n        ArrayList<UnitRoom> ret = new ArrayList<>();\r\n        for(UnitRoom unitRoom: r1.getUnitRooms()){\r\n            if(unitRoom.getRowNum()==lowestRowIdx+distance){\r\n                ret.add(unitRoom);\r\n            }\r\n        }\r\n        ret.sort(Comparator.comparing(UnitRoom::getColNum));\r\n        return ret;\r\n    }\r\n\r\n    //ez a fv a mapgenerátorban is hasonlóan szerepel (colliderek és imagek nélkül)\r\n    private void mergeRooms(Room r1, Room r2, Isten isten) {\r\n        if(!r1.isAdjacent(r2) || r1.getID() == r2.getID()){\r\n            System.err.println(\"cant be merged\");\r\n            return;\r\n        }\r\n        System.out.println(r2.getID() + \"(r2) is merged to (r1)\" + r1.getID());\r\n        //remove r2 and keep r1;\r\n\r\n        //set colliders\r\n\r\n        edgeManager.deleteEdge(r1,r2);\r\n        edgeManager.updateEdgesAfterMerge(r1,r2);\r\n\r\n        for(UnitRoom unitRoom : r2.getUnitRooms()){\r\n            //r1.getUnitRooms().add(unitroom);\r\n            unitRoom.setOwnerRoom(r1);\r\n\r\n            //setting the new images of the deleted room\r\n            //this method cares about the renderable items too\r\n            unitRoom.addRightImage(isten);\r\n        }\r\n\r\n        r1.getUnitRooms().addAll(r2.getUnitRooms()); //insted of this: r1.getUnitRooms().add(unitroom);\r\n\r\n        r1.getAdjacentRooms().remove(r2);\r\n        r2.getAdjacentRooms().remove(r1);\r\n        for(Room adj : r2.getAdjacentRooms()){\r\n            if(!r1.getAdjacentRooms().contains(adj) && !adj.equals(r1)){\r\n                //System.out.println(\"adjroom added in r1: \" + adj.getID());\r\n                r1.getAdjacentRooms().add(adj);\r\n            }\r\n            adj.getAdjacentRooms().remove(r2);\r\n            if(!adj.getAdjacentRooms().contains(r1)) {\r\n                adj.getAdjacentRooms().add(r1);\r\n            }\r\n        }\r\n\r\n        r2.getAdjacentRooms().clear();\r\n        r2.getUnitRooms().clear();\r\n\r\n        //r1.setDiscovered(r2.isDiscovered());\r\n        //r1.setPlayerCount(r1.getPlayerCount() + r2.getPlayerCount());\r\n        //r1.setRoomType(r2.getRoomType());\r\n        r1.setMaxPlayerCount(r1.getMaxPlayerCount() + r2.getMaxPlayerCount());\r\n        rooms.remove(r2);\r\n\r\n\r\n    }\r\n\r\n    //merge the rooms until every room has minimumm size of the given number\r\n    private void printMap(){\r\n        for(int i = 0;i < mapRowSize;i++){ //test\r\n            for(int j = 0; j< mapColumnSize;j++){\r\n                if(unitRooms[i][j].getOwnerRoom().getID() < 10) {\r\n                    System.out.print(unitRooms[i][j].getOwnerRoom().getID() + \"     \");\r\n                }\r\n                else if(unitRooms[i][j].getOwnerRoom().getID() >= 10 && unitRooms[i][j].getOwnerRoom().getID() < 100) {\r\n                    System.out.print(unitRooms[i][j].getOwnerRoom().getID() + \"    \");\r\n                }\r\n                else if(unitRooms[i][j].getOwnerRoom().getID() >= 100) {\r\n                    System.out.print(unitRooms[i][j].getOwnerRoom().getID() + \"   \");\r\n                }\r\n            }\r\n            System.out.println();\r\n            System.out.println();\r\n        }\r\n    }\r\n    private int generateNewRoomID(){\r\n        int newID = 0;\r\n        while(true){\r\n            int roomCnt = 0;\r\n            for(Room room : rooms){\r\n                if(room.getID() == newID){\r\n                    newID++;\r\n                    break; //not found, try the next ID\r\n                }\r\n                roomCnt++;\r\n            }\r\n            if(roomCnt == rooms.size()){\r\n                return newID;\r\n            }\r\n\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n    public void setRooms(ArrayList<Room> rooms) {this.rooms = rooms;}\r\n\r\n    public void setUnitRooms(UnitRoom[][] unitRooms) {\r\n        this.unitRooms = unitRooms;\r\n    }\r\n\r\n    public ArrayList<Room> getRooms() {\r\n        return rooms;\r\n    }\r\n\r\n    public UnitRoom[][] getUnitRooms() {\r\n        return unitRooms;\r\n    }\r\n\r\n    public int getMapRowSize() {\r\n        return mapRowSize;\r\n    }\r\n\r\n    public int getMapColumnSize() {\r\n        return mapColumnSize;\r\n    }\r\n    public EdgeManager getEdgeManager(){ return edgeManager;}\r\n    public boolean isGenerated() {\r\n        return isGenerated;\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/game/Map/Map.java b/src/main/java/org/game/Map/Map.java
--- a/src/main/java/org/game/Map/Map.java	
+++ b/src/main/java/org/game/Map/Map.java	
@@ -200,7 +200,6 @@
                             && ElementToBeAddedToGraph.isAdjacent(coherentGraph.get(i)))
                     {
                         coherentGraph.add(ElementToBeAddedToGraph);
-                        //break; ezzel valszeg effektivebb
                     }
                 }
                 else{
Index: .idea/misc.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"ExternalStorageConfigurationManager\" enabled=\"true\" />\r\n  <component name=\"FrameworkDetectionExcludesConfiguration\">\r\n    <file type=\"web\" url=\"file://$PROJECT_DIR$\" />\r\n  </component>\r\n  <component name=\"ProjectRootManager\" version=\"2\" languageLevel=\"JDK_20\" project-jdk-name=\"21\" project-jdk-type=\"JavaSDK\">\r\n    <output url=\"file://$PROJECT_DIR$/out\" />\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/misc.xml b/.idea/misc.xml
--- a/.idea/misc.xml	
+++ b/.idea/misc.xml	
@@ -1,4 +1,3 @@
-<?xml version="1.0" encoding="UTF-8"?>
 <project version="4">
   <component name="ExternalStorageConfigurationManager" enabled="true" />
   <component name="FrameworkDetectionExcludesConfiguration">
