Index: src/main/java/org/game/Map/Map.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package main.java.org.game.Map;\r\n\r\nimport main.java.org.game.Graphics.Image;\r\nimport main.java.org.game.Isten;\r\nimport main.java.org.game.physics.Collider;\r\nimport main.java.org.game.updatable.Updatable;\r\nimport main.java.org.linalg.Vec2;\r\n\r\nimport java.util.*;\r\n\r\n\r\npublic class Map extends Updatable {\r\n    private Mapgenerator mapgenerator;\r\n    ArrayList<Room> rooms;\r\n    private UnitRoom[][] unitRooms;\r\n    private final int mapRowSize;\r\n    private final int mapColumnSize;\r\n    private EdgeManager edgeManager;\r\n    private final int minRoomSize;\r\n    private boolean isGenerated = false;\r\n    //private boolean\r\n\r\n    @Override\r\n    public void onStart(Isten isten) {\r\n\r\n        Mapgenerator mapgenerator = new Mapgenerator(this, isten);\r\n        mapgenerator.generateSideWalls();\r\n        //printMap();\r\n    }\r\n\r\n    public void init(Isten isten) {\r\n        this.edgeManager = new EdgeManager(isten);\r\n        this.mapgenerator = new Mapgenerator(this, isten);\r\n        mapgenerator.generate(minRoomSize);\r\n        isGenerated = true;\r\n    }\r\n\r\n    public Map(int rowNumber, int columnNumber, int minRoomSize){\r\n        this.mapRowSize = rowNumber;\r\n        this.mapColumnSize = columnNumber;\r\n        this.minRoomSize = minRoomSize;\r\n        //unitrooms is set in the generator --> onstart\r\n        this.rooms = new ArrayList<>();\r\n        initUnitRooms();\r\n\r\n    }\r\n\r\n    //for testing\r\n    boolean merged = false;\r\n    double delta = 0;\r\n    int cnt = 0;\r\n    int r = 0;\r\n    @Override\r\n    public void onUpdate(Isten isten, double deltaTime) {\r\n        //for testing\r\n        delta += deltaTime;\r\n        if (delta > 3 && cnt < 4 && !merged) {\r\n            //mergeRooms(rooms.get(0), rooms.get(0).getAdjacentRooms().get(0), isten);\r\n            /*if (!splitRooms(rooms.get(r), isten)) r++;\r\n            else {\r\n                r = 0;\r\n            }\r\n\r\n             */\r\n            System.out.println();\r\n            System.out.println();\r\n            //printMap();\r\n            cnt++;\r\n            delta = 0;\r\n            merged = true;\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void onDestroy() {\r\n\r\n    }\r\n    public void initUnitRooms(){\r\n        unitRooms = new UnitRoom[mapRowSize][mapColumnSize];\r\n        for(int i = 0; i<mapRowSize;i++)\r\n        {\r\n            for(int j = 0;j<mapColumnSize;j++)\r\n            {\r\n                unitRooms[i][j] = new UnitRoom(new Vec2(j,i));\r\n            }\r\n        }\r\n    }\r\n\r\n    //csak akkor ha minden ajto nyitva van!!\r\n    //a slitelesnel csak a minroomsize fele engedelyezett\r\n    private boolean splitRooms(Room r1, Isten isten)\r\n    {\r\n        if(r1.getUnitRooms().size() < minRoomSize) return false;\r\n        //egyenlőre minden szoba ami splittel lesz createlve ilyen type-val rendelkezik\r\n        int newID = generateNewRoomID(); //már kész van, teszt miatt nincs hasznalva\r\n        //int newId = 999;\r\n        Room newRoom = new Room(newID);\r\n        int lowestRowIdx = getRoomWithLowestRowIdx(r1);\r\n        ArrayList<UnitRoom> addableUnitRooms = new ArrayList<>();\r\n        int distance = 0;\r\n        ArrayList<UnitRoom> UnitRoomsWithDistanceXFromLowestRow;\r\n        //addig, amíg az új szoba a méret fele nem lesz\r\n        while(addableUnitRooms.size()<r1.getUnitRooms().size()/2){\r\n            UnitRoomsWithDistanceXFromLowestRow=getUnitRoomsWithXDistanceFromLowestRowIdxInOrderByColumn(r1,lowestRowIdx,distance++); //tavolsag novelese, es igy soronkent egyesevel balrol jobbra az osszes unitroom hozzaadasa, amig kell\r\n            for(UnitRoom addableUnitRoom:UnitRoomsWithDistanceXFromLowestRow){\r\n                if(addableUnitRooms.size()<r1.getUnitRooms().size()/2 )\r\n                {\r\n                    addableUnitRooms.add(addableUnitRoom);\r\n                }\r\n\r\n            }\r\n        }\r\n        ArrayList<UnitRoom> oldRoomWithoutNewRoom = getDifference(r1.getUnitRooms(),addableUnitRooms);\r\n        //ellenorzom, hogy osszefuggoek lennének-e: ha igen:\r\n        if( kruskalAlgoImplementation(oldRoomWithoutNewRoom) && kruskalAlgoImplementation(addableUnitRooms)) {\r\n            // removeoljuk a szomszedos roomok szomszedossagi listaibol a szobat, es a func vegen hozzaadjuk a ket szetvalasztott szoba egyiket/mindekettot\r\n            for(Room neighbourRoom : r1.getAdjacentRooms()){\r\n                neighbourRoom.getAdjacentRooms().remove(r1);\r\n            }\r\n            for (UnitRoom addUnitRoomToNewRoom : addableUnitRooms) {\r\n                //kivesszük az előző szobából a  aunitroomot\r\n                addUnitRoomToNewRoom.getOwnerRoom().getUnitRooms().remove(addUnitRoomToNewRoom);\r\n                addUnitRoomToNewRoom.setOwnerRoom(newRoom);\r\n                //hozzáadjuk az új szobához a unitroomot\r\n                newRoom.getUnitRooms().add(addUnitRoomToNewRoom);\r\n            }\r\n            rooms.add(newRoom);\r\n            newRoom.setAdjacentRooms();\r\n            r1.setAdjacentRooms();\r\n\r\n            //set the images\r\n            for(UnitRoom unitRoom : newRoom.getUnitRooms()) {\r\n                unitRoom.addRightImage(isten);\r\n            }\r\n            //update nodeRooms and generate the new ones\r\n            //also updates the images and colliders\r\n            edgeManager.updateEdgesAfterSplit(r1, newRoom);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n\r\n    public static ArrayList<UnitRoom> getDifference(ArrayList<UnitRoom> u1, ArrayList<UnitRoom> u2)\r\n    {\r\n        ArrayList<UnitRoom> difference = new ArrayList<>();\r\n        for (UnitRoom element : u1) {\r\n            if (!u2.contains(element)) {\r\n                difference.add(element);\r\n            }\r\n        }\r\n        return difference;\r\n    }\r\n    //nem biztos hogy így a legjobb\r\n    private boolean wouldRoomBeCoherent(ArrayList<UnitRoom> newRoomUnits)\r\n    {\r\n        UnitRoom starterRoom = newRoomUnits.get(0);\r\n        ArrayList<UnitRoom> coherentGraph = new ArrayList<>();\r\n        coherentGraph.add(starterRoom);\r\n        for(int i = 0;i<newRoomUnits.size();i++){\r\n            for(UnitRoom unitRoomToBeAddedToGraph : newRoomUnits){\r\n                 /*ha a size i-vel egyenlő, vagy kisebb nála, akkor tudjuk, hogy nem alkotnak összefüggő gráfot a UnitRoomok a Roomban,\r\n                    mert különben az előző körhöz képest legalább 1-et fel kellett volna tuidjak venni, vagy pedig már előtte többet kellett volna tudjak felvenni,\r\n                    rekurzív gondolat, mukodik (remelem)*/\r\n                if(coherentGraph.size()> i)\r\n                {\r\n                    if (!unitRoomToBeAddedToGraph.equals(coherentGraph.get(i))\r\n                            && !coherentGraph.contains(unitRoomToBeAddedToGraph)\r\n                            && unitRoomToBeAddedToGraph.isAdjacent(coherentGraph.get(i)))\r\n                    {\r\n                        coherentGraph.add(unitRoomToBeAddedToGraph);\r\n                        //break; ezzel valszeg effektivebb\r\n                    }\r\n                }\r\n                else{\r\n                    System.out.println(\"Nem lennenek koherensek a szobak\");\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        //mivel minden indexen vegig tudtunk menni ezert tudunk truet returnolni, azert biztonsag kedveert meg egy kontrollt bennhagyok\r\n        if(coherentGraph.size() == newRoomUnits.size()) return true;\r\n            //hogyha nem egyenlok akkor false menjen ki, bar egyenloknek kene lenniuk\r\n        else return false;\r\n    }\r\n    //elozo fv, vagyis wouldRoomBeCoherent atirasa generikusra, es akkor egy wouldMapBeCoherent fv-t is helyettesit.\r\n    private<T extends Graph> boolean kruskalAlgoImplementation(ArrayList<T> newCoherentElements)\r\n    {\r\n        T starterRoom = newCoherentElements.get(0);\r\n        ArrayList<T> coherentGraph = new ArrayList<>();\r\n        coherentGraph.add(starterRoom);\r\n        for(int i = 0;i<newCoherentElements.size();i++){\r\n            for(T ElementToBeAddedToGraph : newCoherentElements){\r\n                 /*ha a size i-vel egyenlő, vagy kisebb nála, akkor tudjuk, hogy nem alkotnak összefüggő gráfot a UnitRoomok a Roomban,\r\n                    mert különben az előző körhöz képest legalább 1-et fel kellett volna tuidjak venni, vagy pedig már előtte többet kellett volna tudjak felvenni,\r\n                    rekurzív gondolat, mukodik (remelem)*/\r\n                if(coherentGraph.size()> i)\r\n                {\r\n                    if (!ElementToBeAddedToGraph.equals(coherentGraph.get(i))\r\n                            && !coherentGraph.contains(ElementToBeAddedToGraph)\r\n                            && ElementToBeAddedToGraph.isAdjacent(coherentGraph.get(i)))\r\n                    {\r\n                        coherentGraph.add(ElementToBeAddedToGraph);\r\n                        //break; ezzel valszeg effektivebb\r\n                    }\r\n                }\r\n                else{\r\n                    System.out.println(\"Nem lennenek koherensek a szobak\");\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        //mivel minden indexen vegig tudtunk menni ezert tudunk truet returnolni, azert biztonsag kedveert meg egy kontrollt bennhagyok\r\n        if(coherentGraph.size() == newCoherentElements.size()) return true;\r\n            //hogyha nem egyenlok akkor false menjen ki, bar egyenloknek kene lenniuk\r\n        else return false;\r\n    }\r\n\r\n    //function hogy megtalaljam a legkisebb sorindexet a tombben, viszonyitasi parameter lesz.\r\n    // splitRooms func-on belül használva\r\n    private int getRoomWithLowestRowIdx(Room r1) {\r\n        UnitRoom min = unitRooms[mapRowSize-1][mapColumnSize-1];\r\n        for(UnitRoom unitRoom : r1.getUnitRooms())\r\n        {\r\n            if(unitRoom.getRowNum()<min.getRowNum())\r\n            {\r\n                min = unitRoom;\r\n            }\r\n        }\r\n        return min.getRowNum();\r\n    }\r\n    //function hogy megtalaljam azon UnitRoomokat, amik egy adott szamu soraban vannak a szobanaka alulrol nezve, amit a distance hataroz meg\r\n    // splitRooms func-on belül használva\r\n    private ArrayList<UnitRoom> getUnitRoomsWithXDistanceFromLowestRowIdxInOrderByColumn(Room r1, int lowestRowIdx, int distance) {\r\n        ArrayList<UnitRoom> ret = new ArrayList<>();\r\n        for(UnitRoom unitRoom: r1.getUnitRooms()){\r\n            if(unitRoom.getRowNum()==lowestRowIdx+distance){\r\n                ret.add(unitRoom);\r\n            }\r\n        }\r\n        ret.sort(Comparator.comparing(UnitRoom::getColNum));\r\n        return ret;\r\n    }\r\n\r\n    //ez a fv a mapgenerátorban is hasonlóan szerepel (colliderek és imagek nélkül)\r\n    private void mergeRooms(Room r1, Room r2, Isten isten) {\r\n        if(!r1.isAdjacent(r2) || r1.getID() == r2.getID()){\r\n            System.err.println(\"cant be merged\");\r\n            return;\r\n        }\r\n        System.out.println(r2.getID() + \"(r2) is merged to (r1)\" + r1.getID());\r\n        //remove r2 and keep r1;\r\n\r\n        //set colliders\r\n\r\n        edgeManager.deleteEdge(r1,r2);\r\n        edgeManager.updateEdgesAfterMerge(r1,r2);\r\n\r\n        for(UnitRoom unitRoom : r2.getUnitRooms()){\r\n            //r1.getUnitRooms().add(unitroom);\r\n            unitRoom.setOwnerRoom(r1);\r\n\r\n            //setting the new images of the deleted room\r\n            //this method cares about the renderable items too\r\n            unitRoom.addRightImage(isten);\r\n        }\r\n\r\n        r1.getUnitRooms().addAll(r2.getUnitRooms()); //insted of this: r1.getUnitRooms().add(unitroom);\r\n\r\n        r1.getAdjacentRooms().remove(r2);\r\n        r2.getAdjacentRooms().remove(r1);\r\n        for(Room adj : r2.getAdjacentRooms()){\r\n            if(!r1.getAdjacentRooms().contains(adj) && !adj.equals(r1)){\r\n                //System.out.println(\"adjroom added in r1: \" + adj.getID());\r\n                r1.getAdjacentRooms().add(adj);\r\n            }\r\n            adj.getAdjacentRooms().remove(r2);\r\n            if(!adj.getAdjacentRooms().contains(r1)) {\r\n                adj.getAdjacentRooms().add(r1);\r\n            }\r\n        }\r\n\r\n        r2.getAdjacentRooms().clear();\r\n        r2.getUnitRooms().clear();\r\n\r\n        //r1.setDiscovered(r2.isDiscovered());\r\n        //r1.setPlayerCount(r1.getPlayerCount() + r2.getPlayerCount());\r\n        //r1.setRoomType(r2.getRoomType());\r\n        r1.setMaxPlayerCount(r1.getMaxPlayerCount() + r2.getMaxPlayerCount());\r\n        rooms.remove(r2);\r\n\r\n\r\n    }\r\n\r\n    //merge the rooms until every room has minimumm size of the given number\r\n    private void printMap(){\r\n        for(int i = 0;i < mapRowSize;i++){ //test\r\n            for(int j = 0; j< mapColumnSize;j++){\r\n                if(unitRooms[i][j].getOwnerRoom().getID() < 10) {\r\n                    System.out.print(unitRooms[i][j].getOwnerRoom().getID() + \"     \");\r\n                }\r\n                else if(unitRooms[i][j].getOwnerRoom().getID() >= 10 && unitRooms[i][j].getOwnerRoom().getID() < 100) {\r\n                    System.out.print(unitRooms[i][j].getOwnerRoom().getID() + \"    \");\r\n                }\r\n                else if(unitRooms[i][j].getOwnerRoom().getID() >= 100) {\r\n                    System.out.print(unitRooms[i][j].getOwnerRoom().getID() + \"   \");\r\n                }\r\n            }\r\n            System.out.println();\r\n            System.out.println();\r\n        }\r\n    }\r\n    private int generateNewRoomID(){\r\n        int newID = 0;\r\n        while(true){\r\n            int roomCnt = 0;\r\n            for(Room room : rooms){\r\n                if(room.getID() == newID){\r\n                    newID++;\r\n                    break; //not found, try the next ID\r\n                }\r\n                roomCnt++;\r\n            }\r\n            if(roomCnt == rooms.size()){\r\n                return newID;\r\n            }\r\n\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n    public void setRooms(ArrayList<Room> rooms) {this.rooms = rooms;}\r\n\r\n    public void setUnitRooms(UnitRoom[][] unitRooms) {\r\n        this.unitRooms = unitRooms;\r\n    }\r\n\r\n    public ArrayList<Room> getRooms() {\r\n        return rooms;\r\n    }\r\n\r\n    public UnitRoom[][] getUnitRooms() {\r\n        return unitRooms;\r\n    }\r\n\r\n    public int getMapRowSize() {\r\n        return mapRowSize;\r\n    }\r\n\r\n    public int getMapColumnSize() {\r\n        return mapColumnSize;\r\n    }\r\n    public EdgeManager getEdgeManager(){ return edgeManager;}\r\n    public boolean isGenerated() {\r\n        return isGenerated;\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/game/Map/Map.java b/src/main/java/org/game/Map/Map.java
--- a/src/main/java/org/game/Map/Map.java	
+++ b/src/main/java/org/game/Map/Map.java	
@@ -19,7 +19,6 @@
     private final int minRoomSize;
     private boolean isGenerated = false;
     //private boolean
-
     @Override
     public void onStart(Isten isten) {
 
@@ -29,18 +28,18 @@
     }
 
     public void init(Isten isten) {
-        this.edgeManager = new EdgeManager(isten);
         this.mapgenerator = new Mapgenerator(this, isten);
         mapgenerator.generate(minRoomSize);
         isGenerated = true;
     }
 
-    public Map(int rowNumber, int columnNumber, int minRoomSize){
+    public Map(Isten isten, int rowNumber, int columnNumber, int minRoomSize){
         this.mapRowSize = rowNumber;
         this.mapColumnSize = columnNumber;
         this.minRoomSize = minRoomSize;
         //unitrooms is set in the generator --> onstart
         this.rooms = new ArrayList<>();
+        this.edgeManager = new EdgeManager(isten);
         initUnitRooms();
 
     }
Index: src/main/java/org/game/UI/Minimap.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package main.java.org.game.UI;\r\n\r\nimport main.java.org.game.Graphics.Image;\r\nimport main.java.org.game.Graphics.ImageUI;\r\nimport main.java.org.game.Graphics.Renderable;\r\nimport main.java.org.game.Isten;\r\nimport main.java.org.game.Map.*;\r\nimport main.java.org.game.updatable.Updatable;\r\nimport main.java.org.linalg.Vec2;\r\n\r\nimport java.awt.*;\r\nimport java.awt.image.*;\r\nimport java.lang.reflect.Array;\r\nimport java.util.ArrayList;\r\nimport java.util.Arrays;\r\nimport java.util.Random;\r\n\r\npublic class Minimap extends Updatable {\r\n\r\n    private int displayedScale;\r\n\r\n    private final int width;\r\n    private final int height;\r\n\r\n    private final int pixelsPerUnit;\r\n    private final int wallWidthInPixels;\r\n\r\n    private ImageUI displayedImage=null;\r\n    private BufferedImage displayedImageData;\r\n    private int[] rawData;\r\n\r\n    private final Object syncObject=new Object();\r\n    private boolean canRerender=true;\r\n\r\n    public Minimap(int displayedScale, int res, int pixelsPerUnit, int wallWidthInPixels)\r\n    {\r\n        this.displayedScale=displayedScale;\r\n\r\n        this.width=res;\r\n        this.height=res;\r\n        this.pixelsPerUnit=pixelsPerUnit;\r\n        this.wallWidthInPixels=wallWidthInPixels;\r\n\r\n        rawData=new int[4*res*res];\r\n        displayedImageData=new BufferedImage(this.width, this.height, BufferedImage.TYPE_INT_ARGB);\r\n    }\r\n\r\n    @Override\r\n    public void onStart(Isten isten) {\r\n        displayedImage=new ImageUI();\r\n        displayedImage.setPosition(new Vec2(20,20));\r\n        displayedImage.setScale(new Vec2(displayedScale,displayedScale));\r\n        displayedImage.setSortingLayer(-69420);\r\n        displayedImage.setAlignment(Renderable.RIGHT, Renderable.BOTTOM);\r\n        displayedImage.setOrigin(Renderable.RIGHT, Renderable.BOTTOM);\r\n        displayedImage.setImage(displayedImageData);\r\n\r\n        isten.getRenderer().addRenderable(displayedImage);\r\n    }\r\n\r\n    @Override\r\n    public void onUpdate(Isten isten, double deltaTime) {\r\n        synchronized (syncObject)\r\n        {\r\n            if(canRerender==true)\r\n            {\r\n                canRerender=false;\r\n                Thread thread = new Thread(()->{this.draw(isten);});\r\n                thread.start();\r\n            }\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void onDestroy() {\r\n\r\n    }\r\n\r\n    private void draw(Isten isten)\r\n    {\r\n        Arrays.fill(rawData,0);//reset the content of the image\r\n\r\n        final Vec2 playerPos=isten.getPlayer().getPlayerCollider().getPosition().clone();\r\n\r\n        final Vec2 lowerBound=Vec2.subtract(playerPos, new Vec2(width*0.5f/pixelsPerUnit, height*0.5f/pixelsPerUnit));\r\n        final Vec2 upperBound=Vec2.sum(playerPos, new Vec2(width*0.5f/pixelsPerUnit, height*0.5f/pixelsPerUnit));\r\n        final Vec2 covered=Vec2.subtract(upperBound,lowerBound);\r\n        final Vec2 onePerCovered=new Vec2(1/covered.x, 1/covered.y);\r\n\r\n        /*ArrayList<Room> rooms = isten.getMap().getRooms();\r\n        if(rooms==null)\r\n            rooms=new ArrayList<>();\r\n\r\n        for(int i=0;i<rooms.size();i++)\r\n        {\r\n            //draw unit rooms\r\n            ArrayList<UnitRoom> unitRooms=rooms.get(i).getUnitRooms();\r\n            for(int j=0;j<unitRooms.size();j++)\r\n            {\r\n                Vec2 startPos=unitRooms.get(j).getPosition().clone();\r\n                startPos.x-=0.5f+lowerBound.x;\r\n                startPos.y-=0.5f+lowerBound.y;\r\n\r\n                if(startPos.x+1<0||startPos.y+1<0||startPos.x>covered.x||startPos.y>covered.y)\r\n                    continue;\r\n\r\n                startPos.y=covered.y-startPos.y-1;\r\n\r\n                int drawX, drawY;\r\n                drawX=Math.round(width*startPos.x* onePerCovered.x);\r\n                drawY=Math.round(height* startPos.y* onePerCovered.y);\r\n\r\n                for(int k=drawY>-1?drawY:0;k<height&&k<drawY+pixelsPerUnit;k++)\r\n                {\r\n                    for(int l=drawX>-1?drawX:0;l<width&&l<drawX+pixelsPerUnit;l++)\r\n                    {\r\n                        int index=4*(width*k+l);\r\n                        rawData[index++]=0;\r\n                        rawData[index++]=0;\r\n                        rawData[index++]=0;\r\n                        rawData[index]=255;\r\n                    }\r\n                }\r\n            }\r\n        }*/\r\n\r\n        //edging intensifies (drawing edges)\r\n        ArrayList<EdgeBetweenRooms> edges =isten.getMap().getEdgeManager().getRoomEdges();\r\n        for(int i=0;i<edges.size();i++)\r\n        {\r\n            ArrayList<EdgePiece> edgePieces=edges.get(i).getWalls();\r\n\r\n            for(int j=0;j<edgePieces.size();j++)\r\n            {\r\n                Vec2 startPos=edgePieces.get(j).getCollider().getPosition().clone();\r\n                Vec2 scale=edgePieces.get(j).getCollider().getScale();\r\n                startPos.x-=0.5f*scale.x+lowerBound.x;\r\n                startPos.y-=0.5f*scale.y+lowerBound.y;\r\n\r\n                if(startPos.x+1<0||startPos.y+1<0||startPos.x>covered.x||startPos.y>covered.y)\r\n                    continue;\r\n\r\n                startPos.y=covered.y-startPos.y-scale.y;\r\n\r\n                int drawX, drawY;\r\n                drawX=Math.round(width*startPos.x* onePerCovered.x);\r\n                drawY=Math.round(height* startPos.y* onePerCovered.y)+1;\r\n\r\n                int drawEndX=Math.round(scale.x*pixelsPerUnit);\r\n                int drawEndY=Math.round(scale.y*pixelsPerUnit);\r\n\r\n                if(drawEndX>drawEndY)\r\n                {\r\n                    drawX--;\r\n                    drawEndX+=drawX+wallWidthInPixels/2;\r\n                    drawEndY=drawY+wallWidthInPixels;\r\n                }\r\n                else\r\n                {\r\n                    drawY--;\r\n                    drawEndY+=drawY;\r\n                    drawEndX=drawX+wallWidthInPixels;\r\n                }\r\n\r\n                if(drawX<0)\r\n                    drawX=0;\r\n                if(drawY<0)\r\n                    drawY=0;\r\n                if(drawEndX>width)\r\n                    drawEndX=width;\r\n                if(drawEndY>height)\r\n                    drawEndY=height;\r\n\r\n                int r=255, g=255,b=255;\r\n                if(edgePieces.get(j) instanceof Door)\r\n                {\r\n                    //r=255;\r\n                    g=205;\r\n                    b=0;\r\n                }\r\n\r\n                for(int k=drawY;k<drawEndY;k++)\r\n                {\r\n                    for(int l=drawX;l<drawEndX;l++)\r\n                    {\r\n                        int index=4*(width*k+l);\r\n                        rawData[index++]=r;\r\n                        rawData[index++]=g;\r\n                        rawData[index++]=b;\r\n                        rawData[index]=255;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        //draw the great edges\r\n        do{\r\n            float mapSizeX, mapSizeY;\r\n            mapSizeX=isten.getMap().getMapColumnSize();\r\n            mapSizeY=isten.getMap().getMapRowSize();\r\n\r\n            float wallWidth=0.1f;\r\n\r\n            try{\r\n                Vec2 temp=isten.getMap().getEdgeManager().getRoomEdges().get(0).getWalls().get(0).getCollider().getScale();\r\n                wallWidth=temp.x>temp.y?temp.y:temp.x;\r\n            }\r\n            catch (Exception ex){}\r\n\r\n            Vec2[] positions=new Vec2[]{\r\n                    new Vec2(-0.5f, 0.5f*mapSizeY-0.5f),\r\n                    new Vec2(0.5f*mapSizeX-0.5f, mapSizeY-0.5f),\r\n                    new Vec2(mapSizeX-0.5f, 0.5f*mapSizeY-0.5f),\r\n                    new Vec2(0.5f*mapSizeX-0.5f,-0.5f)\r\n            };\r\n            Vec2[] scales=new Vec2[]{\r\n                    new Vec2(wallWidth, mapSizeY),\r\n                    new Vec2(mapSizeX, wallWidth),\r\n                    new Vec2(wallWidth, mapSizeY),\r\n                    new Vec2(mapSizeX, wallWidth)\r\n            };\r\n\r\n            for(int j=0;j<4;j++)\r\n            {\r\n                Vec2 startPos=positions[j].clone();\r\n                Vec2 scale=scales[j];\r\n                startPos.x-=0.5f*scale.x+lowerBound.x;\r\n                startPos.y-=0.5f*scale.y+lowerBound.y;\r\n                startPos.y=covered.y-startPos.y-scale.y;\r\n\r\n                int drawX, drawY;\r\n                drawX=Math.round(width*startPos.x* onePerCovered.x);\r\n                drawY=Math.round(height* startPos.y* onePerCovered.y)+1;\r\n\r\n                int drawEndX=Math.round(scale.x*pixelsPerUnit);\r\n                int drawEndY=Math.round(scale.y*pixelsPerUnit);\r\n\r\n                if(drawEndX>drawEndY)\r\n                {\r\n                    drawX--;\r\n                    drawEndX+=drawX+wallWidthInPixels/2;\r\n                    drawEndY=drawY+wallWidthInPixels;\r\n                }\r\n                else\r\n                {\r\n                    drawY--;\r\n                    drawEndY+=drawY;\r\n                    drawEndX=drawX+wallWidthInPixels;\r\n                }\r\n\r\n                if(drawX<0)\r\n                    drawX=0;\r\n                if(drawY<0)\r\n                    drawY=0;\r\n                if(drawEndX>width)\r\n                    drawEndX=width;\r\n                if(drawEndY>height)\r\n                    drawEndY=height;\r\n\r\n                for(int k=drawY;k<drawEndY;k++)\r\n                {\r\n                    for(int l=drawX;l<drawEndX;l++)\r\n                    {\r\n                        int index=4*(width*k+l);\r\n                        rawData[index++]=255;\r\n                        rawData[index++]=255;\r\n                        rawData[index++]=255;\r\n                        rawData[index]=255;\r\n                    }\r\n                }\r\n            }\r\n        } while(69==420);\r\n\r\n        //draw player\r\n        do{\r\n            for(int i=height/2-wallWidthInPixels;i<height/2+wallWidthInPixels+1;i++)\r\n            {\r\n                for (int j=width/2-wallWidthInPixels;j<width/2+wallWidthInPixels+1;j++)\r\n                {\r\n                    int currentIndex=4*(i*width+j);\r\n                    rawData[currentIndex++]=0;\r\n                    rawData[currentIndex++]=0;\r\n                    rawData[currentIndex++]=255;\r\n                    rawData[currentIndex]=255;\r\n                }\r\n            }\r\n        }while(69==420);\r\n\r\n        //apply transparency mask\r\n        int currentIndex=3;//offset to alpha value\r\n        float outerRadius=(float)Math.sqrt((width*0.5f)*(height*0.5f));\r\n        float innerRadius=outerRadius*0.9f;\r\n        float onePerInterpolationDistance=1/(outerRadius-innerRadius);\r\n        for(int row=0;row<height;row++)\r\n        {\r\n            for(int col=0;col<width;col++, currentIndex+=4)\r\n            {\r\n                float length=(float)Math.sqrt(Math.pow(row-height*0.5f,2)+Math.pow(col-width*0.5f,2));\r\n\r\n                if(rawData[currentIndex]==0)\r\n                    rawData[currentIndex]=128;\r\n\r\n                if(length<innerRadius)\r\n                {\r\n                    continue;\r\n                }\r\n                if(length>outerRadius)\r\n                {\r\n                    rawData[currentIndex]=0;\r\n                    continue;\r\n                }\r\n\r\n                rawData[currentIndex]=(int)((rawData[currentIndex]/255.0f)*(255-255*(length-innerRadius)*onePerInterpolationDistance));\r\n            }\r\n        }\r\n\r\n        displayedImageData.getRaster().setPixels(0,0, this.width, this.height, rawData);\r\n\r\n        synchronized (syncObject)\r\n        {\r\n            canRerender=true;\r\n        }\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/game/UI/Minimap.java b/src/main/java/org/game/UI/Minimap.java
--- a/src/main/java/org/game/UI/Minimap.java	
+++ b/src/main/java/org/game/UI/Minimap.java	
@@ -125,6 +125,9 @@
         }*/
 
         //edging intensifies (drawing edges)
+
+        if(isten.getMap().getEdgeManager() != null) return;
+
         ArrayList<EdgeBetweenRooms> edges =isten.getMap().getEdgeManager().getRoomEdges();
         for(int i=0;i<edges.size();i++)
         {
Index: src/main/java/org/items/ChestManager.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package main.java.org.items;\r\n\r\nimport lombok.Getter;\r\nimport main.java.org.game.Isten;\r\nimport main.java.org.game.Map.Map;\r\nimport main.java.org.game.Map.UnitRoom;\r\nimport main.java.org.game.Map.Wall;\r\nimport main.java.org.game.physics.Collider;\r\nimport main.java.org.game.physics.ColliderGroup;\r\nimport main.java.org.game.updatable.Updatable;\r\nimport main.java.org.items.usable_items.*;\r\nimport main.java.org.linalg.Vec2;\r\nimport main.java.org.networking.Packet11ChestOpened;\r\n\r\nimport java.awt.event.KeyEvent;\r\nimport java.util.*;\r\n\r\nimport static java.lang.Math.sqrt;\r\n\r\n/**\r\n * This class generates chests around the map randomly.\r\n * Rules: There aren't any chests in front of doors.\r\n * Every chest is next to a wall and headed against the wall.\r\n */\r\npublic class ChestManager extends Updatable {\r\n    private Vector<Chest>chests=new Vector<>();\r\n    private  int chestCount;\r\n    private  Map map;\r\n    private Vector<UnitRoom> placeableUnitRooms = new Vector<>();//UnitRoom-ok, amelyikbe helyezhető láda (mivel ajtó mellé nem rakható láda)\r\n    private Vector<Boolean> isThereChest=new Vector<>();//igaz=van az azonos sorszámú unitroomban láda\r\n    /**\r\n     * @param n How many chests should be generated randomly across the map?\r\n     */\r\n    public ChestManager(int n){\r\n        chestCount=n;\r\n        map=null;\r\n    }\r\n    @Override\r\n    public void onStart(Isten isten) {\r\n\r\n    }\r\n\r\n    public void init(Isten isten) {\r\n        map=isten.getMap();\r\n        for (int i = 0; i < map.getUnitRooms().length; i++) {\r\n            for (int j = 0; j < map.getUnitRooms()[i].length; j++) {\r\n                UnitRoom unitRoomTmp=map.getUnitRooms()[i][j];\r\n                //megcsinaltam a unitroomot: van egy hasdoor valtozoja, es mindegyik uniroomrol le lehet kerdezni hogy melyik oldala fall\r\n                //fontos az ajtot is falnak veszi!!\r\n                //ezek a valtoztatasok a mapdrawing branchen elerhetoek(nem tudtam jol összrakni, nem vagyok jo git kezeko :) )\r\n                if(!unitRoomTmp.hasDoor()//ha egyik fal sem ajtó\r\n                        &&(unitRoomTmp.isTopWall()|| unitRoomTmp.isRightWall()|| unitRoomTmp.isBottomWall()|| unitRoomTmp.isLeftWall()))//ha egyik oldalán legalább fal van\r\n                {\r\n                    placeableUnitRooms.add(unitRoomTmp);\r\n                    isThereChest.add(false);\r\n                }\r\n            }\r\n        }\r\n        if(chestCount> placeableUnitRooms.size()) {\r\n            System.err.println(\"So many chests cant be generated!\");\r\n            chestCount=placeableUnitRooms.size();\r\n        }\r\n        Random rand=new Random();\r\n        int randomUnitRoom=rand.nextInt(placeableUnitRooms.size());\r\n        for (int h = 0; h < chestCount; h++) {\r\n            while(isThereChest.get(randomUnitRoom)){\r\n                randomUnitRoom=rand.nextInt(placeableUnitRooms.size());\r\n            }\r\n            WallLocation wall= wallInUnitRoomPicker(placeableUnitRooms.get(randomUnitRoom));\r\n            Vec2 chestPos=null;\r\n            switch (wall) {//0=left, 1=top, 2=right, 3=bottom\r\n                case LEFT: chestPos=new Vec2(placeableUnitRooms.get(randomUnitRoom).getPosition().x - 0.3f, placeableUnitRooms.get(randomUnitRoom).getPosition().y);break;\r\n                case TOP :chestPos=new Vec2(placeableUnitRooms.get(randomUnitRoom).getPosition().x, placeableUnitRooms.get(randomUnitRoom).getPosition().y + 0.3f);break;\r\n                case RIGHT: chestPos=new Vec2(placeableUnitRooms.get(randomUnitRoom).getPosition().x + 0.3f, placeableUnitRooms.get(randomUnitRoom).getPosition().y);break;\r\n                case BOTTOM: chestPos=new Vec2(placeableUnitRooms.get(randomUnitRoom).getPosition().x, placeableUnitRooms.get(randomUnitRoom).getPosition().y - 0.3f);break;\r\n            };\r\n            //CHEST TÍPUSOK, a networking miatt sokkal egyszerűbb így az itemeket átadni --> Chest.java/fillChest\r\n            chests.add(new Chest(chestPos,isten,wall.ordinal(),rand.nextInt(5)));\r\n            isThereChest.set(randomUnitRoom,true);\r\n        }\r\n        ColliderGroup chestColliders=new ColliderGroup();\r\n        for (int i = 0; i < chests.size(); i++) {\r\n            Collider c=new Collider(chests.get(i).getPosition(),new Vec2(0.15f,0.15f));\r\n            chestColliders.addCollider(c);\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void onUpdate(Isten isten, double deltaTime) {\r\n        if(isten.getInputHandler().isKeyDown(KeyEvent.VK_E)){\r\n            Vec2 playerPostion = isten.getPlayer().getPlayerCollider().getPosition();\r\n            int index = 0;\r\n            for(var chest : chests){\r\n                Vec2 playerChestVector = Vec2.subtract(playerPostion,chest.getPosition());\r\n                double playerChestDistance = sqrt(Vec2.dot(playerChestVector,playerChestVector));\r\n                if(playerChestDistance <= 0.5 && !chest.isOpened()){\r\n                    chest.open();\r\n                    isten.getSocketClient().sendData((\"11\"+index).getBytes());\r\n                    break;\r\n                }\r\n                index++;\r\n            }\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void onDestroy() {\r\n\r\n    }\r\n    private WallLocation wallInUnitRoomPicker(UnitRoom unitRoom ){\r\n\r\n        WallLocation wall;//0=left, 1=top, 2=right, 3=bottom\r\n        ArrayList<WallLocation> walls = new ArrayList<>();\r\n        if(unitRoom.isLeftWall())walls.add(WallLocation.LEFT);\r\n        if(unitRoom.isTopWall())walls.add(WallLocation.TOP);\r\n        if(unitRoom.isRightWall())walls.add(WallLocation.RIGHT);\r\n        if(unitRoom.isBottomWall()) walls.add(WallLocation.BOTTOM);\r\n\r\n        Random random = new Random();\r\n        return walls.get(random.nextInt(walls.size()));\r\n\r\n\r\n    }\r\n\r\n    public enum WallLocation {\r\n        LEFT,\r\n        TOP,\r\n        RIGHT,\r\n        BOTTOM\r\n    }\r\n\r\n    @Override\r\n    public Vector<Chest> getChests() { return chests; }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/items/ChestManager.java b/src/main/java/org/items/ChestManager.java
--- a/src/main/java/org/items/ChestManager.java	
+++ b/src/main/java/org/items/ChestManager.java	
@@ -74,7 +74,7 @@
                 case RIGHT: chestPos=new Vec2(placeableUnitRooms.get(randomUnitRoom).getPosition().x + 0.3f, placeableUnitRooms.get(randomUnitRoom).getPosition().y);break;
                 case BOTTOM: chestPos=new Vec2(placeableUnitRooms.get(randomUnitRoom).getPosition().x, placeableUnitRooms.get(randomUnitRoom).getPosition().y - 0.3f);break;
             };
-            //CHEST TÍPUSOK, a networking miatt sokkal egyszerűbb így az itemeket átadni --> Chest.java/fillChest
+            //CHEST TIPUSOK, a networking miatt sokkal egyszerubb így az itemeket atadni --> Chest.java/fillChest
             chests.add(new Chest(chestPos,isten,wall.ordinal(),rand.nextInt(5)));
             isThereChest.set(randomUnitRoom,true);
         }
Index: src/main/java/org/game/Isten.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package main.java.org.game;\r\n\r\nimport main.java.org.entities.villain.Villain;\r\nimport main.java.org.game.Camera.Camera;\r\nimport main.java.org.game.Graphics.*;\r\n\r\nimport main.java.org.entities.player.Player;\r\n\r\nimport main.java.org.game.Input.Input;\r\nimport main.java.org.game.Map.Map;\r\nimport main.java.org.game.PlayerPrefs.PlayerPrefs;\r\nimport main.java.org.game.UI.*;\r\nimport main.java.org.game.physics.PhysicsEngine;\r\nimport main.java.org.game.updatable.Updatable;\r\nimport main.java.org.linalg.Vec2;\r\n\r\nimport main.java.org.items.ChestManager;\r\nimport main.java.org.items.ItemManager;\r\n\r\nimport main.java.org.networking.*;\r\n\r\nimport javax.swing.*;\r\n\r\nimport java.util.ArrayList;\r\n\r\n/**\r\n * The main class representing the game part of the program.\r\n */\r\npublic class Isten {\r\n    private HandlerManager handlerManager;\r\n    private final PhysicsEngine physicsEngine;\r\n    protected final GameRenderer renderer;\r\n    protected final ArrayList<Updatable> updatables;\r\n    private final ArrayList<Updatable> pendingAddedUpdatables;\r\n    private final ArrayList<Updatable> pendingRemovedUpdatables;\r\n\r\n    private Map map;\r\n    private Inventory inventory;\r\n    private final Input inputHandler;\r\n    private final ItemManager itemManager;\r\n\r\n    private final Camera camera;\r\n\r\n    private GameClient socketClient;\r\n    private GameServer socketServer;\r\n\r\n    private PlayerMP player;\r\n    private ChestManager chestManager;\r\n    /**\r\n     * Constructor for Isten.\r\n     * Initializes the physics engine, game renderer, and list of updatables.\r\n     */\r\n    public Isten() {\r\n        inventory=new Inventory(5);\r\n        map=new Map(20, 20, 10);\r\n        chestManager = new ChestManager(75);\r\n        itemManager=new ItemManager();\r\n        inputHandler = new Input();\r\n        camera = new Camera();\r\n        physicsEngine = new PhysicsEngine();\r\n        renderer = new GameRenderer(camera, inputHandler);\r\n        updatables = new ArrayList<>();\r\n        pendingAddedUpdatables = new ArrayList<>();\r\n        pendingRemovedUpdatables = new ArrayList<>();\r\n\r\n\r\n        handlerManager = new HandlerManager(this);\r\n    }\r\n\r\n    /**\r\n     * Method to update the game state.\r\n     *\r\n     * @param deltaTime The time elapsed since the last update\r\n     */\r\n    public void update(double deltaTime) {\r\n\r\n\r\n        inputHandler.update();\r\n\r\n        if(socketServer == null || socketServer.isInitialized()) physicsEngine.step(deltaTime);\r\n\r\n\r\n        //remove pending updatables from updatables\r\n        for (Updatable u : pendingRemovedUpdatables)\r\n            if (!u.isDestroyed()) {\r\n                u.setDestroyedTrue();\r\n                u.onDestroy();\r\n            }\r\n        updatables.removeAll(pendingRemovedUpdatables);\r\n        pendingRemovedUpdatables.clear();\r\n\r\n        //add pending updatables to updatables\r\n        updatables.addAll(pendingAddedUpdatables);\r\n        pendingAddedUpdatables.clear();\r\n\r\n        //check if updatable has been initialized\r\n        for (Updatable u : updatables)\r\n            if (!u.isInitialized()) {\r\n                u.setInitializedTrue();\r\n                u.onStart(this);\r\n            }\r\n\r\n\r\n        //call onUpdates\r\n        for (Updatable u : updatables)\r\n            u.onUpdate(this, deltaTime);\r\n\r\n\r\n        //ServerUpdate\r\n        if(socketServer != null) {\r\n            socketServer.updateServer(this, deltaTime);\r\n        }\r\n\r\n\r\n\r\n        //Manage handlers of client\r\n        handlerManager.executeTasks();\r\n\r\n\r\n        //calculate render positions, check for UI inputs and then render\r\n        renderer.calculateRenderedPositions();\r\n        renderer.processUIInputs(inputHandler);\r\n        renderer.repaint();\r\n    }\r\n\r\n    /**\r\n     * Method to initialize the game.\r\n     */\r\n\r\n    public void initMP() {\r\n        //Set localPlayer to true, so that only this player can be moved and followed by the camera on this client\r\n        player = new PlayerMP(JOptionPane.showInputDialog(this.getRenderer(),\"Username\"),null,-1);\r\n\r\n\r\n        player.localPlayer = true;\r\n\r\n        addUpdatables();\r\n        addRenderables();\r\n\r\n        int skinID = PlayerPrefs.getInt(\"skin\");\r\n        player.setSkinID(skinID);\r\n        Packet00Login loginPacket = new Packet00Login(player.getUsername(), 0, 0, skinID);\r\n\r\n        if(socketServer != null) {\r\n            socketServer.addConnection(player,loginPacket);\r\n        }\r\n\r\n        if(JOptionPane.showConfirmDialog(this.getRenderer(), \"Server?\") == 0) {\r\n            socketServer = new GameServer(this);\r\n            socketServer.start();\r\n\r\n        }\r\n        socketClient = new GameClient(this, \"localhost\");\r\n        socketClient.start();\r\n\r\n        loginPacket.writeData(socketClient);\r\n\r\n        update(0);\r\n    }\r\n    public void init() {\r\n        //Create own player\r\n        player = new PlayerMP(JOptionPane.showInputDialog(this.getRenderer(),\"Username\"),null,-1);\r\n\r\n        player.localPlayer = true;\r\n\r\n        addUpdatables();\r\n        addRenderables();\r\n\r\n        int skinID = PlayerPrefs.getInt(\"skin\");\r\n        player.setSkinID(skinID);\r\n        Packet00Login loginPacket = new Packet00Login(player.getUsername(), 0, 0, skinID);\r\n\r\n        if(socketServer != null) {\r\n            socketServer.addConnection(player,loginPacket);\r\n        }\r\n\r\n        socketServer = new GameServer(this);\r\n        socketServer.start();\r\n\r\n        socketClient = new GameClient(this, \"localhost\");\r\n        socketClient.start();\r\n\r\n        loginPacket.writeData(socketClient);\r\n    }\r\n\r\n    /**\r\n     * Method to add renderable objects to the game renderer.\r\n     */\r\n    protected void addRenderables() {\r\n    }\r\n\r\n    /**\r\n     * Method to add updatable objects to the game.\r\n     */\r\n    protected void addUpdatables() {\r\n\r\n        updatables.add(player);\r\n        updatables.add(itemManager);\r\n        updatables.add(inventory);\r\n        updatables.add(map);\r\n\r\n        updatables.add(chestManager);//majd a játékba nem kell 500 láda, csak szemléltetésképp kell ilyen sok\r\n\r\n\r\n        updatables.add(new TimeCounter());\r\n        updatables.add(new Help());\r\n        updatables.add(new GameMenu());\r\n\r\n        updatables.add(new Minimap(200,200,20,2));\r\n    }\r\n\r\n    /**\r\n     * Method to get the game renderer.\r\n     *\r\n     * @return The game renderer\r\n     */\r\n    public GameRenderer getRenderer() {\r\n        return renderer;\r\n    }\r\n\r\n    /**\r\n     * returns the physics engine of the isten\r\n     */\r\n    public PhysicsEngine getPhysicsEngine() {\r\n        return physicsEngine;\r\n    }\r\n\r\n    /**\r\n     * returns the inputhandler of the isten\r\n     */\r\n    public Input getInputHandler() {\r\n        return inputHandler;\r\n    }\r\n\r\n    /**\r\n     * returns the camera of the isten\r\n     */\r\n    public Camera getCamera() {\r\n        return this.camera;\r\n    }\r\n\r\n    public Player getPlayer(){return player;}\r\n    public Inventory getInventory(){return inventory;}\r\n    public ItemManager getItemManager(){return itemManager;}\r\n    public Map getMap(){return map;}\r\n\r\n    public void addUpdatable(Updatable u) {\r\n        pendingAddedUpdatables.add(u);\r\n    }\r\n\r\n    public void removeUpdatable(Updatable u) {\r\n        pendingRemovedUpdatables.add(u);\r\n    }\r\n\r\n    public int getPlayerMPIndex(String username) {\r\n        int index = 0;\r\n        for(int i = 0; i < updatables.size(); i++) {\r\n            Updatable u = updatables.get(i);\r\n            if(u instanceof PlayerMP) {\r\n                if(((PlayerMP)u).getUsername().equalsIgnoreCase(username)) {\r\n                    break;\r\n                }\r\n\r\n            }\r\n            index++;\r\n        }\r\n        return index;\r\n    }\r\n\r\n    public int getVillainIndex(String villainName) {\r\n        int index = 0;\r\n        for(int i = 0; i < updatables.size(); i++) {\r\n            Updatable u = updatables.get(i);\r\n            if(u instanceof Villain) {\r\n                if(((Villain)u).getVillainName().equalsIgnoreCase(villainName)) {\r\n                    break;\r\n                }\r\n\r\n            }\r\n            index++;\r\n        }\r\n        return index;\r\n    }\r\n    public Updatable getUpdatable(int index) {\r\n        if(index >= updatables.size()) return null;\r\n        return updatables.get(index);\r\n    }\r\n\r\n    /**\r\n     * returns an ArrayList of updatables of the given type <br>\r\n     * <br>\r\n     * how to use it:\r\n     * ArrayList< Player> alma=new ArrayList<>();\r\n     * alma = isten.getUpdatablesByType(Player.class);\r\n     * @param type the Class of the elements\r\n     * @return an array list of elements\r\n     * @param <E> the type of the queried elements\r\n     */\r\n    public final <E extends Updatable> ArrayList<E> getUpdatablesByType(Class<E> type)\r\n    {\r\n        ArrayList<E> tempList=new ArrayList<>();\r\n        for(int i=0;i<updatables.size();i++)\r\n        {\r\n            if(type.isInstance(updatables.get(i)))\r\n                tempList.add((E)updatables.get(i));\r\n        }\r\n\r\n        return tempList;\r\n    }\r\n\r\n    public GameClient getSocketClient() {\r\n        return socketClient;\r\n    }\r\n\r\n    public ArrayList<Updatable> getUpdatables() {\r\n        return updatables;\r\n    }\r\n\r\n    public GameServer getSocketServer() {\r\n        return socketServer;\r\n    }\r\n\r\n    public HandlerManager getHandlerManager() {\r\n        return handlerManager;\r\n    }\r\n\r\n    public ChestManager getChestManager() { return chestManager; }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/game/Isten.java b/src/main/java/org/game/Isten.java
--- a/src/main/java/org/game/Isten.java	
+++ b/src/main/java/org/game/Isten.java	
@@ -1,4 +1,4 @@
-package main.java.org.game;
+    package main.java.org.game;
 
 import main.java.org.entities.villain.Villain;
 import main.java.org.game.Camera.Camera;
@@ -52,7 +52,7 @@
      */
     public Isten() {
         inventory=new Inventory(5);
-        map=new Map(20, 20, 10);
+        map=new Map(this, 20, 20, 10);
         chestManager = new ChestManager(75);
         itemManager=new ItemManager();
         inputHandler = new Input();
