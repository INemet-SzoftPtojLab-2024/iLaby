Index: .idea/shelf/Uncommitted_changes_before_Update_at_01_05_2024_13_38__Changes_1.xml
===================================================================
diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_01_05_2024_13_38__Changes_1.xml b/.idea/shelf/Uncommitted_changes_before_Update_at_01_05_2024_13_38__Changes_1.xml
deleted file mode 100644
--- a/.idea/shelf/Uncommitted_changes_before_Update_at_01_05_2024_13_38__Changes_1.xml	(revision 072d073c088012b37a1d4a123bd6255c2258b9ce)
+++ /dev/null	(revision 072d073c088012b37a1d4a123bd6255c2258b9ce)
@@ -1,9 +0,0 @@
-<changelist name="Uncommitted_changes_before_Update_at_01_05_2024_13_38_[Changes]1" date="1714563621747" recycled="true" deleted="true">
-  <option name="PATH" value="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_01_05_2024_13_38_[Changes]1/shelved.patch" />
-  <option name="DESCRIPTION" value="Uncommitted changes before Update at 01/05/2024 13:38 [Changes]" />
-  <binary>
-    <option name="BEFORE_PATH" value="data/sus.amogus" />
-    <option name="AFTER_PATH" value="data/sus.amogus" />
-    <option name="SHELVED_PATH" value="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_01_05_2024_13_38_[Changes]1/sus.amogus" />
-  </binary>
-</changelist>
\ No newline at end of file
Index: .idea/shelf/Uncommitted_changes_before_Checkout_at_2024__05__02__15_12_[Changes]1/shelved.patch
===================================================================
diff --git a/.idea/shelf/Uncommitted_changes_before_Checkout_at_2024__05__02__15_12_[Changes]1/shelved.patch b/.idea/shelf/Uncommitted_changes_before_Checkout_at_2024__05__02__15_12_[Changes]1/shelved.patch
deleted file mode 100644
--- a/.idea/shelf/Uncommitted_changes_before_Checkout_at_2024__05__02__15_12_[Changes]1/shelved.patch	(revision 072d073c088012b37a1d4a123bd6255c2258b9ce)
+++ /dev/null	(revision 072d073c088012b37a1d4a123bd6255c2258b9ce)
@@ -1,33 +0,0 @@
-Index: src/main/java/org/game/Map/Map.java
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
-<+>package main.java.org.game.Map;\r\n\r\nimport main.java.org.game.Graphics.Image;\r\nimport main.java.org.game.Isten;\r\nimport main.java.org.game.physics.Collider;\r\nimport main.java.org.game.updatable.Updatable;\r\nimport main.java.org.linalg.Vec2;\r\n\r\nimport java.util.*;\r\n\r\n\r\npublic class Map extends Updatable {\r\n    private Mapgenerator mapgenerator;\r\n    ArrayList<Room> rooms;\r\n    private UnitRoom[][] unitRooms;\r\n    private final int mapRowSize;\r\n    private final int mapColumnSize;\r\n    private EdgeManager edgeManager;\r\n    private final int minRoomSize;\r\n    private boolean isGenerated = false;\r\n    //private boolean\r\n    @Override\r\n    public void onStart(Isten isten) {\r\n\r\n        Mapgenerator mapgenerator = new Mapgenerator(this, isten);\r\n        mapgenerator.generateSideWalls();\r\n        //printMap();\r\n    }\r\n\r\n    public void init(Isten isten) {\r\n        this.mapgenerator = new Mapgenerator(this, isten);\r\n        mapgenerator.generate(minRoomSize);\r\n        isGenerated = true;\r\n    }\r\n\r\n    public Map(Isten isten, int rowNumber, int columnNumber, int minRoomSize){\r\n        this.mapRowSize = rowNumber;\r\n        this.mapColumnSize = columnNumber;\r\n        this.minRoomSize = minRoomSize;\r\n        //unitrooms is set in the generator --> onstart\r\n        this.rooms = new ArrayList<>();\r\n        this.edgeManager = new EdgeManager(isten);\r\n        initUnitRooms();\r\n\r\n    }\r\n\r\n    //for testing\r\n    boolean merged = false;\r\n    double delta = 0;\r\n    int cnt = 0;\r\n    int r = 0;\r\n    @Override\r\n    public void onUpdate(Isten isten, double deltaTime) {\r\n        //for testing\r\n        delta += deltaTime;\r\n        if (delta > 3 && cnt < 4 && !merged) {\r\n            //mergeRooms(rooms.get(0), rooms.get(0).getAdjacentRooms().get(0), isten);\r\n            /*if (!splitRooms(rooms.get(r), isten)) r++;\r\n            else {\r\n                r = 0;\r\n            }\r\n\r\n             */\r\n            System.out.println();\r\n            System.out.println();\r\n            //printMap();\r\n            cnt++;\r\n            delta = 0;\r\n            merged = true;\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void onDestroy() {\r\n\r\n    }\r\n    public void initUnitRooms(){\r\n        unitRooms = new UnitRoom[mapRowSize][mapColumnSize];\r\n        for(int i = 0; i<mapRowSize;i++)\r\n        {\r\n            for(int j = 0;j<mapColumnSize;j++)\r\n            {\r\n                unitRooms[i][j] = new UnitRoom(new Vec2(j,i));\r\n            }\r\n        }\r\n    }\r\n\r\n    //csak akkor ha minden ajto nyitva van!!\r\n    //a slitelesnel csak a minroomsize fele engedelyezett\r\n    private boolean splitRooms(Room r1, Isten isten)\r\n    {\r\n        if(r1.getUnitRooms().size() < minRoomSize) return false;\r\n        //egyenlőre minden szoba ami splittel lesz createlve ilyen type-val rendelkezik\r\n        int newID = generateNewRoomID(); //már kész van, teszt miatt nincs hasznalva\r\n        //int newId = 999;\r\n        Room newRoom = new Room(newID);\r\n        int lowestRowIdx = getRoomWithLowestRowIdx(r1);\r\n        ArrayList<UnitRoom> addableUnitRooms = new ArrayList<>();\r\n        int distance = 0;\r\n        ArrayList<UnitRoom> UnitRoomsWithDistanceXFromLowestRow;\r\n        //addig, amíg az új szoba a méret fele nem lesz\r\n        while(addableUnitRooms.size()<r1.getUnitRooms().size()/2){\r\n            UnitRoomsWithDistanceXFromLowestRow=getUnitRoomsWithXDistanceFromLowestRowIdxInOrderByColumn(r1,lowestRowIdx,distance++); //tavolsag novelese, es igy soronkent egyesevel balrol jobbra az osszes unitroom hozzaadasa, amig kell\r\n            for(UnitRoom addableUnitRoom:UnitRoomsWithDistanceXFromLowestRow){\r\n                if(addableUnitRooms.size()<r1.getUnitRooms().size()/2 )\r\n                {\r\n                    addableUnitRooms.add(addableUnitRoom);\r\n                }\r\n\r\n            }\r\n        }\r\n        ArrayList<UnitRoom> oldRoomWithoutNewRoom = getDifference(r1.getUnitRooms(),addableUnitRooms);\r\n        //ellenorzom, hogy osszefuggoek lennének-e: ha igen:\r\n        if( kruskalAlgoImplementation(oldRoomWithoutNewRoom) && kruskalAlgoImplementation(addableUnitRooms)) {\r\n            // removeoljuk a szomszedos roomok szomszedossagi listaibol a szobat, es a func vegen hozzaadjuk a ket szetvalasztott szoba egyiket/mindekettot\r\n            for(Room neighbourRoom : r1.getAdjacentRooms()){\r\n                neighbourRoom.getAdjacentRooms().remove(r1);\r\n            }\r\n            for (UnitRoom addUnitRoomToNewRoom : addableUnitRooms) {\r\n                //kivesszük az előző szobából a  aunitroomot\r\n                addUnitRoomToNewRoom.getOwnerRoom().getUnitRooms().remove(addUnitRoomToNewRoom);\r\n                addUnitRoomToNewRoom.setOwnerRoom(newRoom);\r\n                //hozzáadjuk az új szobához a unitroomot\r\n                newRoom.getUnitRooms().add(addUnitRoomToNewRoom);\r\n            }\r\n            rooms.add(newRoom);\r\n            newRoom.setAdjacentRooms();\r\n            r1.setAdjacentRooms();\r\n\r\n            //set the images\r\n            for(UnitRoom unitRoom : newRoom.getUnitRooms()) {\r\n                unitRoom.addRightImage(isten);\r\n            }\r\n            //update nodeRooms and generate the new ones\r\n            //also updates the images and colliders\r\n            edgeManager.updateEdgesAfterSplit(r1, newRoom);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n\r\n    public static ArrayList<UnitRoom> getDifference(ArrayList<UnitRoom> u1, ArrayList<UnitRoom> u2)\r\n    {\r\n        ArrayList<UnitRoom> difference = new ArrayList<>();\r\n        for (UnitRoom element : u1) {\r\n            if (!u2.contains(element)) {\r\n                difference.add(element);\r\n            }\r\n        }\r\n        return difference;\r\n    }\r\n    //nem biztos hogy így a legjobb\r\n    private boolean wouldRoomBeCoherent(ArrayList<UnitRoom> newRoomUnits)\r\n    {\r\n        UnitRoom starterRoom = newRoomUnits.get(0);\r\n        ArrayList<UnitRoom> coherentGraph = new ArrayList<>();\r\n        coherentGraph.add(starterRoom);\r\n        for(int i = 0;i<newRoomUnits.size();i++){\r\n            for(UnitRoom unitRoomToBeAddedToGraph : newRoomUnits){\r\n                 /*ha a size i-vel egyenlő, vagy kisebb nála, akkor tudjuk, hogy nem alkotnak összefüggő gráfot a UnitRoomok a Roomban,\r\n                    mert különben az előző körhöz képest legalább 1-et fel kellett volna tuidjak venni, vagy pedig már előtte többet kellett volna tudjak felvenni,\r\n                    rekurzív gondolat, mukodik (remelem)*/\r\n                if(coherentGraph.size()> i)\r\n                {\r\n                    if (!unitRoomToBeAddedToGraph.equals(coherentGraph.get(i))\r\n                            && !coherentGraph.contains(unitRoomToBeAddedToGraph)\r\n                            && unitRoomToBeAddedToGraph.isAdjacent(coherentGraph.get(i)))\r\n                    {\r\n                        coherentGraph.add(unitRoomToBeAddedToGraph);\r\n                        //break; ezzel valszeg effektivebb\r\n                    }\r\n                }\r\n                else{\r\n                    System.out.println(\"Nem lennenek koherensek a szobak\");\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        //mivel minden indexen vegig tudtunk menni ezert tudunk truet returnolni, azert biztonsag kedveert meg egy kontrollt bennhagyok\r\n        if(coherentGraph.size() == newRoomUnits.size()) return true;\r\n            //hogyha nem egyenlok akkor false menjen ki, bar egyenloknek kene lenniuk\r\n        else return false;\r\n    }\r\n    //elozo fv, vagyis wouldRoomBeCoherent atirasa generikusra, es akkor egy wouldMapBeCoherent fv-t is helyettesit.\r\n    private<T extends Graph> boolean kruskalAlgoImplementation(ArrayList<T> newCoherentElements)\r\n    {\r\n        T starterRoom = newCoherentElements.get(0);\r\n        ArrayList<T> coherentGraph = new ArrayList<>();\r\n        coherentGraph.add(starterRoom);\r\n        for(int i = 0;i<newCoherentElements.size();i++){\r\n            for(T ElementToBeAddedToGraph : newCoherentElements){\r\n                 /*ha a size i-vel egyenlő, vagy kisebb nála, akkor tudjuk, hogy nem alkotnak összefüggő gráfot a UnitRoomok a Roomban,\r\n                    mert különben az előző körhöz képest legalább 1-et fel kellett volna tuidjak venni, vagy pedig már előtte többet kellett volna tudjak felvenni,\r\n                    rekurzív gondolat, mukodik (remelem)*/\r\n                if(coherentGraph.size()> i)\r\n                {\r\n                    if (!ElementToBeAddedToGraph.equals(coherentGraph.get(i))\r\n                            && !coherentGraph.contains(ElementToBeAddedToGraph)\r\n                            && ElementToBeAddedToGraph.isAdjacent(coherentGraph.get(i)))\r\n                    {\r\n                        coherentGraph.add(ElementToBeAddedToGraph);\r\n                        //break; ezzel valszeg effektivebb\r\n                    }\r\n                }\r\n                else{\r\n                    System.out.println(\"Nem lennenek koherensek a szobak\");\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        //mivel minden indexen vegig tudtunk menni ezert tudunk truet returnolni, azert biztonsag kedveert meg egy kontrollt bennhagyok\r\n        if(coherentGraph.size() == newCoherentElements.size()) return true;\r\n            //hogyha nem egyenlok akkor false menjen ki, bar egyenloknek kene lenniuk\r\n        else return false;\r\n    }\r\n\r\n    //function hogy megtalaljam a legkisebb sorindexet a tombben, viszonyitasi parameter lesz.\r\n    // splitRooms func-on belül használva\r\n    private int getRoomWithLowestRowIdx(Room r1) {\r\n        UnitRoom min = unitRooms[mapRowSize-1][mapColumnSize-1];\r\n        for(UnitRoom unitRoom : r1.getUnitRooms())\r\n        {\r\n            if(unitRoom.getRowNum()<min.getRowNum())\r\n            {\r\n                min = unitRoom;\r\n            }\r\n        }\r\n        return min.getRowNum();\r\n    }\r\n    //function hogy megtalaljam azon UnitRoomokat, amik egy adott szamu soraban vannak a szobanaka alulrol nezve, amit a distance hataroz meg\r\n    // splitRooms func-on belül használva\r\n    private ArrayList<UnitRoom> getUnitRoomsWithXDistanceFromLowestRowIdxInOrderByColumn(Room r1, int lowestRowIdx, int distance) {\r\n        ArrayList<UnitRoom> ret = new ArrayList<>();\r\n        for(UnitRoom unitRoom: r1.getUnitRooms()){\r\n            if(unitRoom.getRowNum()==lowestRowIdx+distance){\r\n                ret.add(unitRoom);\r\n            }\r\n        }\r\n        ret.sort(Comparator.comparing(UnitRoom::getColNum));\r\n        return ret;\r\n    }\r\n\r\n    //ez a fv a mapgenerátorban is hasonlóan szerepel (colliderek és imagek nélkül)\r\n    private void mergeRooms(Room r1, Room r2, Isten isten) {\r\n        if(!r1.isAdjacent(r2) || r1.getID() == r2.getID()){\r\n            System.err.println(\"cant be merged\");\r\n            return;\r\n        }\r\n        System.out.println(r2.getID() + \"(r2) is merged to (r1)\" + r1.getID());\r\n        //remove r2 and keep r1;\r\n\r\n        //set colliders\r\n\r\n        edgeManager.deleteEdge(r1,r2);\r\n        edgeManager.updateEdgesAfterMerge(r1,r2);\r\n\r\n        for(UnitRoom unitRoom : r2.getUnitRooms()){\r\n            //r1.getUnitRooms().add(unitroom);\r\n            unitRoom.setOwnerRoom(r1);\r\n\r\n            //setting the new images of the deleted room\r\n            //this method cares about the renderable items too\r\n            unitRoom.addRightImage(isten);\r\n        }\r\n\r\n        r1.getUnitRooms().addAll(r2.getUnitRooms()); //insted of this: r1.getUnitRooms().add(unitroom);\r\n\r\n        r1.getAdjacentRooms().remove(r2);\r\n        r2.getAdjacentRooms().remove(r1);\r\n        for(Room adj : r2.getAdjacentRooms()){\r\n            if(!r1.getAdjacentRooms().contains(adj) && !adj.equals(r1)){\r\n                //System.out.println(\"adjroom added in r1: \" + adj.getID());\r\n                r1.getAdjacentRooms().add(adj);\r\n            }\r\n            adj.getAdjacentRooms().remove(r2);\r\n            if(!adj.getAdjacentRooms().contains(r1)) {\r\n                adj.getAdjacentRooms().add(r1);\r\n            }\r\n        }\r\n\r\n        r2.getAdjacentRooms().clear();\r\n        r2.getUnitRooms().clear();\r\n\r\n        //r1.setDiscovered(r2.isDiscovered());\r\n        //r1.setPlayerCount(r1.getPlayerCount() + r2.getPlayerCount());\r\n        //r1.setRoomType(r2.getRoomType());\r\n        r1.setMaxPlayerCount(r1.getMaxPlayerCount() + r2.getMaxPlayerCount());\r\n        rooms.remove(r2);\r\n\r\n\r\n    }\r\n\r\n    //merge the rooms until every room has minimumm size of the given number\r\n    private void printMap(){\r\n        for(int i = 0;i < mapRowSize;i++){ //test\r\n            for(int j = 0; j< mapColumnSize;j++){\r\n                if(unitRooms[i][j].getOwnerRoom().getID() < 10) {\r\n                    System.out.print(unitRooms[i][j].getOwnerRoom().getID() + \"     \");\r\n                }\r\n                else if(unitRooms[i][j].getOwnerRoom().getID() >= 10 && unitRooms[i][j].getOwnerRoom().getID() < 100) {\r\n                    System.out.print(unitRooms[i][j].getOwnerRoom().getID() + \"    \");\r\n                }\r\n                else if(unitRooms[i][j].getOwnerRoom().getID() >= 100) {\r\n                    System.out.print(unitRooms[i][j].getOwnerRoom().getID() + \"   \");\r\n                }\r\n            }\r\n            System.out.println();\r\n            System.out.println();\r\n        }\r\n    }\r\n    private int generateNewRoomID(){\r\n        int newID = 0;\r\n        while(true){\r\n            int roomCnt = 0;\r\n            for(Room room : rooms){\r\n                if(room.getID() == newID){\r\n                    newID++;\r\n                    break; //not found, try the next ID\r\n                }\r\n                roomCnt++;\r\n            }\r\n            if(roomCnt == rooms.size()){\r\n                return newID;\r\n            }\r\n\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n    public void setRooms(ArrayList<Room> rooms) {this.rooms = rooms;}\r\n\r\n    public void setUnitRooms(UnitRoom[][] unitRooms) {\r\n        this.unitRooms = unitRooms;\r\n    }\r\n\r\n    public ArrayList<Room> getRooms() {\r\n        return rooms;\r\n    }\r\n\r\n    public UnitRoom[][] getUnitRooms() {\r\n        return unitRooms;\r\n    }\r\n\r\n    public int getMapRowSize() {\r\n        return mapRowSize;\r\n    }\r\n\r\n    public int getMapColumnSize() {\r\n        return mapColumnSize;\r\n    }\r\n    public EdgeManager getEdgeManager(){ return edgeManager;}\r\n    public boolean isGenerated() {\r\n        return isGenerated;\r\n    }\r\n}\r\n
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
-diff --git a/src/main/java/org/game/Map/Map.java b/src/main/java/org/game/Map/Map.java
---- a/src/main/java/org/game/Map/Map.java	
-+++ b/src/main/java/org/game/Map/Map.java	
-@@ -200,7 +200,6 @@
-                             && ElementToBeAddedToGraph.isAdjacent(coherentGraph.get(i)))
-                     {
-                         coherentGraph.add(ElementToBeAddedToGraph);
--                        //break; ezzel valszeg effektivebb
-                     }
-                 }
-                 else{
-Index: .idea/misc.xml
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
-<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"ExternalStorageConfigurationManager\" enabled=\"true\" />\r\n  <component name=\"FrameworkDetectionExcludesConfiguration\">\r\n    <file type=\"web\" url=\"file://$PROJECT_DIR$\" />\r\n  </component>\r\n  <component name=\"ProjectRootManager\" version=\"2\" languageLevel=\"JDK_20\" project-jdk-name=\"21\" project-jdk-type=\"JavaSDK\">\r\n    <output url=\"file://$PROJECT_DIR$/out\" />\r\n  </component>\r\n</project>
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
-diff --git a/.idea/misc.xml b/.idea/misc.xml
---- a/.idea/misc.xml	
-+++ b/.idea/misc.xml	
-@@ -1,4 +1,3 @@
--<?xml version="1.0" encoding="UTF-8"?>
- <project version="4">
-   <component name="ExternalStorageConfigurationManager" enabled="true" />
-   <component name="FrameworkDetectionExcludesConfiguration">
Index: .idea/shelf/Uncommitted_changes_before_Update_at_02_05_2024_16_14__Changes_.xml
===================================================================
diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_02_05_2024_16_14__Changes_.xml b/.idea/shelf/Uncommitted_changes_before_Update_at_02_05_2024_16_14__Changes_.xml
deleted file mode 100644
--- a/.idea/shelf/Uncommitted_changes_before_Update_at_02_05_2024_16_14__Changes_.xml	(revision 072d073c088012b37a1d4a123bd6255c2258b9ce)
+++ /dev/null	(revision 072d073c088012b37a1d4a123bd6255c2258b9ce)
@@ -1,4 +0,0 @@
-<changelist name="Uncommitted_changes_before_Update_at_02_05_2024_16_14_[Changes]" date="1714659343023" recycled="true" deleted="true">
-  <option name="PATH" value="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_02_05_2024_16_14_[Changes]/shelved.patch" />
-  <option name="DESCRIPTION" value="Uncommitted changes before Update at 02/05/2024 16:14 [Changes]" />
-</changelist>
\ No newline at end of file
Index: .idea/shelf/Uncommitted_changes_before_Update_at_02_05_2024_16_14_[Changes]/shelved.patch
===================================================================
diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_02_05_2024_16_14_[Changes]/shelved.patch b/.idea/shelf/Uncommitted_changes_before_Update_at_02_05_2024_16_14_[Changes]/shelved.patch
deleted file mode 100644
--- a/.idea/shelf/Uncommitted_changes_before_Update_at_02_05_2024_16_14_[Changes]/shelved.patch	(revision 072d073c088012b37a1d4a123bd6255c2258b9ce)
+++ /dev/null	(revision 072d073c088012b37a1d4a123bd6255c2258b9ce)
@@ -1,374 +0,0 @@
-Index: src/main/java/org/networking/GameClient.java
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
-<+>package main.java.org.networking;\r\n\r\nimport main.java.org.game.Isten;\r\nimport main.java.org.game.Map.Map;\r\nimport main.java.org.game.UI.TimeCounter;\r\nimport main.java.org.game.physics.Collider;\r\nimport main.java.org.game.physics.ColliderGroup;\r\nimport main.java.org.items.Chest;\r\nimport main.java.org.items.ChestManager;\r\nimport main.java.org.items.Item;\r\nimport main.java.org.items.ItemManager;\r\nimport main.java.org.linalg.Vec2;\r\n\r\nimport java.io.IOException;\r\nimport java.net.*;\r\n\r\npublic class GameClient extends Thread {\r\n    private InetAddress ipAddress;\r\n    private DatagramSocket socket;\r\n    Isten isten;\r\n\r\n    public GameClient(Isten isten, String ipAddress) {\r\n        this.isten = isten;\r\n        try {\r\n            this.socket = new DatagramSocket();\r\n            this.ipAddress = InetAddress.getByName(ipAddress);\r\n        }\r\n        catch(SocketException e) {\r\n            e.printStackTrace();\r\n        }\r\n        catch(UnknownHostException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n    public void run() {\r\n        while(true) {\r\n            byte[] data = new byte[1024];\r\n            DatagramPacket packet = new DatagramPacket(data, data.length);\r\n            try {\r\n                socket.receive(packet);\r\n            } catch (IOException e) {\r\n                throw new RuntimeException(e);\r\n            }\r\n            parsePacket(packet.getData(), packet.getAddress(), packet.getPort());\r\n\r\n        }\r\n    }\r\n\r\n    private void parsePacket(byte[] data, InetAddress address, int port) {\r\n        String message = new String(data).trim();\r\n        Packet.PacketTypes type = Packet.lookupPacket(message.substring(0,2));\r\n        Packet packet = null;\r\n        switch(type) {\r\n            default:\r\n                break;\r\n            case INVALID:\r\n                break;\r\n            case LOGIN:\r\n                packet = new Packet00Login(data);\r\n                handleLogin((Packet00Login) packet, address, port);\r\n                break;\r\n            case DISCONNECT:\r\n                break;\r\n            case MOVE:\r\n                packet = new Packet02Move(data);\r\n                handleMove((Packet02Move) packet);\r\n                break;\r\n            case ANIMATION:\r\n                packet = new Packet03Animation(data);\r\n                handleAnimation((Packet03Animation)packet);\r\n                break;\r\n            case UNITROOM:\r\n                packet = new Packet04UnitRoom(data);\r\n                handleUnitRoom((Packet04UnitRoom)packet);\r\n                break;\r\n            case VILLAIN:\r\n                packet = new Packet05Villain(data);\r\n                handleVillain((Packet05Villain)packet);\r\n                break;\r\n            case VILLAINMOVE:\r\n                packet = new Packet06VillainMove(data);\r\n                handleVillainMove((Packet06VillainMove) packet);\r\n                break;\r\n            case TIMER:\r\n                packet = new Packet07Timer(data);\r\n                handleTimer((Packet07Timer)packet);\r\n                break;\r\n            case CHESTGENERATION:\r\n                packet = new Packet10ChestGeneration(data);\r\n                handleChestGeneration((Packet10ChestGeneration) packet);\r\n                break;\r\n            case CHESTOPENED:\r\n                packet = new Packet11ChestOpened(data);\r\n                handleChestOpened((Packet11ChestOpened) packet);\r\n                break;\r\n            case ITEMPICKEDUP:\r\n                packet = new Packet12ItemPickedUp(data);\r\n                handleItemPickedUp((Packet12ItemPickedUp) packet);\r\n                break;\r\n            case ITEMDROPPED:\r\n                packet = new Packet13ItemDropped(data);\r\n                handleItemDropped((Packet13ItemDropped) packet);\r\n                break;\r\n            case WALL:\r\n                //System.out.println(\"GOT WALL PACKET\");\r\n                packet = new Packet20Wall(data);\r\n                handleWall((Packet20Wall) packet);\r\n                break;\r\n            case DEATH:\r\n                packet = new Packet21Death(data);\r\n                handleDeath((Packet21Death)packet);\r\n                break;\r\n        }\r\n    }\r\n\r\n    private void handleItemDropped(Packet13ItemDropped packet) {\r\n        for(int i = 0; i < isten.getUpdatables().size(); i++) {\r\n            if(isten.getUpdatable(i).getClass() == ItemManager.class) {\r\n                isten.getUpdatables().get(i).getItems().get(packet.itemIndex).setLocation(Item.Location.GROUND);\r\n                isten.getUpdatables().get(i).getItems().get(packet.itemIndex).getImage().setVisibility(true);\r\n                isten.getUpdatables().get(i).getItems().get(packet.itemIndex).getImage().setPosition(packet.pos);\r\n                isten.getUpdatables().get(i).getItems().get(packet.itemIndex).setPosition(packet.pos);\r\n            }\r\n        }\r\n    }\r\n\r\n    private void handleItemPickedUp(Packet12ItemPickedUp packet) {\r\n        for(int i = 0; i < isten.getUpdatables().size(); i++) {\r\n            if(isten.getUpdatable(i).getClass() == ItemManager.class) {\r\n                isten.getUpdatables().get(i).getItems().get(packet.itemIndex).setLocation(Item.Location.INVENTORY);\r\n                isten.getUpdatables().get(i).getItems().get(packet.itemIndex).getImage().setVisibility(false);\r\n            }\r\n        }\r\n        //isten.getUpdatablesByType(ItemManager.class).getFirst().getItems().get(pack);\r\n\r\n    }\r\n\r\n    private void handleChestOpened(Packet11ChestOpened packet) {\r\n        for(int i = 0; i < isten.getUpdatables().size(); i++) {\r\n            if(isten.getUpdatable(i).getClass() == ChestManager.class) {\r\n                isten.getUpdatables().get(i).getChests().get(packet.chestIndex).open();\r\n            }\r\n        }\r\n    }\r\n\r\n    private int chestGenCount = 0;\r\n    private void handleChestGeneration(Packet10ChestGeneration packet) {\r\n        if(isten.getSocketServer() != null) return;\r\n\r\n        int chestIndex = 0;\r\n        for(int i = 0; i < isten.getUpdatables().size(); i++) {\r\n            if(isten.getUpdatable(i).getClass() == ChestManager.class) {\r\n                chestIndex = i;\r\n                isten.getUpdatables().get(i).getChests().add(new Chest(packet.pos,isten,packet.heading, packet.chestType));\r\n                chestGenCount++;\r\n            }\r\n        }\r\n\r\n        ColliderGroup chestColliders=new ColliderGroup();\r\n        for (int i = 0; i < isten.getUpdatables().get(chestIndex).getChests().size(); i++) {\r\n            Collider c=new Collider( isten.getUpdatables().get(chestIndex).getChests().get(i).getPosition(),new Vec2(0.15f,0.15f));\r\n            chestColliders.addCollider(c);\r\n        }\r\n        isten.getPhysicsEngine().addColliderGroup(chestColliders);\r\n    }\r\n\r\n    private void handleDeath(Packet21Death packet) {\r\n        String username = packet.getUsername();\r\n\r\n        for(int i = 0; i < isten.getUpdatables().size(); i++) {\r\n            if(isten.getUpdatable(i).getClass() == PlayerMP.class) {\r\n                PlayerMP playerMP = (PlayerMP)isten.getUpdatable(i);\r\n                if(playerMP.getUsername().equalsIgnoreCase(username)) {\r\n                    playerMP.setAlive(false);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private void handleWall(Packet20Wall packet) {\r\n        Vec2 pos = new Vec2(packet.getPosX(), packet.getPosY());\r\n        Vec2 scale = new Vec2(packet.getScaleX(), packet.getScaleY());\r\n        boolean isDoor = packet.isDoor();\r\n\r\n        HandlerManager hm = isten.getHandlerManager();\r\n        hm.lock.lock();\r\n            try {\r\n                // Critical section\r\n                // Access shared resources here\r\n                hm.addTask(HandlerManager.TaskType.Wall);\r\n                hm.addData(new HandlerManager.WallData(pos, scale, isDoor));\r\n            } finally {\r\n                hm.lock.unlock(); // Release the lock\r\n            }\r\n    }\r\n\r\n    private void handleUnitRoom(Packet04UnitRoom packet) {\r\n        Vec2 position = new Vec2(packet.getX(), packet.getY());\r\n        int type = packet.getType();\r\n        String path = \"./assets/floors/floor\" + (type+1) + \".png\";\r\n        Map map = isten.getMap();\r\n        for(int i = 0; i < map.getMapRowSize(); i++) {\r\n            for(int j = 0; j < map.getMapColumnSize(); j++) {\r\n                if(map.getUnitRooms()[i][j].getPosition().x == position.x &&\r\n                map.getUnitRooms()[i][j].getPosition().y == position.y) {\r\n                    map.getUnitRooms()[i][j].setNewImage(path, isten);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private void handleTimer(Packet07Timer packet) {\r\n        double timeRemaining = packet.timeRemaining;\r\n        TimeCounter.setTimeRemaining(timeRemaining);\r\n    }\r\n\r\n    private void handleVillainMove(Packet06VillainMove packet) {\r\n        String villainName = packet.getVillainName();\r\n        Vec2 position = new Vec2(packet.getX(), packet.getY());\r\n\r\n        HandlerManager hm = isten.getHandlerManager();\r\n        hm.lock.lock();\r\n            try {\r\n                // Critical section\r\n                // Access shared resources here\r\n                hm.addTask(HandlerManager.TaskType.VillainMove);\r\n                hm.addData(new HandlerManager.VillainMoveData(villainName, position));\r\n            } finally {\r\n                hm.lock.unlock(); // Release the lock\r\n            }\r\n    }\r\n\r\n    private void handleVillain(Packet05Villain packet) {\r\n        String villainName = packet.getVillainName();\r\n        Vec2 position = packet.getPosition();\r\n        String imagePath = packet.getImagePath();\r\n        int random1 = packet.getRandom1();\r\n        int random2 = packet.getRandom2();\r\n\r\n        HandlerManager hm = isten.getHandlerManager();\r\n        hm.lock.lock();\r\n            try {\r\n                // Critical section\r\n                // Access shared resources here\r\n                hm.addTask(HandlerManager.TaskType.Villain);\r\n                hm.addData(new HandlerManager.VillainData(villainName, position, imagePath, random1, random2));\r\n            } finally {\r\n                hm.lock.unlock(); // Release the lock\r\n            }\r\n    }\r\n\r\n    private void handleAnimation(Packet03Animation packet) {\r\n        int index = isten.getPlayerMPIndex(packet.getUsername());\r\n        PlayerMP player = (PlayerMP)isten.getUpdatable(index);\r\n        if(player == null || player.localPlayer || player.getPlayerImage() == null) return;\r\n        for(int i = 0; i < player.getPlayerImage().size(); i++) {\r\n            player.getPlayerImage().get(i).setVisibility(false);\r\n        }\r\n        player.setActiveImage(packet.getActiveImage());\r\n        if(!player.getPlayerImage().isEmpty() && packet.getActiveImage() < player.getPlayerImage().size()) player.getPlayerImage().get(packet.getActiveImage()).setVisibility(true);\r\n    }\r\n\r\n    private void handleLogin(Packet00Login packet, InetAddress address, int port) {\r\n        PlayerMP player = null;\r\n        Vec2 position = new Vec2(packet.getX(), packet.getY());\r\n        String username = packet.getUsername();\r\n        int skinID = packet.getSkinID();\r\n\r\n        HandlerManager hm = isten.getHandlerManager();\r\n        hm.lock.lock();\r\n        try {\r\n            hm.addTask(HandlerManager.TaskType.Login);\r\n            hm.addData(new HandlerManager.LoginData(username, address, port, position, skinID));\r\n        }\r\n        finally {\r\n            hm.lock.unlock();\r\n        }\r\n    }\r\n\r\n    private void handleMove(Packet02Move packet) {\r\n        String username = packet.getUsername();\r\n\r\n        int index = isten.getPlayerMPIndex(username);\r\n        PlayerMP player = (PlayerMP)isten.getUpdatable(index);\r\n        if(player == null) return;\r\n        if(player.getPlayerCollider() != null) player.getPlayerCollider().setPosition(new Vec2(packet.getX(), packet.getY()));\r\n    }\r\n\r\n    public void sendData(byte[] data) {\r\n        DatagramPacket packet = new DatagramPacket(data, data.length, ipAddress, 1331);\r\n        try {\r\n            socket.send(packet);\r\n        } catch (IOException e) {\r\n            throw new RuntimeException(e);\r\n        }\r\n    }\r\n}\r\n
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
-diff --git a/src/main/java/org/networking/GameClient.java b/src/main/java/org/networking/GameClient.java
---- a/src/main/java/org/networking/GameClient.java	(revision 50dea416be2d980ce725745a881d3db402e74354)
-+++ b/src/main/java/org/networking/GameClient.java	(date 1714588707202)
-@@ -295,4 +295,5 @@
-             throw new RuntimeException(e);
-         }
-     }
-+
- }
-Index: src/main/java/org/items/Item.java
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
-<+>package main.java.org.items;\r\n\r\nimport jdk.jshell.execution.LoaderDelegate;\r\nimport main.java.org.game.Graphics.Image;\r\nimport main.java.org.game.Graphics.ImageUI;\r\nimport main.java.org.game.Isten;\r\nimport main.java.org.linalg.Vec2;\r\n\r\nimport java.time.LocalDateTime;\r\n\r\n/*TVSZ denevérbőrre nyomtatott példányai\r\nGasmask\r\nTransistor\r\nLogarléc\r\nSöröspohár, rongy (adott ideig véd a boss-tól)\r\nCamambert (gázszobát csinál, bénítja a boss-t)*/\r\npublic abstract class Item {\r\n    public enum Location {\r\n        CHEST,\r\n        GROUND,\r\n        INVENTORY\r\n    };\r\n    protected final Vec2 scale;\r\n    protected Location location;\r\n    protected Vec2 position;\r\n    protected Image image;\r\n    protected final Isten isten;\r\n    protected String imagePath;\r\n    private int itemIndex;\r\n\r\n    private LocalDateTime droppedAt;\r\n    public Item(Isten isten,Vec2 scale){\r\n        this.scale=scale;\r\n        location=Location.CHEST;\r\n        position=null;\r\n        droppedAt = null;\r\n        this.isten=isten;\r\n        itemIndex = isten.getItemManager().getItems().size();\r\n\r\n        isten.getItemManager().addItem(this);\r\n    }\r\n    public void dropOnGround(Vec2 pos){\r\n        if(!location.equals(Location.GROUND)){\r\n            location = Location.GROUND;\r\n            position = pos;\r\n            image.setPosition(pos);\r\n            image.setVisibility(true);\r\n            droppedAt = LocalDateTime.now();\r\n        }\r\n    }\r\n    public void pickUpInInventory(){\r\n        //Pics up an item if it is not in the inventory, and it has been dropped for more than 200 millisec\r\n        //1 ms = 1000000 ns :)\r\n        if((!location.equals(Location.INVENTORY) && droppedAt.isBefore((LocalDateTime.now()).minusNanos(200000000)))) {\r\n            location = Location.INVENTORY;\r\n            image.setVisibility(false);\r\n            isten.getInventory().addItem(this);\r\n        }\r\n    }\r\n\r\n    public void use(){\r\n\r\n    }\r\n    public String getImagePath(){return imagePath;}\r\n\r\n    public Vec2 getPosition(){return position;}\r\n    public void setPosition(Vec2 pos) { position=pos; }\r\n    public Location getLocation(){return location;}\r\n    public void setLocation(Location loc) { location = loc; }\r\n\r\n    public Image getImage() { return image; }\r\n\r\n    public int getItemIndex() { return itemIndex; }\r\n}\r\n
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
-diff --git a/src/main/java/org/items/Item.java b/src/main/java/org/items/Item.java
---- a/src/main/java/org/items/Item.java	(revision 50dea416be2d980ce725745a881d3db402e74354)
-+++ b/src/main/java/org/items/Item.java	(date 1714578287735)
-@@ -1,6 +1,5 @@
- package main.java.org.items;
- 
--import jdk.jshell.execution.LoaderDelegate;
- import main.java.org.game.Graphics.Image;
- import main.java.org.game.Graphics.ImageUI;
- import main.java.org.game.Isten;
-Index: .idea/gradle.xml
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
-<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"GradleSettings\">\r\n    <option name=\"linkedExternalProjectsSettings\">\r\n      <GradleProjectSettings>\r\n        <option name=\"externalProjectPath\" value=\"$PROJECT_DIR$\" />\r\n        <option name=\"gradleJvm\" value=\"17\" />\r\n        <option name=\"modules\">\r\n          <set>\r\n            <option value=\"$PROJECT_DIR$\" />\r\n          </set>\r\n        </option>\r\n      </GradleProjectSettings>\r\n    </option>\r\n  </component>\r\n</project>
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
-diff --git a/.idea/gradle.xml b/.idea/gradle.xml
---- a/.idea/gradle.xml	(revision 50dea416be2d980ce725745a881d3db402e74354)
-+++ b/.idea/gradle.xml	(date 1714589374642)
-@@ -1,5 +1,6 @@
- <?xml version="1.0" encoding="UTF-8"?>
- <project version="4">
-+  <component name="GradleMigrationSettings" migrationVersion="1" />
-   <component name="GradleSettings">
-     <option name="linkedExternalProjectsSettings">
-       <GradleProjectSettings>
-Index: .idea/workspace.xml
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
-<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"AutoImportSettings\">\r\n    <option name=\"autoReloadType\" value=\"SELECTIVE\" />\r\n  </component>\r\n  <component name=\"ChangeListManager\">\r\n    <list default=\"true\" id=\"3506ab6d-0407-47f2-a7e8-78ebc867e577\" name=\"Changes\" comment=\"\">\r\n      <change beforePath=\"$PROJECT_DIR$/.idea/workspace.xml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/workspace.xml\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/src/main/java/org/game/UI/Minimap.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/main/java/org/game/UI/Minimap.java\" afterDir=\"false\" />\r\n    </list>\r\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\r\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\r\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\r\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\r\n  </component>\r\n  <component name=\"ExternalProjectsData\">\r\n    <projectState path=\"$PROJECT_DIR$\">\r\n      <ProjectState />\r\n    </projectState>\r\n  </component>\r\n  <component name=\"ExternalProjectsManager\">\r\n    <system id=\"GRADLE\">\r\n      <state>\r\n        <task path=\"$PROJECT_DIR$\">\r\n          <activation />\r\n        </task>\r\n        <projects_view />\r\n      </state>\r\n    </system>\r\n  </component>\r\n  <component name=\"Git.Settings\">\r\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\r\n  </component>\r\n  <component name=\"MarkdownSettingsMigration\">\r\n    <option name=\"stateVersion\" value=\"1\" />\r\n  </component>\r\n  <component name=\"ProjectColorInfo\">{\r\n  &quot;associatedIndex&quot;: 8\r\n}</component>\r\n  <component name=\"ProjectId\" id=\"2frbzqFlsraLkUjUjuqMYUBt0BV\" />\r\n  <component name=\"ProjectViewState\">\r\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\r\n    <option name=\"showLibraryContents\" value=\"true\" />\r\n  </component>\r\n  <component name=\"PropertiesComponent\"><![CDATA[{\r\n  \"keyToString\": {\r\n    \"Gradle.iLaby [run].executor\": \"Run\",\r\n    \"RunOnceActivity.OpenProjectViewOnStart\": \"true\",\r\n    \"RunOnceActivity.ShowReadmeOnStart\": \"true\",\r\n    \"WebServerToolWindowFactoryState\": \"false\",\r\n    \"git-widget-placeholder\": \"main\",\r\n    \"last_opened_file_path\": \"D:/ploglamoszasssssz/java/cucc/iLaby\",\r\n    \"node.js.detected.package.eslint\": \"true\",\r\n    \"node.js.detected.package.tslint\": \"true\",\r\n    \"node.js.selected.package.eslint\": \"(autodetect)\",\r\n    \"node.js.selected.package.tslint\": \"(autodetect)\",\r\n    \"settings.editor.selected.configurable\": \"reference.settingsdialog.project.gradle\",\r\n    \"vue.rearranger.settings.migration\": \"true\"\r\n  }\r\n}]]></component>\r\n  <component name=\"RunManager\">\r\n    <configuration name=\"iLaby [run]\" type=\"GradleRunConfiguration\" factoryName=\"Gradle\" singleton=\"false\" nameIsGenerated=\"true\">\r\n      <ExternalSystemSettings>\r\n        <option name=\"executionName\" />\r\n        <option name=\"externalProjectPath\" value=\"$PROJECT_DIR$\" />\r\n        <option name=\"externalSystemIdString\" value=\"GRADLE\" />\r\n        <option name=\"scriptParameters\" value=\"\" />\r\n        <option name=\"taskDescriptions\">\r\n          <list />\r\n        </option>\r\n        <option name=\"taskNames\">\r\n          <list>\r\n            <option value=\"run\" />\r\n          </list>\r\n        </option>\r\n        <option name=\"vmOptions\" />\r\n      </ExternalSystemSettings>\r\n      <ExternalSystemDebugServerProcess>true</ExternalSystemDebugServerProcess>\r\n      <ExternalSystemReattachDebugProcess>true</ExternalSystemReattachDebugProcess>\r\n      <DebugAllEnabled>false</DebugAllEnabled>\r\n      <RunAsTest>false</RunAsTest>\r\n      <method v=\"2\" />\r\n    </configuration>\r\n  </component>\r\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"application-level\" UseSingleDictionary=\"true\" transferred=\"true\" />\r\n  <component name=\"TaskManager\">\r\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\r\n      <changelist id=\"3506ab6d-0407-47f2-a7e8-78ebc867e577\" name=\"Changes\" comment=\"\" />\r\n      <created>1714562409879</created>\r\n      <option name=\"number\" value=\"Default\" />\r\n      <option name=\"presentableId\" value=\"Default\" />\r\n      <updated>1714562409879</updated>\r\n      <workItem from=\"1714562410886\" duration=\"908000\" />\r\n    </task>\r\n    <servers />\r\n  </component>\r\n  <component name=\"TypeScriptGeneratedFilesManager\">\r\n    <option name=\"version\" value=\"3\" />\r\n  </component>\r\n</project>
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
-diff --git a/.idea/workspace.xml b/.idea/workspace.xml
---- a/.idea/workspace.xml	(revision 50dea416be2d980ce725745a881d3db402e74354)
-+++ b/.idea/workspace.xml	(date 1714659210573)
-@@ -5,8 +5,12 @@
-   </component>
-   <component name="ChangeListManager">
-     <list default="true" id="3506ab6d-0407-47f2-a7e8-78ebc867e577" name="Changes" comment="">
-+      <change afterPath="$PROJECT_DIR$/test/MultiplayerTester.java" afterDir="false" />
-+      <change beforePath="$PROJECT_DIR$/.idea/gradle.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/gradle.xml" afterDir="false" />
-       <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
--      <change beforePath="$PROJECT_DIR$/src/main/java/org/game/UI/Minimap.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/org/game/UI/Minimap.java" afterDir="false" />
-+      <change beforePath="$PROJECT_DIR$/src/main/java/org/items/Item.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/org/items/Item.java" afterDir="false" />
-+      <change beforePath="$PROJECT_DIR$/src/main/java/org/networking/GameClient.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/org/networking/GameClient.java" afterDir="false" />
-+      <change beforePath="$PROJECT_DIR$/src/main/java/org/networking/HandlerManager.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/org/networking/HandlerManager.java" afterDir="false" />
-     </list>
-     <option name="SHOW_DIALOG" value="false" />
-     <option name="HIGHLIGHT_CONFLICTS" value="true" />
-@@ -27,6 +31,13 @@
-         <projects_view />
-       </state>
-     </system>
-+  </component>
-+  <component name="FileTemplateManagerImpl">
-+    <option name="RECENT_TEMPLATES">
-+      <list>
-+        <option value="Class" />
-+      </list>
-+    </option>
-   </component>
-   <component name="Git.Settings">
-     <option name="RECENT_GIT_ROOT_PATH" value="$PROJECT_DIR$" />
-@@ -42,23 +53,106 @@
-     <option name="hideEmptyMiddlePackages" value="true" />
-     <option name="showLibraryContents" value="true" />
-   </component>
--  <component name="PropertiesComponent"><![CDATA[{
--  "keyToString": {
--    "Gradle.iLaby [run].executor": "Run",
--    "RunOnceActivity.OpenProjectViewOnStart": "true",
--    "RunOnceActivity.ShowReadmeOnStart": "true",
--    "WebServerToolWindowFactoryState": "false",
--    "git-widget-placeholder": "main",
--    "last_opened_file_path": "D:/ploglamoszasssssz/java/cucc/iLaby",
--    "node.js.detected.package.eslint": "true",
--    "node.js.detected.package.tslint": "true",
--    "node.js.selected.package.eslint": "(autodetect)",
--    "node.js.selected.package.tslint": "(autodetect)",
--    "settings.editor.selected.configurable": "reference.settingsdialog.project.gradle",
--    "vue.rearranger.settings.migration": "true"
-+  <component name="PropertiesComponent">{
-+  &quot;keyToString&quot;: {
-+    &quot;Downloaded.Files.Path.Enabled&quot;: &quot;false&quot;,
-+    &quot;Gradle.MultiplayerTester.executor&quot;: &quot;Run&quot;,
-+    &quot;Gradle.MultiplayerTester.testPacket01.executor&quot;: &quot;Run&quot;,
-+    &quot;Gradle.MultiplayerTester.testPacket02Constructor.executor&quot;: &quot;Run&quot;,
-+    &quot;Gradle.iLaby [run].executor&quot;: &quot;Run&quot;,
-+    &quot;Repository.Attach.Annotations&quot;: &quot;false&quot;,
-+    &quot;Repository.Attach.JavaDocs&quot;: &quot;false&quot;,
-+    &quot;Repository.Attach.Sources&quot;: &quot;false&quot;,
-+    &quot;RunOnceActivity.OpenProjectViewOnStart&quot;: &quot;true&quot;,
-+    &quot;RunOnceActivity.ShowReadmeOnStart&quot;: &quot;true&quot;,
-+    &quot;WebServerToolWindowFactoryState&quot;: &quot;false&quot;,
-+    &quot;git-widget-placeholder&quot;: &quot;main&quot;,
-+    &quot;kotlin-language-version-configured&quot;: &quot;true&quot;,
-+    &quot;last_opened_file_path&quot;: &quot;C:/Users/kuruc/Downloads/junit-4.13.2.jar&quot;,
-+    &quot;node.js.detected.package.eslint&quot;: &quot;true&quot;,
-+    &quot;node.js.detected.package.tslint&quot;: &quot;true&quot;,
-+    &quot;node.js.selected.package.eslint&quot;: &quot;(autodetect)&quot;,
-+    &quot;node.js.selected.package.tslint&quot;: &quot;(autodetect)&quot;,
-+    &quot;project.structure.last.edited&quot;: &quot;Modules&quot;,
-+    &quot;project.structure.proportion&quot;: &quot;0.15&quot;,
-+    &quot;project.structure.side.proportion&quot;: &quot;0.2&quot;,
-+    &quot;settings.editor.selected.configurable&quot;: &quot;reference.settingsdialog.project.gradle&quot;,
-+    &quot;vue.rearranger.settings.migration&quot;: &quot;true&quot;
-   }
--}]]></component>
--  <component name="RunManager">
-+}</component>
-+  <component name="RunManager" selected="Gradle.iLaby [run]">
-+    <configuration name="MultiplayerTester" type="GradleRunConfiguration" factoryName="Gradle" temporary="true">
-+      <ExternalSystemSettings>
-+        <option name="executionName" />
-+        <option name="externalProjectPath" value="$PROJECT_DIR$" />
-+        <option name="externalSystemIdString" value="GRADLE" />
-+        <option name="scriptParameters" value="" />
-+        <option name="taskDescriptions">
-+          <list />
-+        </option>
-+        <option name="taskNames">
-+          <list>
-+            <option value=":test" />
-+            <option value="--tests" />
-+            <option value="&quot;MultiplayerTester&quot;" />
-+          </list>
-+        </option>
-+        <option name="vmOptions" />
-+      </ExternalSystemSettings>
-+      <ExternalSystemDebugServerProcess>false</ExternalSystemDebugServerProcess>
-+      <ExternalSystemReattachDebugProcess>true</ExternalSystemReattachDebugProcess>
-+      <DebugAllEnabled>false</DebugAllEnabled>
-+      <RunAsTest>true</RunAsTest>
-+      <method v="2" />
-+    </configuration>
-+    <configuration name="MultiplayerTester.testPacket01" type="GradleRunConfiguration" factoryName="Gradle" temporary="true">
-+      <ExternalSystemSettings>
-+        <option name="executionName" />
-+        <option name="externalProjectPath" value="$PROJECT_DIR$" />
-+        <option name="externalSystemIdString" value="GRADLE" />
-+        <option name="scriptParameters" value="" />
-+        <option name="taskDescriptions">
-+          <list />
-+        </option>
-+        <option name="taskNames">
-+          <list>
-+            <option value=":test" />
-+            <option value="--tests" />
-+            <option value="&quot;MultiplayerTester.testPacket01&quot;" />
-+          </list>
-+        </option>
-+        <option name="vmOptions" />
-+      </ExternalSystemSettings>
-+      <ExternalSystemDebugServerProcess>false</ExternalSystemDebugServerProcess>
-+      <ExternalSystemReattachDebugProcess>true</ExternalSystemReattachDebugProcess>
-+      <DebugAllEnabled>false</DebugAllEnabled>
-+      <RunAsTest>true</RunAsTest>
-+      <method v="2" />
-+    </configuration>
-+    <configuration name="MultiplayerTester.testPacket02Constructor" type="GradleRunConfiguration" factoryName="Gradle" temporary="true">
-+      <ExternalSystemSettings>
-+        <option name="executionName" />
-+        <option name="externalProjectPath" value="$PROJECT_DIR$" />
-+        <option name="externalSystemIdString" value="GRADLE" />
-+        <option name="scriptParameters" value="" />
-+        <option name="taskDescriptions">
-+          <list />
-+        </option>
-+        <option name="taskNames">
-+          <list>
-+            <option value=":test" />
-+            <option value="--tests" />
-+            <option value="&quot;MultiplayerTester.testPacket02Constructor&quot;" />
-+          </list>
-+        </option>
-+        <option name="vmOptions" />
-+      </ExternalSystemSettings>
-+      <ExternalSystemDebugServerProcess>false</ExternalSystemDebugServerProcess>
-+      <ExternalSystemReattachDebugProcess>true</ExternalSystemReattachDebugProcess>
-+      <DebugAllEnabled>false</DebugAllEnabled>
-+      <RunAsTest>true</RunAsTest>
-+      <method v="2" />
-+    </configuration>
-     <configuration name="iLaby [run]" type="GradleRunConfiguration" factoryName="Gradle" singleton="false" nameIsGenerated="true">
-       <ExternalSystemSettings>
-         <option name="executionName" />
-@@ -81,6 +175,27 @@
-       <RunAsTest>false</RunAsTest>
-       <method v="2" />
-     </configuration>
-+    <list>
-+      <item itemvalue="Gradle.iLaby [run]" />
-+      <item itemvalue="Gradle.MultiplayerTester" />
-+      <item itemvalue="Gradle.MultiplayerTester.testPacket02Constructor" />
-+      <item itemvalue="Gradle.MultiplayerTester.testPacket01" />
-+    </list>
-+    <recent_temporary>
-+      <list>
-+        <item itemvalue="Gradle.MultiplayerTester" />
-+        <item itemvalue="Gradle.MultiplayerTester.testPacket02Constructor" />
-+        <item itemvalue="Gradle.MultiplayerTester.testPacket01" />
-+      </list>
-+    </recent_temporary>
-+  </component>
-+  <component name="SharedIndexes">
-+    <attachedChunks>
-+      <set>
-+        <option value="jdk-18.0.2-corretto-18.0.2-4caba194b151-5720f15e" />
-+        <option value="jdk-21.0.2-openjdk-21.0.2-4caba194b151-4f524021" />
-+      </set>
-+    </attachedChunks>
-   </component>
-   <component name="SpellCheckerSettings" RuntimeDictionaries="0" Folders="0" CustomDictionaries="0" DefaultDictionary="application-level" UseSingleDictionary="true" transferred="true" />
-   <component name="TaskManager">
-Index: test/MultiplayerTester.java
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
-diff --git a/test/MultiplayerTester.java b/test/MultiplayerTester.java
-new file mode 100644
---- /dev/null	(date 1714591021869)
-+++ b/test/MultiplayerTester.java	(date 1714591021869)
-@@ -0,0 +1,107 @@
-+import main.java.org.game.Isten;
-+import main.java.org.linalg.Vec2;
-+import main.java.org.networking.*;
-+import org.junit.Assert;
-+import org.junit.Test;
-+
-+public class MultiplayerTester {
-+
-+    @Test
-+    public void testPacket02Constructor() {
-+        Packet02Move packet02Move = new Packet02Move("username", 1, 1);
-+        Assert.assertEquals(packet02Move, new Packet02Move("username", 1, 1));
-+    }
-+
-+    @Test
-+    public void testPacket03Constructor() {
-+        Packet03Animation packet03Animation = new Packet03Animation("username", 1);
-+        Assert.assertEquals(packet03Animation, new Packet03Animation("username", 1));
-+    }
-+
-+    @Test
-+    public void testPacket04Constructor() {
-+        Packet04UnitRoom packet04UnitRoom = new Packet04UnitRoom(1,1,1);
-+        Assert.assertEquals(packet04UnitRoom, new Packet04UnitRoom(1,1,1));
-+    }
-+
-+    @Test
-+    public void testPacket05Constructor() {
-+        Packet05Villain packet05Villain = new Packet05Villain("villain", new Vec2(1,1), "imgpath", 0, 0);
-+        Assert.assertEquals(packet05Villain, new Packet05Villain("villain", new Vec2(1,1), "imgpath", 0, 0));
-+    }
-+
-+    @Test
-+    public void testPacket06Constructor() {
-+        Packet06VillainMove packet06VillainMove = new Packet06VillainMove("villain1", 1, 1);
-+        Assert.assertEquals(packet06VillainMove, new Packet06VillainMove("villain1", 1, 1));
-+    }
-+
-+    @Test
-+    public void testPacket07Constructor() {
-+        Packet07Timer packet07Timer = new Packet07Timer(2.0f);
-+        Assert.assertEquals(packet07Timer, new Packet07Timer(2.0f));
-+    }
-+
-+    @Test
-+    public void testPacket21Constructor() {
-+        Packet21Death packet21Death = new Packet21Death("player1");
-+        Assert.assertEquals(packet21Death, new Packet21Death("player1"));
-+    }
-+
-+    @Test
-+    public void testSentPacketEqualsArrivedPacket02() {
-+        Packet02Move packet = new Packet02Move("player1", 2.0f, 2.0f);
-+        byte[] data = "02player1,2.0,2.0".getBytes();
-+        Assert.assertEquals(new Packet02Move(data), packet);
-+    }
-+
-+    @Test
-+    public void testSentPacketEqualsArrivedPacket03() {
-+        Packet03Animation packet = new Packet03Animation("player1", 1);
-+        byte[] data = "03player1,1".getBytes();
-+        Assert.assertEquals(new Packet03Animation(data), packet);
-+    }
-+
-+    @Test
-+    public void testSentPacketEqualsArrivedPacket04() {
-+        Packet04UnitRoom packet = new Packet04UnitRoom(2.0f, 2.0f, 1);
-+        byte[] data = "042.0,2.0,1".getBytes();
-+        Assert.assertEquals(new Packet04UnitRoom(data), packet);
-+    }
-+
-+    @Test
-+    public void testSentPacketEqualsArrivedPacket05() {
-+        Packet05Villain packet = new Packet05Villain("villain1", new Vec2(1,1), "imagePath", 1, 1);
-+        byte[] data = "05villain1,1.0,1.0,imagePath,1,1".getBytes();
-+        Assert.assertEquals(new Packet05Villain(data), packet);
-+    }
-+
-+    @Test
-+    public void testSentPacketEqualsArrivedPacket06() {
-+        Packet06VillainMove packet = new Packet06VillainMove("villain1", 1.0f, 1.0f);
-+        byte[] data = "06villain1,1.0,1.0".getBytes();
-+        Assert.assertEquals(new Packet06VillainMove(data), packet);
-+    }
-+
-+    @Test
-+    public void testSentPacketEqualsArrivedPacket07() {
-+        Packet07Timer packet = new Packet07Timer(3.0);
-+        byte[] data = "073.0".getBytes();
-+        Assert.assertEquals(new Packet07Timer(data), packet);
-+    }
-+
-+    @Test
-+    public void testSentPacketEqualsArrivedPacket20() {
-+        Packet20Wall packet = new Packet20Wall(1.0f, 1.0f, 2.0f, 2.0f, true);
-+        byte[] data = "201.0,1.0,2.0,2.0,1".getBytes();
-+        Assert.assertEquals(new Packet20Wall(data), packet);
-+    }
-+
-+    @Test
-+    public void testSentPacketEqualsArrivedPacket21() {
-+        Packet21Death packet = new Packet21Death("player1");
-+        byte[] data = "21player1".getBytes();
-+        Assert.assertEquals(new Packet21Death(data), packet);
-+    }
-+
-+}
-Index: src/main/java/org/networking/HandlerManager.java
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
-<+>package main.java.org.networking;\r\n\r\nimport main.java.org.entities.villain.Villain;\r\nimport main.java.org.game.Graphics.Image;\r\n\r\nimport java.net.InetAddress;\r\nimport java.util.concurrent.locks.Lock;\r\nimport main.java.org.game.Graphics.Text;\r\nimport main.java.org.game.Isten;\r\nimport main.java.org.game.Map.Map;\r\nimport main.java.org.game.Map.Room;\r\nimport main.java.org.game.Map.UnitRoom;\r\nimport main.java.org.game.physics.Collider;\r\nimport main.java.org.game.physics.ColliderGroup;\r\nimport main.java.org.linalg.Vec2;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.Collections;\r\nimport java.util.List;\r\nimport java.util.concurrent.locks.ReentrantLock;\r\nimport java.util.logging.Handler;\r\n\r\npublic class HandlerManager {\r\n\r\n    Isten isten;\r\n\r\n    public HandlerManager(Isten isten) {\r\n        this.isten = isten;\r\n    }\r\n\r\n    private List<TaskType> tasks = new ArrayList<>();\r\n    private List<TaskType> synchronizedTasks = Collections.synchronizedList(tasks);\r\n    private List<HandlerData> handlerDataList = new ArrayList<>();\r\n    private List<HandlerData> synchronizedHandlerDataList = Collections.synchronizedList(handlerDataList);\r\n    public Lock lock = new ReentrantLock();\r\n\r\n    //->>>>>>>>>>>>>>>>//\r\n    //HANDLER DATA\r\n    //->>>>>>>>>>>>>>>>//\r\n    public static abstract class HandlerData {\r\n\r\n    }\r\n\r\n    public static class VillainData extends HandlerData {\r\n        VillainData(String villainName, Vec2 position, String imgPath, int random1, int random2) {\r\n            this.villainName = villainName;\r\n            this.position = position;\r\n            this.imgPath = imgPath;\r\n            this.random1 = random1;\r\n            this.random2 = random2;\r\n        }\r\n\r\n        public String villainName;\r\n        public Vec2 position;\r\n        public String imgPath;\r\n        public int random1;\r\n        public int random2;\r\n    }\r\n\r\n    public static class WallData extends HandlerData {\r\n\r\n        WallData(Vec2 pos, Vec2 scale, boolean isDoor) {\r\n            this.pos = pos;\r\n            this.scale = scale;\r\n            this.isDoor = isDoor;\r\n        }\r\n\r\n        public Vec2 pos;\r\n        public Vec2 scale;\r\n        public boolean isDoor;\r\n    }\r\n\r\n    public static class VillainMoveData extends HandlerData {\r\n        public VillainMoveData(String villainName, Vec2 position) {\r\n            this.villainName = villainName;\r\n            this.position = position;\r\n        }\r\n\r\n        public String villainName;\r\n        public Vec2 position;\r\n    }\r\n\r\n    public static class LoginData extends HandlerData {\r\n        public LoginData(String username, InetAddress inetAddress, int port, Vec2 position, int skinID) {\r\n            this.username = username;\r\n            this.inetAddress = inetAddress;\r\n            this.port = port;\r\n            this.position = position;\r\n            this.skinID = skinID;\r\n        }\r\n\r\n        public String username;\r\n        public Vec2 position;\r\n        public int port;\r\n        public InetAddress inetAddress;\r\n        public int skinID;\r\n    }\r\n\r\n    //->>>>>>>>>>>>>>>>//\r\n    //EXECUTION\r\n    //->>>>>>>>>>>>>>>>//\r\n    public void executeTasks() {\r\n\r\n        if (synchronizedHandlerDataList.size() != synchronizedTasks.size()) return;\r\n\r\n        /*\r\n        lock.lock();\r\n        try {\r\n            for(int i = 0; i < synchronizedTasks.size(); i++) {\r\n                TaskType task = synchronizedTasks.get(i);\r\n                HandlerData data = synchronizedHandlerDataList.get(i);\r\n                if(task == TaskType.VillainMove) {\r\n                    System.out.println(task);\r\n                    System.out.println(data.getClass());\r\n                }\r\n            }\r\n        }\r\n        finally {\r\n            lock.unlock();\r\n        }\r\n\r\n         */\r\n\r\n\r\n        while (!synchronizedTasks.isEmpty()) {\r\n\r\n            TaskType task;\r\n            HandlerData data;\r\n\r\n            lock.lock();\r\n            try {\r\n                // Critical section\r\n                // Access shared resources here\r\n                task = getTask();\r\n                data = getHandlerData();\r\n            } finally {\r\n                lock.unlock(); // Release the lock\r\n            }\r\n\r\n            if (task == null || data == null) return;\r\n            switch (task) {\r\n                case Villain: {\r\n                    if (data.getClass() != VillainData.class) return;\r\n                    VillainData villainData = (VillainData) data;\r\n                    villainHandler(villainData);\r\n                    break;\r\n                }\r\n                case VillainMove: {\r\n                    if (data.getClass() != VillainMoveData.class) return;\r\n                    VillainMoveData villainMoveData = (VillainMoveData) data;\r\n                    villainMoveHandler(villainMoveData);\r\n                    break;\r\n                }\r\n                case Wall: {\r\n                    if (data.getClass() != WallData.class) return;\r\n                    WallData wallData = (WallData) data;\r\n                    wallHandler(wallData);\r\n                    break;\r\n                }\r\n                case Login: {\r\n                    if(data.getClass() != LoginData.class) return;\r\n                    LoginData loginData = (LoginData)data;\r\n                    loginHandler(loginData);\r\n                    break;\r\n                }\r\n            }\r\n\r\n        }\r\n\r\n\r\n    }\r\n\r\n    //->>>>>>>>>>>>>>>>//\r\n    //TASKTYPE ENUM\r\n    //->>>>>>>>>>>>>>>>//\r\n    public enum TaskType {\r\n        Villain,\r\n        VillainMove,\r\n        Wall,\r\n        Login,\r\n    }\r\n\r\n    synchronized public void addTask(TaskType type) {\r\n        lock.lock();\r\n        try {\r\n            synchronizedTasks.add(type);\r\n        }\r\n        finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n\r\n    synchronized public void addData(HandlerData data) {\r\n        lock.lock();\r\n        try {\r\n            synchronizedHandlerDataList.add(data);\r\n        }\r\n        finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n\r\n    public TaskType getTask() {\r\n        lock.lock();\r\n        try {\r\n            if (tasks.isEmpty()) return null;\r\n            return synchronizedTasks.remove(0);\r\n        }\r\n        finally {\r\n            lock.unlock();\r\n        }\r\n\r\n    }\r\n\r\n    public HandlerData getHandlerData() {\r\n        lock.lock();\r\n        try {\r\n            if (handlerDataList.isEmpty()) return null;\r\n            return synchronizedHandlerDataList.remove(0);\r\n        }\r\n        finally {\r\n            lock.unlock();\r\n        }\r\n\r\n    }\r\n\r\n\r\n    //->>>>>>>>>>>>>>>>//\r\n    //HANDLER FUNCTIONS\r\n    //->>>>>>>>>>>>>>>>//\r\n    private void wallHandler(WallData wallData) {\r\n        ColliderGroup cg = new ColliderGroup();\r\n        Collider collider = new Collider(wallData.pos, wallData.scale);\r\n\r\n        if (wallData.isDoor) {\r\n            isten.getRenderer().addRenderable(new Image(wallData.pos, wallData.scale, \"./assets/doors/doors_leaf_closed.png\"));\r\n            collider.setSolidity(false);\r\n        } else {\r\n            isten.getRenderer().addRenderable(new Image(wallData.pos, wallData.scale, \"./assets/walls/wall_mid.png\"));\r\n\r\n        }\r\n\r\n        cg.addCollider(collider);\r\n        isten.getPhysicsEngine().addColliderGroup(cg);\r\n    }\r\n\r\n    private void villainHandler(VillainData villainData) {\r\n        Villain villain = new Villain(villainData.villainName, villainData.position, villainData.imgPath);\r\n        //villain.setRoomForVillain(isten.getMap().getRooms(), villainData.random1, villainData.random2);\r\n        isten.addUpdatable(villain);\r\n    }\r\n\r\n    private void villainMoveHandler(VillainMoveData villainMoveData) {\r\n        int index = isten.getVillainIndex(villainMoveData.villainName);\r\n        Villain villain = (Villain) isten.getUpdatable(index);\r\n        if (villain == null) {\r\n            return;\r\n        }\r\n        if (villain.getVillainCollider() != null) {\r\n            Vec2 position = villainMoveData.position;\r\n            villain.getVillainCollider().setPosition(position);\r\n        }\r\n    }\r\n\r\n    private void loginHandler(LoginData loginData) {\r\n        String username = loginData.username;\r\n        InetAddress address = loginData.inetAddress;\r\n        int port = loginData.port;\r\n        Vec2 position = loginData.position;\r\n        int skinID = loginData.skinID;\r\n\r\n        PlayerMP player = new PlayerMP(username, address, port, position);\r\n        player.setSkinID(skinID);\r\n        isten.addUpdatable(player);\r\n    }\r\n}
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
-diff --git a/src/main/java/org/networking/HandlerManager.java b/src/main/java/org/networking/HandlerManager.java
---- a/src/main/java/org/networking/HandlerManager.java	(revision 50dea416be2d980ce725745a881d3db402e74354)
-+++ b/src/main/java/org/networking/HandlerManager.java	(date 1714578021288)
-@@ -7,6 +7,7 @@
- import java.util.concurrent.locks.Lock;
- import main.java.org.game.Graphics.Text;
- import main.java.org.game.Isten;
-+import main.java.org.game.Map.EdgeBetweenRooms;
- import main.java.org.game.Map.Map;
- import main.java.org.game.Map.Room;
- import main.java.org.game.Map.UnitRoom;
Index: .idea/shelf/Uncommitted_changes_before_Update_at_01_05_2024_13_06__Changes_.xml
===================================================================
diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_01_05_2024_13_06__Changes_.xml b/.idea/shelf/Uncommitted_changes_before_Update_at_01_05_2024_13_06__Changes_.xml
deleted file mode 100644
--- a/.idea/shelf/Uncommitted_changes_before_Update_at_01_05_2024_13_06__Changes_.xml	(revision 072d073c088012b37a1d4a123bd6255c2258b9ce)
+++ /dev/null	(revision 072d073c088012b37a1d4a123bd6255c2258b9ce)
@@ -1,9 +0,0 @@
-<changelist name="Uncommitted_changes_before_Update_at_01_05_2024_13_06_[Changes]" date="1714561590836" recycled="true" deleted="true">
-  <option name="PATH" value="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_01_05_2024_13_06_[Changes]/shelved.patch" />
-  <option name="DESCRIPTION" value="Uncommitted changes before Update at 01/05/2024 13:06 [Changes]" />
-  <binary>
-    <option name="BEFORE_PATH" value="data/sus.amogus" />
-    <option name="AFTER_PATH" value="data/sus.amogus" />
-    <option name="SHELVED_PATH" value="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_01_05_2024_13_06_[Changes]/sus.amogus" />
-  </binary>
-</changelist>
\ No newline at end of file
Index: .idea/shelf/Uncommitted_changes_before_Update_at_01_05_2024_13_38_[Changes]1/shelved.patch
===================================================================
diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_01_05_2024_13_38_[Changes]1/shelved.patch b/.idea/shelf/Uncommitted_changes_before_Update_at_01_05_2024_13_38_[Changes]1/shelved.patch
deleted file mode 100644
--- a/.idea/shelf/Uncommitted_changes_before_Update_at_01_05_2024_13_38_[Changes]1/shelved.patch	(revision 072d073c088012b37a1d4a123bd6255c2258b9ce)
+++ /dev/null	(revision 072d073c088012b37a1d4a123bd6255c2258b9ce)
@@ -1,103 +0,0 @@
-Index: src/main/java/org/game/Map/Map.java
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
-<+>package main.java.org.game.Map;\r\n\r\nimport main.java.org.game.Graphics.Image;\r\nimport main.java.org.game.Isten;\r\nimport main.java.org.game.physics.Collider;\r\nimport main.java.org.game.updatable.Updatable;\r\nimport main.java.org.linalg.Vec2;\r\n\r\nimport java.util.*;\r\n\r\n\r\npublic class Map extends Updatable {\r\n    private Mapgenerator mapgenerator;\r\n    ArrayList<Room> rooms;\r\n    private UnitRoom[][] unitRooms;\r\n    private final int mapRowSize;\r\n    private final int mapColumnSize;\r\n    private EdgeManager edgeManager;\r\n    private final int minRoomSize;\r\n    private boolean isGenerated = false;\r\n    //private boolean\r\n\r\n    @Override\r\n    public void onStart(Isten isten) {\r\n\r\n        Mapgenerator mapgenerator = new Mapgenerator(this, isten);\r\n        mapgenerator.generateSideWalls();\r\n        //printMap();\r\n    }\r\n\r\n    public void init(Isten isten) {\r\n        this.edgeManager = new EdgeManager(isten);\r\n        this.mapgenerator = new Mapgenerator(this, isten);\r\n        mapgenerator.generate(minRoomSize);\r\n        isGenerated = true;\r\n    }\r\n\r\n    public Map(int rowNumber, int columnNumber, int minRoomSize){\r\n        this.mapRowSize = rowNumber;\r\n        this.mapColumnSize = columnNumber;\r\n        this.minRoomSize = minRoomSize;\r\n        //unitrooms is set in the generator --> onstart\r\n        this.rooms = new ArrayList<>();\r\n        initUnitRooms();\r\n\r\n    }\r\n\r\n    //for testing\r\n    boolean merged = false;\r\n    double delta = 0;\r\n    int cnt = 0;\r\n    int r = 0;\r\n    @Override\r\n    public void onUpdate(Isten isten, double deltaTime) {\r\n        //for testing\r\n        delta += deltaTime;\r\n        if (delta > 3 && cnt < 4 && !merged) {\r\n            //mergeRooms(rooms.get(0), rooms.get(0).getAdjacentRooms().get(0), isten);\r\n            /*if (!splitRooms(rooms.get(r), isten)) r++;\r\n            else {\r\n                r = 0;\r\n            }\r\n\r\n             */\r\n            System.out.println();\r\n            System.out.println();\r\n            //printMap();\r\n            cnt++;\r\n            delta = 0;\r\n            merged = true;\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void onDestroy() {\r\n\r\n    }\r\n    public void initUnitRooms(){\r\n        unitRooms = new UnitRoom[mapRowSize][mapColumnSize];\r\n        for(int i = 0; i<mapRowSize;i++)\r\n        {\r\n            for(int j = 0;j<mapColumnSize;j++)\r\n            {\r\n                unitRooms[i][j] = new UnitRoom(new Vec2(j,i));\r\n            }\r\n        }\r\n    }\r\n\r\n    //csak akkor ha minden ajto nyitva van!!\r\n    //a slitelesnel csak a minroomsize fele engedelyezett\r\n    private boolean splitRooms(Room r1, Isten isten)\r\n    {\r\n        if(r1.getUnitRooms().size() < minRoomSize) return false;\r\n        //egyenlőre minden szoba ami splittel lesz createlve ilyen type-val rendelkezik\r\n        int newID = generateNewRoomID(); //már kész van, teszt miatt nincs hasznalva\r\n        //int newId = 999;\r\n        Room newRoom = new Room(newID);\r\n        int lowestRowIdx = getRoomWithLowestRowIdx(r1);\r\n        ArrayList<UnitRoom> addableUnitRooms = new ArrayList<>();\r\n        int distance = 0;\r\n        ArrayList<UnitRoom> UnitRoomsWithDistanceXFromLowestRow;\r\n        //addig, amíg az új szoba a méret fele nem lesz\r\n        while(addableUnitRooms.size()<r1.getUnitRooms().size()/2){\r\n            UnitRoomsWithDistanceXFromLowestRow=getUnitRoomsWithXDistanceFromLowestRowIdxInOrderByColumn(r1,lowestRowIdx,distance++); //tavolsag novelese, es igy soronkent egyesevel balrol jobbra az osszes unitroom hozzaadasa, amig kell\r\n            for(UnitRoom addableUnitRoom:UnitRoomsWithDistanceXFromLowestRow){\r\n                if(addableUnitRooms.size()<r1.getUnitRooms().size()/2 )\r\n                {\r\n                    addableUnitRooms.add(addableUnitRoom);\r\n                }\r\n\r\n            }\r\n        }\r\n        ArrayList<UnitRoom> oldRoomWithoutNewRoom = getDifference(r1.getUnitRooms(),addableUnitRooms);\r\n        //ellenorzom, hogy osszefuggoek lennének-e: ha igen:\r\n        if( kruskalAlgoImplementation(oldRoomWithoutNewRoom) && kruskalAlgoImplementation(addableUnitRooms)) {\r\n            // removeoljuk a szomszedos roomok szomszedossagi listaibol a szobat, es a func vegen hozzaadjuk a ket szetvalasztott szoba egyiket/mindekettot\r\n            for(Room neighbourRoom : r1.getAdjacentRooms()){\r\n                neighbourRoom.getAdjacentRooms().remove(r1);\r\n            }\r\n            for (UnitRoom addUnitRoomToNewRoom : addableUnitRooms) {\r\n                //kivesszük az előző szobából a  aunitroomot\r\n                addUnitRoomToNewRoom.getOwnerRoom().getUnitRooms().remove(addUnitRoomToNewRoom);\r\n                addUnitRoomToNewRoom.setOwnerRoom(newRoom);\r\n                //hozzáadjuk az új szobához a unitroomot\r\n                newRoom.getUnitRooms().add(addUnitRoomToNewRoom);\r\n            }\r\n            rooms.add(newRoom);\r\n            newRoom.setAdjacentRooms();\r\n            r1.setAdjacentRooms();\r\n\r\n            //set the images\r\n            for(UnitRoom unitRoom : newRoom.getUnitRooms()) {\r\n                unitRoom.addRightImage(isten);\r\n            }\r\n            //update nodeRooms and generate the new ones\r\n            //also updates the images and colliders\r\n            edgeManager.updateEdgesAfterSplit(r1, newRoom);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n\r\n    public static ArrayList<UnitRoom> getDifference(ArrayList<UnitRoom> u1, ArrayList<UnitRoom> u2)\r\n    {\r\n        ArrayList<UnitRoom> difference = new ArrayList<>();\r\n        for (UnitRoom element : u1) {\r\n            if (!u2.contains(element)) {\r\n                difference.add(element);\r\n            }\r\n        }\r\n        return difference;\r\n    }\r\n    //nem biztos hogy így a legjobb\r\n    private boolean wouldRoomBeCoherent(ArrayList<UnitRoom> newRoomUnits)\r\n    {\r\n        UnitRoom starterRoom = newRoomUnits.get(0);\r\n        ArrayList<UnitRoom> coherentGraph = new ArrayList<>();\r\n        coherentGraph.add(starterRoom);\r\n        for(int i = 0;i<newRoomUnits.size();i++){\r\n            for(UnitRoom unitRoomToBeAddedToGraph : newRoomUnits){\r\n                 /*ha a size i-vel egyenlő, vagy kisebb nála, akkor tudjuk, hogy nem alkotnak összefüggő gráfot a UnitRoomok a Roomban,\r\n                    mert különben az előző körhöz képest legalább 1-et fel kellett volna tuidjak venni, vagy pedig már előtte többet kellett volna tudjak felvenni,\r\n                    rekurzív gondolat, mukodik (remelem)*/\r\n                if(coherentGraph.size()> i)\r\n                {\r\n                    if (!unitRoomToBeAddedToGraph.equals(coherentGraph.get(i))\r\n                            && !coherentGraph.contains(unitRoomToBeAddedToGraph)\r\n                            && unitRoomToBeAddedToGraph.isAdjacent(coherentGraph.get(i)))\r\n                    {\r\n                        coherentGraph.add(unitRoomToBeAddedToGraph);\r\n                        //break; ezzel valszeg effektivebb\r\n                    }\r\n                }\r\n                else{\r\n                    System.out.println(\"Nem lennenek koherensek a szobak\");\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        //mivel minden indexen vegig tudtunk menni ezert tudunk truet returnolni, azert biztonsag kedveert meg egy kontrollt bennhagyok\r\n        if(coherentGraph.size() == newRoomUnits.size()) return true;\r\n            //hogyha nem egyenlok akkor false menjen ki, bar egyenloknek kene lenniuk\r\n        else return false;\r\n    }\r\n    //elozo fv, vagyis wouldRoomBeCoherent atirasa generikusra, es akkor egy wouldMapBeCoherent fv-t is helyettesit.\r\n    private<T extends Graph> boolean kruskalAlgoImplementation(ArrayList<T> newCoherentElements)\r\n    {\r\n        T starterRoom = newCoherentElements.get(0);\r\n        ArrayList<T> coherentGraph = new ArrayList<>();\r\n        coherentGraph.add(starterRoom);\r\n        for(int i = 0;i<newCoherentElements.size();i++){\r\n            for(T ElementToBeAddedToGraph : newCoherentElements){\r\n                 /*ha a size i-vel egyenlő, vagy kisebb nála, akkor tudjuk, hogy nem alkotnak összefüggő gráfot a UnitRoomok a Roomban,\r\n                    mert különben az előző körhöz képest legalább 1-et fel kellett volna tuidjak venni, vagy pedig már előtte többet kellett volna tudjak felvenni,\r\n                    rekurzív gondolat, mukodik (remelem)*/\r\n                if(coherentGraph.size()> i)\r\n                {\r\n                    if (!ElementToBeAddedToGraph.equals(coherentGraph.get(i))\r\n                            && !coherentGraph.contains(ElementToBeAddedToGraph)\r\n                            && ElementToBeAddedToGraph.isAdjacent(coherentGraph.get(i)))\r\n                    {\r\n                        coherentGraph.add(ElementToBeAddedToGraph);\r\n                        //break; ezzel valszeg effektivebb\r\n                    }\r\n                }\r\n                else{\r\n                    System.out.println(\"Nem lennenek koherensek a szobak\");\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        //mivel minden indexen vegig tudtunk menni ezert tudunk truet returnolni, azert biztonsag kedveert meg egy kontrollt bennhagyok\r\n        if(coherentGraph.size() == newCoherentElements.size()) return true;\r\n            //hogyha nem egyenlok akkor false menjen ki, bar egyenloknek kene lenniuk\r\n        else return false;\r\n    }\r\n\r\n    //function hogy megtalaljam a legkisebb sorindexet a tombben, viszonyitasi parameter lesz.\r\n    // splitRooms func-on belül használva\r\n    private int getRoomWithLowestRowIdx(Room r1) {\r\n        UnitRoom min = unitRooms[mapRowSize-1][mapColumnSize-1];\r\n        for(UnitRoom unitRoom : r1.getUnitRooms())\r\n        {\r\n            if(unitRoom.getRowNum()<min.getRowNum())\r\n            {\r\n                min = unitRoom;\r\n            }\r\n        }\r\n        return min.getRowNum();\r\n    }\r\n    //function hogy megtalaljam azon UnitRoomokat, amik egy adott szamu soraban vannak a szobanaka alulrol nezve, amit a distance hataroz meg\r\n    // splitRooms func-on belül használva\r\n    private ArrayList<UnitRoom> getUnitRoomsWithXDistanceFromLowestRowIdxInOrderByColumn(Room r1, int lowestRowIdx, int distance) {\r\n        ArrayList<UnitRoom> ret = new ArrayList<>();\r\n        for(UnitRoom unitRoom: r1.getUnitRooms()){\r\n            if(unitRoom.getRowNum()==lowestRowIdx+distance){\r\n                ret.add(unitRoom);\r\n            }\r\n        }\r\n        ret.sort(Comparator.comparing(UnitRoom::getColNum));\r\n        return ret;\r\n    }\r\n\r\n    //ez a fv a mapgenerátorban is hasonlóan szerepel (colliderek és imagek nélkül)\r\n    private void mergeRooms(Room r1, Room r2, Isten isten) {\r\n        if(!r1.isAdjacent(r2) || r1.getID() == r2.getID()){\r\n            System.err.println(\"cant be merged\");\r\n            return;\r\n        }\r\n        System.out.println(r2.getID() + \"(r2) is merged to (r1)\" + r1.getID());\r\n        //remove r2 and keep r1;\r\n\r\n        //set colliders\r\n\r\n        edgeManager.deleteEdge(r1,r2);\r\n        edgeManager.updateEdgesAfterMerge(r1,r2);\r\n\r\n        for(UnitRoom unitRoom : r2.getUnitRooms()){\r\n            //r1.getUnitRooms().add(unitroom);\r\n            unitRoom.setOwnerRoom(r1);\r\n\r\n            //setting the new images of the deleted room\r\n            //this method cares about the renderable items too\r\n            unitRoom.addRightImage(isten);\r\n        }\r\n\r\n        r1.getUnitRooms().addAll(r2.getUnitRooms()); //insted of this: r1.getUnitRooms().add(unitroom);\r\n\r\n        r1.getAdjacentRooms().remove(r2);\r\n        r2.getAdjacentRooms().remove(r1);\r\n        for(Room adj : r2.getAdjacentRooms()){\r\n            if(!r1.getAdjacentRooms().contains(adj) && !adj.equals(r1)){\r\n                //System.out.println(\"adjroom added in r1: \" + adj.getID());\r\n                r1.getAdjacentRooms().add(adj);\r\n            }\r\n            adj.getAdjacentRooms().remove(r2);\r\n            if(!adj.getAdjacentRooms().contains(r1)) {\r\n                adj.getAdjacentRooms().add(r1);\r\n            }\r\n        }\r\n\r\n        r2.getAdjacentRooms().clear();\r\n        r2.getUnitRooms().clear();\r\n\r\n        //r1.setDiscovered(r2.isDiscovered());\r\n        //r1.setPlayerCount(r1.getPlayerCount() + r2.getPlayerCount());\r\n        //r1.setRoomType(r2.getRoomType());\r\n        r1.setMaxPlayerCount(r1.getMaxPlayerCount() + r2.getMaxPlayerCount());\r\n        rooms.remove(r2);\r\n\r\n\r\n    }\r\n\r\n    //merge the rooms until every room has minimumm size of the given number\r\n    private void printMap(){\r\n        for(int i = 0;i < mapRowSize;i++){ //test\r\n            for(int j = 0; j< mapColumnSize;j++){\r\n                if(unitRooms[i][j].getOwnerRoom().getID() < 10) {\r\n                    System.out.print(unitRooms[i][j].getOwnerRoom().getID() + \"     \");\r\n                }\r\n                else if(unitRooms[i][j].getOwnerRoom().getID() >= 10 && unitRooms[i][j].getOwnerRoom().getID() < 100) {\r\n                    System.out.print(unitRooms[i][j].getOwnerRoom().getID() + \"    \");\r\n                }\r\n                else if(unitRooms[i][j].getOwnerRoom().getID() >= 100) {\r\n                    System.out.print(unitRooms[i][j].getOwnerRoom().getID() + \"   \");\r\n                }\r\n            }\r\n            System.out.println();\r\n            System.out.println();\r\n        }\r\n    }\r\n    private int generateNewRoomID(){\r\n        int newID = 0;\r\n        while(true){\r\n            int roomCnt = 0;\r\n            for(Room room : rooms){\r\n                if(room.getID() == newID){\r\n                    newID++;\r\n                    break; //not found, try the next ID\r\n                }\r\n                roomCnt++;\r\n            }\r\n            if(roomCnt == rooms.size()){\r\n                return newID;\r\n            }\r\n\r\n\r\n        }\r\n\r\n    }\r\n\r\n\r\n    public void setRooms(ArrayList<Room> rooms) {this.rooms = rooms;}\r\n\r\n    public void setUnitRooms(UnitRoom[][] unitRooms) {\r\n        this.unitRooms = unitRooms;\r\n    }\r\n\r\n    public ArrayList<Room> getRooms() {\r\n        return rooms;\r\n    }\r\n\r\n    public UnitRoom[][] getUnitRooms() {\r\n        return unitRooms;\r\n    }\r\n\r\n    public int getMapRowSize() {\r\n        return mapRowSize;\r\n    }\r\n\r\n    public int getMapColumnSize() {\r\n        return mapColumnSize;\r\n    }\r\n    public EdgeManager getEdgeManager(){ return edgeManager;}\r\n    public boolean isGenerated() {\r\n        return isGenerated;\r\n    }\r\n}\r\n
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
-diff --git a/src/main/java/org/game/Map/Map.java b/src/main/java/org/game/Map/Map.java
---- a/src/main/java/org/game/Map/Map.java	
-+++ b/src/main/java/org/game/Map/Map.java	
-@@ -19,7 +19,6 @@
-     private final int minRoomSize;
-     private boolean isGenerated = false;
-     //private boolean
--
-     @Override
-     public void onStart(Isten isten) {
- 
-@@ -29,18 +28,18 @@
-     }
- 
-     public void init(Isten isten) {
--        this.edgeManager = new EdgeManager(isten);
-         this.mapgenerator = new Mapgenerator(this, isten);
-         mapgenerator.generate(minRoomSize);
-         isGenerated = true;
-     }
- 
--    public Map(int rowNumber, int columnNumber, int minRoomSize){
-+    public Map(Isten isten, int rowNumber, int columnNumber, int minRoomSize){
-         this.mapRowSize = rowNumber;
-         this.mapColumnSize = columnNumber;
-         this.minRoomSize = minRoomSize;
-         //unitrooms is set in the generator --> onstart
-         this.rooms = new ArrayList<>();
-+        this.edgeManager = new EdgeManager(isten);
-         initUnitRooms();
- 
-     }
-Index: src/main/java/org/game/UI/Minimap.java
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
-<+>package main.java.org.game.UI;\r\n\r\nimport main.java.org.game.Graphics.Image;\r\nimport main.java.org.game.Graphics.ImageUI;\r\nimport main.java.org.game.Graphics.Renderable;\r\nimport main.java.org.game.Isten;\r\nimport main.java.org.game.Map.*;\r\nimport main.java.org.game.updatable.Updatable;\r\nimport main.java.org.linalg.Vec2;\r\n\r\nimport java.awt.*;\r\nimport java.awt.image.*;\r\nimport java.lang.reflect.Array;\r\nimport java.util.ArrayList;\r\nimport java.util.Arrays;\r\nimport java.util.Random;\r\n\r\npublic class Minimap extends Updatable {\r\n\r\n    private int displayedScale;\r\n\r\n    private final int width;\r\n    private final int height;\r\n\r\n    private final int pixelsPerUnit;\r\n    private final int wallWidthInPixels;\r\n\r\n    private ImageUI displayedImage=null;\r\n    private BufferedImage displayedImageData;\r\n    private int[] rawData;\r\n\r\n    private final Object syncObject=new Object();\r\n    private boolean canRerender=true;\r\n\r\n    public Minimap(int displayedScale, int res, int pixelsPerUnit, int wallWidthInPixels)\r\n    {\r\n        this.displayedScale=displayedScale;\r\n\r\n        this.width=res;\r\n        this.height=res;\r\n        this.pixelsPerUnit=pixelsPerUnit;\r\n        this.wallWidthInPixels=wallWidthInPixels;\r\n\r\n        rawData=new int[4*res*res];\r\n        displayedImageData=new BufferedImage(this.width, this.height, BufferedImage.TYPE_INT_ARGB);\r\n    }\r\n\r\n    @Override\r\n    public void onStart(Isten isten) {\r\n        displayedImage=new ImageUI();\r\n        displayedImage.setPosition(new Vec2(20,20));\r\n        displayedImage.setScale(new Vec2(displayedScale,displayedScale));\r\n        displayedImage.setSortingLayer(-69420);\r\n        displayedImage.setAlignment(Renderable.RIGHT, Renderable.BOTTOM);\r\n        displayedImage.setOrigin(Renderable.RIGHT, Renderable.BOTTOM);\r\n        displayedImage.setImage(displayedImageData);\r\n\r\n        isten.getRenderer().addRenderable(displayedImage);\r\n    }\r\n\r\n    @Override\r\n    public void onUpdate(Isten isten, double deltaTime) {\r\n        synchronized (syncObject)\r\n        {\r\n            if(canRerender==true)\r\n            {\r\n                canRerender=false;\r\n                Thread thread = new Thread(()->{this.draw(isten);});\r\n                thread.start();\r\n            }\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void onDestroy() {\r\n\r\n    }\r\n\r\n    private void draw(Isten isten)\r\n    {\r\n        Arrays.fill(rawData,0);//reset the content of the image\r\n\r\n        final Vec2 playerPos=isten.getPlayer().getPlayerCollider().getPosition().clone();\r\n\r\n        final Vec2 lowerBound=Vec2.subtract(playerPos, new Vec2(width*0.5f/pixelsPerUnit, height*0.5f/pixelsPerUnit));\r\n        final Vec2 upperBound=Vec2.sum(playerPos, new Vec2(width*0.5f/pixelsPerUnit, height*0.5f/pixelsPerUnit));\r\n        final Vec2 covered=Vec2.subtract(upperBound,lowerBound);\r\n        final Vec2 onePerCovered=new Vec2(1/covered.x, 1/covered.y);\r\n\r\n        /*ArrayList<Room> rooms = isten.getMap().getRooms();\r\n        if(rooms==null)\r\n            rooms=new ArrayList<>();\r\n\r\n        for(int i=0;i<rooms.size();i++)\r\n        {\r\n            //draw unit rooms\r\n            ArrayList<UnitRoom> unitRooms=rooms.get(i).getUnitRooms();\r\n            for(int j=0;j<unitRooms.size();j++)\r\n            {\r\n                Vec2 startPos=unitRooms.get(j).getPosition().clone();\r\n                startPos.x-=0.5f+lowerBound.x;\r\n                startPos.y-=0.5f+lowerBound.y;\r\n\r\n                if(startPos.x+1<0||startPos.y+1<0||startPos.x>covered.x||startPos.y>covered.y)\r\n                    continue;\r\n\r\n                startPos.y=covered.y-startPos.y-1;\r\n\r\n                int drawX, drawY;\r\n                drawX=Math.round(width*startPos.x* onePerCovered.x);\r\n                drawY=Math.round(height* startPos.y* onePerCovered.y);\r\n\r\n                for(int k=drawY>-1?drawY:0;k<height&&k<drawY+pixelsPerUnit;k++)\r\n                {\r\n                    for(int l=drawX>-1?drawX:0;l<width&&l<drawX+pixelsPerUnit;l++)\r\n                    {\r\n                        int index=4*(width*k+l);\r\n                        rawData[index++]=0;\r\n                        rawData[index++]=0;\r\n                        rawData[index++]=0;\r\n                        rawData[index]=255;\r\n                    }\r\n                }\r\n            }\r\n        }*/\r\n\r\n        //edging intensifies (drawing edges)\r\n        ArrayList<EdgeBetweenRooms> edges =isten.getMap().getEdgeManager().getRoomEdges();\r\n        for(int i=0;i<edges.size();i++)\r\n        {\r\n            ArrayList<EdgePiece> edgePieces=edges.get(i).getWalls();\r\n\r\n            for(int j=0;j<edgePieces.size();j++)\r\n            {\r\n                Vec2 startPos=edgePieces.get(j).getCollider().getPosition().clone();\r\n                Vec2 scale=edgePieces.get(j).getCollider().getScale();\r\n                startPos.x-=0.5f*scale.x+lowerBound.x;\r\n                startPos.y-=0.5f*scale.y+lowerBound.y;\r\n\r\n                if(startPos.x+1<0||startPos.y+1<0||startPos.x>covered.x||startPos.y>covered.y)\r\n                    continue;\r\n\r\n                startPos.y=covered.y-startPos.y-scale.y;\r\n\r\n                int drawX, drawY;\r\n                drawX=Math.round(width*startPos.x* onePerCovered.x);\r\n                drawY=Math.round(height* startPos.y* onePerCovered.y)+1;\r\n\r\n                int drawEndX=Math.round(scale.x*pixelsPerUnit);\r\n                int drawEndY=Math.round(scale.y*pixelsPerUnit);\r\n\r\n                if(drawEndX>drawEndY)\r\n                {\r\n                    drawX--;\r\n                    drawEndX+=drawX+wallWidthInPixels/2;\r\n                    drawEndY=drawY+wallWidthInPixels;\r\n                }\r\n                else\r\n                {\r\n                    drawY--;\r\n                    drawEndY+=drawY;\r\n                    drawEndX=drawX+wallWidthInPixels;\r\n                }\r\n\r\n                if(drawX<0)\r\n                    drawX=0;\r\n                if(drawY<0)\r\n                    drawY=0;\r\n                if(drawEndX>width)\r\n                    drawEndX=width;\r\n                if(drawEndY>height)\r\n                    drawEndY=height;\r\n\r\n                int r=255, g=255,b=255;\r\n                if(edgePieces.get(j) instanceof Door)\r\n                {\r\n                    //r=255;\r\n                    g=205;\r\n                    b=0;\r\n                }\r\n\r\n                for(int k=drawY;k<drawEndY;k++)\r\n                {\r\n                    for(int l=drawX;l<drawEndX;l++)\r\n                    {\r\n                        int index=4*(width*k+l);\r\n                        rawData[index++]=r;\r\n                        rawData[index++]=g;\r\n                        rawData[index++]=b;\r\n                        rawData[index]=255;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        //draw the great edges\r\n        do{\r\n            float mapSizeX, mapSizeY;\r\n            mapSizeX=isten.getMap().getMapColumnSize();\r\n            mapSizeY=isten.getMap().getMapRowSize();\r\n\r\n            float wallWidth=0.1f;\r\n\r\n            try{\r\n                Vec2 temp=isten.getMap().getEdgeManager().getRoomEdges().get(0).getWalls().get(0).getCollider().getScale();\r\n                wallWidth=temp.x>temp.y?temp.y:temp.x;\r\n            }\r\n            catch (Exception ex){}\r\n\r\n            Vec2[] positions=new Vec2[]{\r\n                    new Vec2(-0.5f, 0.5f*mapSizeY-0.5f),\r\n                    new Vec2(0.5f*mapSizeX-0.5f, mapSizeY-0.5f),\r\n                    new Vec2(mapSizeX-0.5f, 0.5f*mapSizeY-0.5f),\r\n                    new Vec2(0.5f*mapSizeX-0.5f,-0.5f)\r\n            };\r\n            Vec2[] scales=new Vec2[]{\r\n                    new Vec2(wallWidth, mapSizeY),\r\n                    new Vec2(mapSizeX, wallWidth),\r\n                    new Vec2(wallWidth, mapSizeY),\r\n                    new Vec2(mapSizeX, wallWidth)\r\n            };\r\n\r\n            for(int j=0;j<4;j++)\r\n            {\r\n                Vec2 startPos=positions[j].clone();\r\n                Vec2 scale=scales[j];\r\n                startPos.x-=0.5f*scale.x+lowerBound.x;\r\n                startPos.y-=0.5f*scale.y+lowerBound.y;\r\n                startPos.y=covered.y-startPos.y-scale.y;\r\n\r\n                int drawX, drawY;\r\n                drawX=Math.round(width*startPos.x* onePerCovered.x);\r\n                drawY=Math.round(height* startPos.y* onePerCovered.y)+1;\r\n\r\n                int drawEndX=Math.round(scale.x*pixelsPerUnit);\r\n                int drawEndY=Math.round(scale.y*pixelsPerUnit);\r\n\r\n                if(drawEndX>drawEndY)\r\n                {\r\n                    drawX--;\r\n                    drawEndX+=drawX+wallWidthInPixels/2;\r\n                    drawEndY=drawY+wallWidthInPixels;\r\n                }\r\n                else\r\n                {\r\n                    drawY--;\r\n                    drawEndY+=drawY;\r\n                    drawEndX=drawX+wallWidthInPixels;\r\n                }\r\n\r\n                if(drawX<0)\r\n                    drawX=0;\r\n                if(drawY<0)\r\n                    drawY=0;\r\n                if(drawEndX>width)\r\n                    drawEndX=width;\r\n                if(drawEndY>height)\r\n                    drawEndY=height;\r\n\r\n                for(int k=drawY;k<drawEndY;k++)\r\n                {\r\n                    for(int l=drawX;l<drawEndX;l++)\r\n                    {\r\n                        int index=4*(width*k+l);\r\n                        rawData[index++]=255;\r\n                        rawData[index++]=255;\r\n                        rawData[index++]=255;\r\n                        rawData[index]=255;\r\n                    }\r\n                }\r\n            }\r\n        } while(69==420);\r\n\r\n        //draw player\r\n        do{\r\n            for(int i=height/2-wallWidthInPixels;i<height/2+wallWidthInPixels+1;i++)\r\n            {\r\n                for (int j=width/2-wallWidthInPixels;j<width/2+wallWidthInPixels+1;j++)\r\n                {\r\n                    int currentIndex=4*(i*width+j);\r\n                    rawData[currentIndex++]=0;\r\n                    rawData[currentIndex++]=0;\r\n                    rawData[currentIndex++]=255;\r\n                    rawData[currentIndex]=255;\r\n                }\r\n            }\r\n        }while(69==420);\r\n\r\n        //apply transparency mask\r\n        int currentIndex=3;//offset to alpha value\r\n        float outerRadius=(float)Math.sqrt((width*0.5f)*(height*0.5f));\r\n        float innerRadius=outerRadius*0.9f;\r\n        float onePerInterpolationDistance=1/(outerRadius-innerRadius);\r\n        for(int row=0;row<height;row++)\r\n        {\r\n            for(int col=0;col<width;col++, currentIndex+=4)\r\n            {\r\n                float length=(float)Math.sqrt(Math.pow(row-height*0.5f,2)+Math.pow(col-width*0.5f,2));\r\n\r\n                if(rawData[currentIndex]==0)\r\n                    rawData[currentIndex]=128;\r\n\r\n                if(length<innerRadius)\r\n                {\r\n                    continue;\r\n                }\r\n                if(length>outerRadius)\r\n                {\r\n                    rawData[currentIndex]=0;\r\n                    continue;\r\n                }\r\n\r\n                rawData[currentIndex]=(int)((rawData[currentIndex]/255.0f)*(255-255*(length-innerRadius)*onePerInterpolationDistance));\r\n            }\r\n        }\r\n\r\n        displayedImageData.getRaster().setPixels(0,0, this.width, this.height, rawData);\r\n\r\n        synchronized (syncObject)\r\n        {\r\n            canRerender=true;\r\n        }\r\n    }\r\n}\r\n
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
-diff --git a/src/main/java/org/game/UI/Minimap.java b/src/main/java/org/game/UI/Minimap.java
---- a/src/main/java/org/game/UI/Minimap.java	
-+++ b/src/main/java/org/game/UI/Minimap.java	
-@@ -125,6 +125,9 @@
-         }*/
- 
-         //edging intensifies (drawing edges)
-+
-+        if(isten.getMap().getEdgeManager() != null) return;
-+
-         ArrayList<EdgeBetweenRooms> edges =isten.getMap().getEdgeManager().getRoomEdges();
-         for(int i=0;i<edges.size();i++)
-         {
-Index: src/main/java/org/items/ChestManager.java
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
-<+>package main.java.org.items;\r\n\r\nimport lombok.Getter;\r\nimport main.java.org.game.Isten;\r\nimport main.java.org.game.Map.Map;\r\nimport main.java.org.game.Map.UnitRoom;\r\nimport main.java.org.game.Map.Wall;\r\nimport main.java.org.game.physics.Collider;\r\nimport main.java.org.game.physics.ColliderGroup;\r\nimport main.java.org.game.updatable.Updatable;\r\nimport main.java.org.items.usable_items.*;\r\nimport main.java.org.linalg.Vec2;\r\nimport main.java.org.networking.Packet11ChestOpened;\r\n\r\nimport java.awt.event.KeyEvent;\r\nimport java.util.*;\r\n\r\nimport static java.lang.Math.sqrt;\r\n\r\n/**\r\n * This class generates chests around the map randomly.\r\n * Rules: There aren't any chests in front of doors.\r\n * Every chest is next to a wall and headed against the wall.\r\n */\r\npublic class ChestManager extends Updatable {\r\n    private Vector<Chest>chests=new Vector<>();\r\n    private  int chestCount;\r\n    private  Map map;\r\n    private Vector<UnitRoom> placeableUnitRooms = new Vector<>();//UnitRoom-ok, amelyikbe helyezhető láda (mivel ajtó mellé nem rakható láda)\r\n    private Vector<Boolean> isThereChest=new Vector<>();//igaz=van az azonos sorszámú unitroomban láda\r\n    /**\r\n     * @param n How many chests should be generated randomly across the map?\r\n     */\r\n    public ChestManager(int n){\r\n        chestCount=n;\r\n        map=null;\r\n    }\r\n    @Override\r\n    public void onStart(Isten isten) {\r\n\r\n    }\r\n\r\n    public void init(Isten isten) {\r\n        map=isten.getMap();\r\n        for (int i = 0; i < map.getUnitRooms().length; i++) {\r\n            for (int j = 0; j < map.getUnitRooms()[i].length; j++) {\r\n                UnitRoom unitRoomTmp=map.getUnitRooms()[i][j];\r\n                //megcsinaltam a unitroomot: van egy hasdoor valtozoja, es mindegyik uniroomrol le lehet kerdezni hogy melyik oldala fall\r\n                //fontos az ajtot is falnak veszi!!\r\n                //ezek a valtoztatasok a mapdrawing branchen elerhetoek(nem tudtam jol összrakni, nem vagyok jo git kezeko :) )\r\n                if(!unitRoomTmp.hasDoor()//ha egyik fal sem ajtó\r\n                        &&(unitRoomTmp.isTopWall()|| unitRoomTmp.isRightWall()|| unitRoomTmp.isBottomWall()|| unitRoomTmp.isLeftWall()))//ha egyik oldalán legalább fal van\r\n                {\r\n                    placeableUnitRooms.add(unitRoomTmp);\r\n                    isThereChest.add(false);\r\n                }\r\n            }\r\n        }\r\n        if(chestCount> placeableUnitRooms.size()) {\r\n            System.err.println(\"So many chests cant be generated!\");\r\n            chestCount=placeableUnitRooms.size();\r\n        }\r\n        Random rand=new Random();\r\n        int randomUnitRoom=rand.nextInt(placeableUnitRooms.size());\r\n        for (int h = 0; h < chestCount; h++) {\r\n            while(isThereChest.get(randomUnitRoom)){\r\n                randomUnitRoom=rand.nextInt(placeableUnitRooms.size());\r\n            }\r\n            WallLocation wall= wallInUnitRoomPicker(placeableUnitRooms.get(randomUnitRoom));\r\n            Vec2 chestPos=null;\r\n            switch (wall) {//0=left, 1=top, 2=right, 3=bottom\r\n                case LEFT: chestPos=new Vec2(placeableUnitRooms.get(randomUnitRoom).getPosition().x - 0.3f, placeableUnitRooms.get(randomUnitRoom).getPosition().y);break;\r\n                case TOP :chestPos=new Vec2(placeableUnitRooms.get(randomUnitRoom).getPosition().x, placeableUnitRooms.get(randomUnitRoom).getPosition().y + 0.3f);break;\r\n                case RIGHT: chestPos=new Vec2(placeableUnitRooms.get(randomUnitRoom).getPosition().x + 0.3f, placeableUnitRooms.get(randomUnitRoom).getPosition().y);break;\r\n                case BOTTOM: chestPos=new Vec2(placeableUnitRooms.get(randomUnitRoom).getPosition().x, placeableUnitRooms.get(randomUnitRoom).getPosition().y - 0.3f);break;\r\n            };\r\n            //CHEST TÍPUSOK, a networking miatt sokkal egyszerűbb így az itemeket átadni --> Chest.java/fillChest\r\n            chests.add(new Chest(chestPos,isten,wall.ordinal(),rand.nextInt(5)));\r\n            isThereChest.set(randomUnitRoom,true);\r\n        }\r\n        ColliderGroup chestColliders=new ColliderGroup();\r\n        for (int i = 0; i < chests.size(); i++) {\r\n            Collider c=new Collider(chests.get(i).getPosition(),new Vec2(0.15f,0.15f));\r\n            chestColliders.addCollider(c);\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void onUpdate(Isten isten, double deltaTime) {\r\n        if(isten.getInputHandler().isKeyDown(KeyEvent.VK_E)){\r\n            Vec2 playerPostion = isten.getPlayer().getPlayerCollider().getPosition();\r\n            int index = 0;\r\n            for(var chest : chests){\r\n                Vec2 playerChestVector = Vec2.subtract(playerPostion,chest.getPosition());\r\n                double playerChestDistance = sqrt(Vec2.dot(playerChestVector,playerChestVector));\r\n                if(playerChestDistance <= 0.5 && !chest.isOpened()){\r\n                    chest.open();\r\n                    isten.getSocketClient().sendData((\"11\"+index).getBytes());\r\n                    break;\r\n                }\r\n                index++;\r\n            }\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void onDestroy() {\r\n\r\n    }\r\n    private WallLocation wallInUnitRoomPicker(UnitRoom unitRoom ){\r\n\r\n        WallLocation wall;//0=left, 1=top, 2=right, 3=bottom\r\n        ArrayList<WallLocation> walls = new ArrayList<>();\r\n        if(unitRoom.isLeftWall())walls.add(WallLocation.LEFT);\r\n        if(unitRoom.isTopWall())walls.add(WallLocation.TOP);\r\n        if(unitRoom.isRightWall())walls.add(WallLocation.RIGHT);\r\n        if(unitRoom.isBottomWall()) walls.add(WallLocation.BOTTOM);\r\n\r\n        Random random = new Random();\r\n        return walls.get(random.nextInt(walls.size()));\r\n\r\n\r\n    }\r\n\r\n    public enum WallLocation {\r\n        LEFT,\r\n        TOP,\r\n        RIGHT,\r\n        BOTTOM\r\n    }\r\n\r\n    @Override\r\n    public Vector<Chest> getChests() { return chests; }\r\n}\r\n
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
-diff --git a/src/main/java/org/items/ChestManager.java b/src/main/java/org/items/ChestManager.java
---- a/src/main/java/org/items/ChestManager.java	
-+++ b/src/main/java/org/items/ChestManager.java	
-@@ -74,7 +74,7 @@
-                 case RIGHT: chestPos=new Vec2(placeableUnitRooms.get(randomUnitRoom).getPosition().x + 0.3f, placeableUnitRooms.get(randomUnitRoom).getPosition().y);break;
-                 case BOTTOM: chestPos=new Vec2(placeableUnitRooms.get(randomUnitRoom).getPosition().x, placeableUnitRooms.get(randomUnitRoom).getPosition().y - 0.3f);break;
-             };
--            //CHEST TÍPUSOK, a networking miatt sokkal egyszerűbb így az itemeket átadni --> Chest.java/fillChest
-+            //CHEST TIPUSOK, a networking miatt sokkal egyszerubb így az itemeket atadni --> Chest.java/fillChest
-             chests.add(new Chest(chestPos,isten,wall.ordinal(),rand.nextInt(5)));
-             isThereChest.set(randomUnitRoom,true);
-         }
-Index: src/main/java/org/game/Isten.java
-IDEA additional info:
-Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
-<+>package main.java.org.game;\r\n\r\nimport main.java.org.entities.villain.Villain;\r\nimport main.java.org.game.Camera.Camera;\r\nimport main.java.org.game.Graphics.*;\r\n\r\nimport main.java.org.entities.player.Player;\r\n\r\nimport main.java.org.game.Input.Input;\r\nimport main.java.org.game.Map.Map;\r\nimport main.java.org.game.PlayerPrefs.PlayerPrefs;\r\nimport main.java.org.game.UI.*;\r\nimport main.java.org.game.physics.PhysicsEngine;\r\nimport main.java.org.game.updatable.Updatable;\r\nimport main.java.org.linalg.Vec2;\r\n\r\nimport main.java.org.items.ChestManager;\r\nimport main.java.org.items.ItemManager;\r\n\r\nimport main.java.org.networking.*;\r\n\r\nimport javax.swing.*;\r\n\r\nimport java.util.ArrayList;\r\n\r\n/**\r\n * The main class representing the game part of the program.\r\n */\r\npublic class Isten {\r\n    private HandlerManager handlerManager;\r\n    private final PhysicsEngine physicsEngine;\r\n    protected final GameRenderer renderer;\r\n    protected final ArrayList<Updatable> updatables;\r\n    private final ArrayList<Updatable> pendingAddedUpdatables;\r\n    private final ArrayList<Updatable> pendingRemovedUpdatables;\r\n\r\n    private Map map;\r\n    private Inventory inventory;\r\n    private final Input inputHandler;\r\n    private final ItemManager itemManager;\r\n\r\n    private final Camera camera;\r\n\r\n    private GameClient socketClient;\r\n    private GameServer socketServer;\r\n\r\n    private PlayerMP player;\r\n    private ChestManager chestManager;\r\n    /**\r\n     * Constructor for Isten.\r\n     * Initializes the physics engine, game renderer, and list of updatables.\r\n     */\r\n    public Isten() {\r\n        inventory=new Inventory(5);\r\n        map=new Map(20, 20, 10);\r\n        chestManager = new ChestManager(75);\r\n        itemManager=new ItemManager();\r\n        inputHandler = new Input();\r\n        camera = new Camera();\r\n        physicsEngine = new PhysicsEngine();\r\n        renderer = new GameRenderer(camera, inputHandler);\r\n        updatables = new ArrayList<>();\r\n        pendingAddedUpdatables = new ArrayList<>();\r\n        pendingRemovedUpdatables = new ArrayList<>();\r\n\r\n\r\n        handlerManager = new HandlerManager(this);\r\n    }\r\n\r\n    /**\r\n     * Method to update the game state.\r\n     *\r\n     * @param deltaTime The time elapsed since the last update\r\n     */\r\n    public void update(double deltaTime) {\r\n\r\n\r\n        inputHandler.update();\r\n\r\n        if(socketServer == null || socketServer.isInitialized()) physicsEngine.step(deltaTime);\r\n\r\n\r\n        //remove pending updatables from updatables\r\n        for (Updatable u : pendingRemovedUpdatables)\r\n            if (!u.isDestroyed()) {\r\n                u.setDestroyedTrue();\r\n                u.onDestroy();\r\n            }\r\n        updatables.removeAll(pendingRemovedUpdatables);\r\n        pendingRemovedUpdatables.clear();\r\n\r\n        //add pending updatables to updatables\r\n        updatables.addAll(pendingAddedUpdatables);\r\n        pendingAddedUpdatables.clear();\r\n\r\n        //check if updatable has been initialized\r\n        for (Updatable u : updatables)\r\n            if (!u.isInitialized()) {\r\n                u.setInitializedTrue();\r\n                u.onStart(this);\r\n            }\r\n\r\n\r\n        //call onUpdates\r\n        for (Updatable u : updatables)\r\n            u.onUpdate(this, deltaTime);\r\n\r\n\r\n        //ServerUpdate\r\n        if(socketServer != null) {\r\n            socketServer.updateServer(this, deltaTime);\r\n        }\r\n\r\n\r\n\r\n        //Manage handlers of client\r\n        handlerManager.executeTasks();\r\n\r\n\r\n        //calculate render positions, check for UI inputs and then render\r\n        renderer.calculateRenderedPositions();\r\n        renderer.processUIInputs(inputHandler);\r\n        renderer.repaint();\r\n    }\r\n\r\n    /**\r\n     * Method to initialize the game.\r\n     */\r\n\r\n    public void initMP() {\r\n        //Set localPlayer to true, so that only this player can be moved and followed by the camera on this client\r\n        player = new PlayerMP(JOptionPane.showInputDialog(this.getRenderer(),\"Username\"),null,-1);\r\n\r\n\r\n        player.localPlayer = true;\r\n\r\n        addUpdatables();\r\n        addRenderables();\r\n\r\n        int skinID = PlayerPrefs.getInt(\"skin\");\r\n        player.setSkinID(skinID);\r\n        Packet00Login loginPacket = new Packet00Login(player.getUsername(), 0, 0, skinID);\r\n\r\n        if(socketServer != null) {\r\n            socketServer.addConnection(player,loginPacket);\r\n        }\r\n\r\n        if(JOptionPane.showConfirmDialog(this.getRenderer(), \"Server?\") == 0) {\r\n            socketServer = new GameServer(this);\r\n            socketServer.start();\r\n\r\n        }\r\n        socketClient = new GameClient(this, \"localhost\");\r\n        socketClient.start();\r\n\r\n        loginPacket.writeData(socketClient);\r\n\r\n        update(0);\r\n    }\r\n    public void init() {\r\n        //Create own player\r\n        player = new PlayerMP(JOptionPane.showInputDialog(this.getRenderer(),\"Username\"),null,-1);\r\n\r\n        player.localPlayer = true;\r\n\r\n        addUpdatables();\r\n        addRenderables();\r\n\r\n        int skinID = PlayerPrefs.getInt(\"skin\");\r\n        player.setSkinID(skinID);\r\n        Packet00Login loginPacket = new Packet00Login(player.getUsername(), 0, 0, skinID);\r\n\r\n        if(socketServer != null) {\r\n            socketServer.addConnection(player,loginPacket);\r\n        }\r\n\r\n        socketServer = new GameServer(this);\r\n        socketServer.start();\r\n\r\n        socketClient = new GameClient(this, \"localhost\");\r\n        socketClient.start();\r\n\r\n        loginPacket.writeData(socketClient);\r\n    }\r\n\r\n    /**\r\n     * Method to add renderable objects to the game renderer.\r\n     */\r\n    protected void addRenderables() {\r\n    }\r\n\r\n    /**\r\n     * Method to add updatable objects to the game.\r\n     */\r\n    protected void addUpdatables() {\r\n\r\n        updatables.add(player);\r\n        updatables.add(itemManager);\r\n        updatables.add(inventory);\r\n        updatables.add(map);\r\n\r\n        updatables.add(chestManager);//majd a játékba nem kell 500 láda, csak szemléltetésképp kell ilyen sok\r\n\r\n\r\n        updatables.add(new TimeCounter());\r\n        updatables.add(new Help());\r\n        updatables.add(new GameMenu());\r\n\r\n        updatables.add(new Minimap(200,200,20,2));\r\n    }\r\n\r\n    /**\r\n     * Method to get the game renderer.\r\n     *\r\n     * @return The game renderer\r\n     */\r\n    public GameRenderer getRenderer() {\r\n        return renderer;\r\n    }\r\n\r\n    /**\r\n     * returns the physics engine of the isten\r\n     */\r\n    public PhysicsEngine getPhysicsEngine() {\r\n        return physicsEngine;\r\n    }\r\n\r\n    /**\r\n     * returns the inputhandler of the isten\r\n     */\r\n    public Input getInputHandler() {\r\n        return inputHandler;\r\n    }\r\n\r\n    /**\r\n     * returns the camera of the isten\r\n     */\r\n    public Camera getCamera() {\r\n        return this.camera;\r\n    }\r\n\r\n    public Player getPlayer(){return player;}\r\n    public Inventory getInventory(){return inventory;}\r\n    public ItemManager getItemManager(){return itemManager;}\r\n    public Map getMap(){return map;}\r\n\r\n    public void addUpdatable(Updatable u) {\r\n        pendingAddedUpdatables.add(u);\r\n    }\r\n\r\n    public void removeUpdatable(Updatable u) {\r\n        pendingRemovedUpdatables.add(u);\r\n    }\r\n\r\n    public int getPlayerMPIndex(String username) {\r\n        int index = 0;\r\n        for(int i = 0; i < updatables.size(); i++) {\r\n            Updatable u = updatables.get(i);\r\n            if(u instanceof PlayerMP) {\r\n                if(((PlayerMP)u).getUsername().equalsIgnoreCase(username)) {\r\n                    break;\r\n                }\r\n\r\n            }\r\n            index++;\r\n        }\r\n        return index;\r\n    }\r\n\r\n    public int getVillainIndex(String villainName) {\r\n        int index = 0;\r\n        for(int i = 0; i < updatables.size(); i++) {\r\n            Updatable u = updatables.get(i);\r\n            if(u instanceof Villain) {\r\n                if(((Villain)u).getVillainName().equalsIgnoreCase(villainName)) {\r\n                    break;\r\n                }\r\n\r\n            }\r\n            index++;\r\n        }\r\n        return index;\r\n    }\r\n    public Updatable getUpdatable(int index) {\r\n        if(index >= updatables.size()) return null;\r\n        return updatables.get(index);\r\n    }\r\n\r\n    /**\r\n     * returns an ArrayList of updatables of the given type <br>\r\n     * <br>\r\n     * how to use it:\r\n     * ArrayList< Player> alma=new ArrayList<>();\r\n     * alma = isten.getUpdatablesByType(Player.class);\r\n     * @param type the Class of the elements\r\n     * @return an array list of elements\r\n     * @param <E> the type of the queried elements\r\n     */\r\n    public final <E extends Updatable> ArrayList<E> getUpdatablesByType(Class<E> type)\r\n    {\r\n        ArrayList<E> tempList=new ArrayList<>();\r\n        for(int i=0;i<updatables.size();i++)\r\n        {\r\n            if(type.isInstance(updatables.get(i)))\r\n                tempList.add((E)updatables.get(i));\r\n        }\r\n\r\n        return tempList;\r\n    }\r\n\r\n    public GameClient getSocketClient() {\r\n        return socketClient;\r\n    }\r\n\r\n    public ArrayList<Updatable> getUpdatables() {\r\n        return updatables;\r\n    }\r\n\r\n    public GameServer getSocketServer() {\r\n        return socketServer;\r\n    }\r\n\r\n    public HandlerManager getHandlerManager() {\r\n        return handlerManager;\r\n    }\r\n\r\n    public ChestManager getChestManager() { return chestManager; }\r\n}\r\n
-Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
-<+>UTF-8
-===================================================================
-diff --git a/src/main/java/org/game/Isten.java b/src/main/java/org/game/Isten.java
---- a/src/main/java/org/game/Isten.java	
-+++ b/src/main/java/org/game/Isten.java	
-@@ -1,4 +1,4 @@
--package main.java.org.game;
-+    package main.java.org.game;
- 
- import main.java.org.entities.villain.Villain;
- import main.java.org.game.Camera.Camera;
-@@ -52,7 +52,7 @@
-      */
-     public Isten() {
-         inventory=new Inventory(5);
--        map=new Map(20, 20, 10);
-+        map=new Map(this, 20, 20, 10);
-         chestManager = new ChestManager(75);
-         itemManager=new ItemManager();
-         inputHandler = new Input();
Index: .idea/shelf/Uncommitted_changes_before_Checkout_at_2024__05__02__15_12__Changes_1.xml
===================================================================
diff --git a/.idea/shelf/Uncommitted_changes_before_Checkout_at_2024__05__02__15_12__Changes_1.xml b/.idea/shelf/Uncommitted_changes_before_Checkout_at_2024__05__02__15_12__Changes_1.xml
deleted file mode 100644
--- a/.idea/shelf/Uncommitted_changes_before_Checkout_at_2024__05__02__15_12__Changes_1.xml	(revision 072d073c088012b37a1d4a123bd6255c2258b9ce)
+++ /dev/null	(revision 072d073c088012b37a1d4a123bd6255c2258b9ce)
@@ -1,4 +0,0 @@
-<changelist name="Uncommitted_changes_before_Checkout_at_2024__05__02__15_12_[Changes]1" date="1714655550473" recycled="true" deleted="true">
-  <option name="PATH" value="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Checkout_at_2024__05__02__15_12_[Changes]1/shelved.patch" />
-  <option name="DESCRIPTION" value="Uncommitted changes before Checkout at 2024. 05. 02. 15:12 [Changes]" />
-</changelist>
\ No newline at end of file
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"AutoImportSettings\">\r\n    <option name=\"autoReloadType\" value=\"SELECTIVE\" />\r\n  </component>\r\n  <component name=\"ChangeListManager\">\r\n    <list default=\"true\" id=\"3506ab6d-0407-47f2-a7e8-78ebc867e577\" name=\"Changes\" comment=\"it's working\">\r\n      <change afterPath=\"$PROJECT_DIR$/src/main/java/org/networking/Packet27VillainIsInGasRoom.java\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/.idea/misc.xml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/misc.xml\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_2024__05__06__14_25__Changes_.xml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_2024__05__06__14_25__Changes_.xml\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/.idea/workspace.xml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/workspace.xml\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/src/main/java/org/entities/villain/Villain.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/main/java/org/entities/villain/Villain.java\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/src/main/java/org/game/Isten.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/main/java/org/game/Isten.java\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/src/main/java/org/networking/GameClient.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/main/java/org/networking/GameClient.java\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/src/main/java/org/networking/HandlerManager.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/main/java/org/networking/HandlerManager.java\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/src/main/java/org/networking/MapHandler.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/main/java/org/networking/MapHandler.java\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/src/main/java/org/networking/Packet.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/main/java/org/networking/Packet.java\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/src/main/java/org/networking/Packet05Villain.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/main/java/org/networking/Packet05Villain.java\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/src/main/java/org/networking/VillainHandler.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/main/java/org/networking/VillainHandler.java\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/test/MultiplayerTester.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/test/MultiplayerTester.java\" afterDir=\"false\" />\r\n    </list>\r\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\r\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\r\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\r\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\r\n  </component>\r\n  <component name=\"ExternalProjectsData\">\r\n    <projectState path=\"$PROJECT_DIR$\">\r\n      <ProjectState />\r\n    </projectState>\r\n  </component>\r\n  <component name=\"ExternalProjectsManager\">\r\n    <system id=\"GRADLE\">\r\n      <state>\r\n        <task path=\"$PROJECT_DIR$\">\r\n          <activation />\r\n        </task>\r\n        <projects_view>\r\n          <tree_state>\r\n            <expand />\r\n            <select />\r\n          </tree_state>\r\n        </projects_view>\r\n      </state>\r\n    </system>\r\n  </component>\r\n  <component name=\"FileTemplateManagerImpl\">\r\n    <option name=\"RECENT_TEMPLATES\">\r\n      <list>\r\n        <option value=\"Interface\" />\r\n        <option value=\"Class\" />\r\n      </list>\r\n    </option>\r\n  </component>\r\n  <component name=\"Git.Settings\">\r\n    <option name=\"RECENT_BRANCH_BY_REPOSITORY\">\r\n      <map>\r\n        <entry key=\"$PROJECT_DIR$\" value=\"5cd5399fbfcfd5811c762cb41388070c81f45885\" />\r\n      </map>\r\n    </option>\r\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\r\n  </component>\r\n  <component name=\"MarkdownSettingsMigration\">\r\n    <option name=\"stateVersion\" value=\"1\" />\r\n  </component>\r\n  <component name=\"ProjectColorInfo\">{\r\n  &quot;associatedIndex&quot;: 8\r\n}</component>\r\n  <component name=\"ProjectId\" id=\"2frbzqFlsraLkUjUjuqMYUBt0BV\" />\r\n  <component name=\"ProjectViewState\">\r\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\r\n    <option name=\"showLibraryContents\" value=\"true\" />\r\n  </component>\r\n  <component name=\"PropertiesComponent\">{\r\n  &quot;keyToString&quot;: {\r\n    &quot;Downloaded.Files.Path.Enabled&quot;: &quot;false&quot;,\r\n    &quot;Gradle.MultiplayerTester.executor&quot;: &quot;Run&quot;,\r\n    &quot;Gradle.MultiplayerTester.testPacket01.executor&quot;: &quot;Run&quot;,\r\n    &quot;Gradle.MultiplayerTester.testPacket02Constructor.executor&quot;: &quot;Run&quot;,\r\n    &quot;Gradle.iLaby [:Main.main()].executor&quot;: &quot;Run&quot;,\r\n    &quot;Gradle.iLaby [run].executor&quot;: &quot;Run&quot;,\r\n    &quot;Repository.Attach.Annotations&quot;: &quot;false&quot;,\r\n    &quot;Repository.Attach.JavaDocs&quot;: &quot;false&quot;,\r\n    &quot;Repository.Attach.Sources&quot;: &quot;false&quot;,\r\n    &quot;RunOnceActivity.OpenProjectViewOnStart&quot;: &quot;true&quot;,\r\n    &quot;RunOnceActivity.ShowReadmeOnStart&quot;: &quot;true&quot;,\r\n    &quot;WebServerToolWindowFactoryState&quot;: &quot;false&quot;,\r\n    &quot;git-widget-placeholder&quot;: &quot;main&quot;,\r\n    &quot;kotlin-language-version-configured&quot;: &quot;true&quot;,\r\n    &quot;last_opened_file_path&quot;: &quot;C:/Users/kuruc/Downloads/junit-4.13.2.jar&quot;,\r\n    &quot;node.js.detected.package.eslint&quot;: &quot;true&quot;,\r\n    &quot;node.js.detected.package.tslint&quot;: &quot;true&quot;,\r\n    &quot;node.js.selected.package.eslint&quot;: &quot;(autodetect)&quot;,\r\n    &quot;node.js.selected.package.tslint&quot;: &quot;(autodetect)&quot;,\r\n    &quot;nodejs_package_manager_path&quot;: &quot;npm&quot;,\r\n    &quot;project.structure.last.edited&quot;: &quot;Modules&quot;,\r\n    &quot;project.structure.proportion&quot;: &quot;0.15&quot;,\r\n    &quot;project.structure.side.proportion&quot;: &quot;0.2&quot;,\r\n    &quot;settings.editor.selected.configurable&quot;: &quot;reference.settingsdialog.project.gradle&quot;,\r\n    &quot;vue.rearranger.settings.migration&quot;: &quot;true&quot;\r\n  }\r\n}</component>\r\n  <component name=\"RunManager\" selected=\"Gradle.iLaby [run]\">\r\n    <configuration name=\"MultiplayerTester\" type=\"GradleRunConfiguration\" factoryName=\"Gradle\" temporary=\"true\">\r\n      <ExternalSystemSettings>\r\n        <option name=\"executionName\" />\r\n        <option name=\"externalProjectPath\" value=\"$PROJECT_DIR$\" />\r\n        <option name=\"externalSystemIdString\" value=\"GRADLE\" />\r\n        <option name=\"scriptParameters\" value=\"\" />\r\n        <option name=\"taskDescriptions\">\r\n          <list />\r\n        </option>\r\n        <option name=\"taskNames\">\r\n          <list>\r\n            <option value=\":test\" />\r\n            <option value=\"--tests\" />\r\n            <option value=\"&quot;MultiplayerTester&quot;\" />\r\n          </list>\r\n        </option>\r\n        <option name=\"vmOptions\" />\r\n      </ExternalSystemSettings>\r\n      <ExternalSystemDebugServerProcess>false</ExternalSystemDebugServerProcess>\r\n      <ExternalSystemReattachDebugProcess>true</ExternalSystemReattachDebugProcess>\r\n      <DebugAllEnabled>false</DebugAllEnabled>\r\n      <RunAsTest>true</RunAsTest>\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration name=\"MultiplayerTester.testPacket01\" type=\"GradleRunConfiguration\" factoryName=\"Gradle\" temporary=\"true\">\r\n      <ExternalSystemSettings>\r\n        <option name=\"executionName\" />\r\n        <option name=\"externalProjectPath\" value=\"$PROJECT_DIR$\" />\r\n        <option name=\"externalSystemIdString\" value=\"GRADLE\" />\r\n        <option name=\"scriptParameters\" value=\"\" />\r\n        <option name=\"taskDescriptions\">\r\n          <list />\r\n        </option>\r\n        <option name=\"taskNames\">\r\n          <list>\r\n            <option value=\":test\" />\r\n            <option value=\"--tests\" />\r\n            <option value=\"&quot;MultiplayerTester.testPacket01&quot;\" />\r\n          </list>\r\n        </option>\r\n        <option name=\"vmOptions\" />\r\n      </ExternalSystemSettings>\r\n      <ExternalSystemDebugServerProcess>false</ExternalSystemDebugServerProcess>\r\n      <ExternalSystemReattachDebugProcess>true</ExternalSystemReattachDebugProcess>\r\n      <DebugAllEnabled>false</DebugAllEnabled>\r\n      <RunAsTest>true</RunAsTest>\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration name=\"MultiplayerTester.testPacket02Constructor\" type=\"GradleRunConfiguration\" factoryName=\"Gradle\" temporary=\"true\">\r\n      <ExternalSystemSettings>\r\n        <option name=\"executionName\" />\r\n        <option name=\"externalProjectPath\" value=\"$PROJECT_DIR$\" />\r\n        <option name=\"externalSystemIdString\" value=\"GRADLE\" />\r\n        <option name=\"scriptParameters\" value=\"\" />\r\n        <option name=\"taskDescriptions\">\r\n          <list />\r\n        </option>\r\n        <option name=\"taskNames\">\r\n          <list>\r\n            <option value=\":test\" />\r\n            <option value=\"--tests\" />\r\n            <option value=\"&quot;MultiplayerTester.testPacket02Constructor&quot;\" />\r\n          </list>\r\n        </option>\r\n        <option name=\"vmOptions\" />\r\n      </ExternalSystemSettings>\r\n      <ExternalSystemDebugServerProcess>false</ExternalSystemDebugServerProcess>\r\n      <ExternalSystemReattachDebugProcess>true</ExternalSystemReattachDebugProcess>\r\n      <DebugAllEnabled>false</DebugAllEnabled>\r\n      <RunAsTest>true</RunAsTest>\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <configuration name=\"iLaby [run]\" type=\"GradleRunConfiguration\" factoryName=\"Gradle\" singleton=\"false\" nameIsGenerated=\"true\">\r\n      <ExternalSystemSettings>\r\n        <option name=\"executionName\" />\r\n        <option name=\"externalProjectPath\" value=\"$PROJECT_DIR$\" />\r\n        <option name=\"externalSystemIdString\" value=\"GRADLE\" />\r\n        <option name=\"scriptParameters\" value=\"\" />\r\n        <option name=\"taskDescriptions\">\r\n          <list />\r\n        </option>\r\n        <option name=\"taskNames\">\r\n          <list>\r\n            <option value=\"run\" />\r\n          </list>\r\n        </option>\r\n        <option name=\"vmOptions\" />\r\n      </ExternalSystemSettings>\r\n      <ExternalSystemDebugServerProcess>true</ExternalSystemDebugServerProcess>\r\n      <ExternalSystemReattachDebugProcess>true</ExternalSystemReattachDebugProcess>\r\n      <DebugAllEnabled>false</DebugAllEnabled>\r\n      <RunAsTest>false</RunAsTest>\r\n      <method v=\"2\" />\r\n    </configuration>\r\n    <list>\r\n      <item itemvalue=\"Gradle.iLaby [run]\" />\r\n      <item itemvalue=\"Gradle.MultiplayerTester\" />\r\n      <item itemvalue=\"Gradle.MultiplayerTester.testPacket02Constructor\" />\r\n      <item itemvalue=\"Gradle.MultiplayerTester.testPacket01\" />\r\n    </list>\r\n    <recent_temporary>\r\n      <list>\r\n        <item itemvalue=\"Gradle.MultiplayerTester.testPacket01\" />\r\n        <item itemvalue=\"Gradle.MultiplayerTester.testPacket02Constructor\" />\r\n        <item itemvalue=\"Gradle.MultiplayerTester\" />\r\n        <item itemvalue=\"Gradle.MultiplayerTester\" />\r\n        <item itemvalue=\"Gradle.MultiplayerTester.testPacket02Constructor\" />\r\n      </list>\r\n    </recent_temporary>\r\n  </component>\r\n  <component name=\"SharedIndexes\">\r\n    <attachedChunks>\r\n      <set>\r\n        <option value=\"jdk-18.0.2-corretto-18.0.2-4caba194b151-5720f15e\" />\r\n        <option value=\"jdk-21.0.2-openjdk-21.0.2-4caba194b151-4f524021\" />\r\n      </set>\r\n    </attachedChunks>\r\n  </component>\r\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"application-level\" UseSingleDictionary=\"true\" transferred=\"true\" />\r\n  <component name=\"TaskManager\">\r\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\r\n      <changelist id=\"3506ab6d-0407-47f2-a7e8-78ebc867e577\" name=\"Changes\" comment=\"\" />\r\n      <created>1714562409879</created>\r\n      <option name=\"number\" value=\"Default\" />\r\n      <option name=\"presentableId\" value=\"Default\" />\r\n      <updated>1714562409879</updated>\r\n      <workItem from=\"1714562410886\" duration=\"908000\" />\r\n      <workItem from=\"1714687853059\" duration=\"1015000\" />\r\n      <workItem from=\"1714731678095\" duration=\"398000\" />\r\n      <workItem from=\"1714740938116\" duration=\"2592000\" />\r\n      <workItem from=\"1714743658125\" duration=\"732000\" />\r\n      <workItem from=\"1714747759256\" duration=\"7383000\" />\r\n      <workItem from=\"1714847163651\" duration=\"324000\" />\r\n      <workItem from=\"1714924570656\" duration=\"7744000\" />\r\n      <workItem from=\"1715002935390\" duration=\"1974000\" />\r\n    </task>\r\n    <task id=\"LOCAL-00001\" summary=\"it's working\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1714665384490</created>\r\n      <option name=\"number\" value=\"00001\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00001\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1714665384490</updated>\r\n    </task>\r\n    <option name=\"localTasksCounter\" value=\"2\" />\r\n    <servers />\r\n  </component>\r\n  <component name=\"TypeScriptGeneratedFilesManager\">\r\n    <option name=\"version\" value=\"3\" />\r\n  </component>\r\n  <component name=\"Vcs.Log.Tabs.Properties\">\r\n    <option name=\"TAB_STATES\">\r\n      <map>\r\n        <entry key=\"MAIN\">\r\n          <value>\r\n            <State />\r\n          </value>\r\n        </entry>\r\n      </map>\r\n    </option>\r\n  </component>\r\n  <component name=\"VcsManagerConfiguration\">\r\n    <MESSAGE value=\"it's working\" />\r\n    <option name=\"LAST_COMMIT_MESSAGE\" value=\"it's working\" />\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	(revision 072d073c088012b37a1d4a123bd6255c2258b9ce)
+++ b/.idea/workspace.xml	(date 1715277468066)
@@ -5,19 +5,7 @@
   </component>
   <component name="ChangeListManager">
     <list default="true" id="3506ab6d-0407-47f2-a7e8-78ebc867e577" name="Changes" comment="it's working">
-      <change afterPath="$PROJECT_DIR$/src/main/java/org/networking/Packet27VillainIsInGasRoom.java" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/.idea/misc.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/misc.xml" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_2024__05__06__14_25__Changes_.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_2024__05__06__14_25__Changes_.xml" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/src/main/java/org/entities/villain/Villain.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/org/entities/villain/Villain.java" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/src/main/java/org/game/Isten.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/org/game/Isten.java" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/src/main/java/org/networking/GameClient.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/org/networking/GameClient.java" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/src/main/java/org/networking/HandlerManager.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/org/networking/HandlerManager.java" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/src/main/java/org/networking/MapHandler.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/org/networking/MapHandler.java" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/src/main/java/org/networking/Packet.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/org/networking/Packet.java" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/src/main/java/org/networking/Packet05Villain.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/org/networking/Packet05Villain.java" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/src/main/java/org/networking/VillainHandler.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/main/java/org/networking/VillainHandler.java" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/test/MultiplayerTester.java" beforeDir="false" afterPath="$PROJECT_DIR$/test/MultiplayerTester.java" afterDir="false" />
     </list>
     <option name="SHOW_DIALOG" value="false" />
     <option name="HIGHLIGHT_CONFLICTS" value="true" />
diff --git a/.idea/shelf/Uncommitted_changes_before_Update_at_01_05_2024_13_06_[Changes]/shelved.patch b/.idea/shelf/Uncommitted_changes_before_Update_at_01_05_2024_13_06_[Changes]/shelved.patch
deleted file mode 100644
